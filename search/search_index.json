{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#t3co-transportation-technology-total-cost-of-ownership-tool","title":"T3CO : Transportation Technology Total Cost of Ownership Tool","text":""},{"location":"#description","title":"Description","text":"<p>This repo houses T3CO (Transportation Technology Total Cost of Ownership), software for modeling total cost of ownership for commercial vehicles with advanced powertrains.</p> <p>To learn about the models, go to the Overview</p> <p>To get started with the tool, go to the Installation Guide</p> <p>To run your first analysis after installing T3CO, go to the Quick Start Guide</p>"},{"location":"#usage","title":"Usage","text":"<p>T3CO is a general framework allowing a user to determine the total cost of ownership (TCO) of a FASTSim vehicle (paired with a FASTSim DriveCycle(s) for determining fuel efficiency). The user can also determine performance of gradability, acceleration, and range. In addition to straight TCO computation there is also the option to optimize a vehicle powertrain such that it meets performance optional targets while also optionally minimizing TCO.</p>"},{"location":"CodeFlow/","title":"General Code Flow","text":"<ul> <li> <p>Generally, start things off in <code>sweep.py</code> with a command like      Text Only<pre><code>python sweep.py -selections [23,24,25,26] -vehicles /path/to/vehiclesfile.csv -scenarios /path/to/scenariosfile.csv\n</code></pre>     The <code>-vehicles</code> argument points to the vehicles input file.     The <code>-scenarios</code> argument points to the scenarios input file.     These two files are linked with an index column called <code>selection</code>, representing the row from each file to use. <code>FASTSim Vehicles</code> and <code>Scenarios</code> are the core data structures in T3CO</p> <p>Example of Scenario inputs.</p> <p>Example of FASTSim vehicle inputs.</p> </li> <li> <p>Sweep Code sweeps through selected scenarios, in this case <code>[23,24,25,26]</code></p> </li> <li><code>for selection, scenario_name in vehicles.index, vehicles.scenario_name</code></li> <li><code>if selection in [23,24,25,26]: optimize(selection, scenario_name)</code> link </li> <li><code>optimize</code> can optimize the vehicle and scenario, or it can skip optimizing compute TCO from vehicle and scenario inputs and report that</li> <li><code>if optimizing</code><ul> <li><code>run_moo(selection int, scenarios DataFrame, *args, **kwargs)</code> link</li> <li>get get knobs-bounds &amp; curves</li> <li>note: optimization parameters (knobs) are implicitly activated by their minimum and maximum bounds being populated. See Scenario inputs. For example, if the row for your selection has populated values in columns <code>knob_min_ess_kwh</code> and <code>knob_max_ess_kwh</code> then that tells the optimizer that battery size, <code>ess_kwh</code>, is an optimization parameter (knob). The curves work the same way, for example <code>eng_eff_imp_curve_sel</code> being populated means that the opimization parameter for engine efficiency should be used.</li> <li>get objectives and constraints</li> <li>note: unlike knobs, constraints need to be explicitly turned on with <code>True</code>. For example: The Scenario file will have <code>constraint_range</code> value of <code>True</code>, and by necessity the target range must be specified as well, in <code>target_range_mi</code> </li> <li>begin optimization loop</li> </ul> </li> </ul> Text Only<pre><code>while lowest TCO not found by PyMoo, for, say, vehicle &amp; selection 23:\n  ______________________________                                                                                                    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n \u2571                              \u2572                                                                                                   \u2502return optimized\u2502\n\u2571 lowest TCO found while meeting \u2572__________________________________________________________________________________________________\u2502parameters      \u2502\n\u2572 grade and accel constraints    \u2571yes                                                                                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n \u2572______________________________\u2571                                                                                                                \n                \u2502no                                                                                                                              \n     ___________\u25bd___________     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                                \n    \u2571                       \u2572    \u2502try new chassis weight, code:                 \u2502                                                                \n   \u2571 chassis light-weighting \u2572___\u2502weight_delta_percent_knob(wt_delta_perc_guess,\u2502                                                                \n   \u2572 knob active             \u2571yes\u2502optvehicle)                                   \u2502                                                                \n    \u2572_______________________\u2571    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                \n                \u2502no                                      \u2502                                                                                       \n                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                       \n                     ______\u25bd_______     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                             \n                    \u2571              \u2572    \u2502try new drag coeff, code:                 \u2502                                                             \n                   \u2571 CdA drag coeff \u2572___\u2502cda_percent_delta_knob(CdA_reduction_perc,\u2502                                                             \n                   \u2572 knob active    \u2571yes\u2502optvehicle)                               \u2502                                                             \n                    \u2572______________\u2571    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                             \n                           \u2502no                                \u2502                                                                                  \n                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                                  \n                             ________\u25bd________     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                                       \n                            \u2571                 \u2572    \u2502try new peak engine efficiency, code:\u2502                                                       \n                           \u2571 engine efficiency \u2572___\u2502fc_peak_eff_knob(fc_peak_eff_guess,  \u2502                                                       \n                           \u2572 knob active       \u2571yes\u2502optvehicle)                          \u2502                                                       \n                            \u2572_________________\u2571    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                       \n                                     \u2502no                              \u2502                                                                          \n                                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                          \n                                       _______\u25bd________     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                             \n                                      \u2571                \u2572    \u2502try new engine size [kw], code:       \u2502                                             \n                                     \u2571 engine size [kw] \u2572___\u2502run_scenario.set_max_fuel_converter_kw\u2502                                             \n                                     \u2572 knob active      \u2571yes\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                             \n                                      \u2572________________\u2571                        \u2502                                                                \n                                              \u2502no                               \u2502                                                                \n                                              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                                \n                                               ________\u25bd________     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                               \n                                              \u2571                 \u2572    \u2502try new fuel store size [kwh], code:       \u2502                               \n                                             \u2571 fuel store size   \u2572___\u2502run_scenario.set_fuel_store_kwh(optvehicle,\u2502                               \n                                             \u2572 [kwh] knob active \u2571yes\u2502fs_kwh_guess)                              \u2502                               \n                                              \u2572_________________\u2571    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                               \n                                                       \u2502no                                 \u2502                                                     \n                                                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                                     \n                                                         ________\u25bd________     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                    \n                                                        \u2571                 \u2572    \u2502try new battery size [kwh], code:           \u2502                    \n                                                       \u2571 battery size      \u2572___\u2502run_scenario.set_max_battery_kwh(optvehicle,\u2502                    \n                                                       \u2572 [kwh] knob active \u2571yes\u2502max_ess_kwh_guess)                          \u2502                    \n                                                        \u2572_________________\u2571    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                    \n                                                                 \u2502no                                  \u2502                                          \n                                                                 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                          \n                                                                    _______\u25bd________     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510             \n                                                                   \u2571                \u2572    \u2502try new motor power [kw], code:          \u2502             \n                                                                  \u2571 motor power [kw] \u2572___\u2502run_scenario.set_max_motor_kw(optvehicle,\u2502             \n                                                                  \u2572 knob active      \u2571yes\u2502self.opt_scenario, max_motor_kw_guess)   \u2502             \n                                                                   \u2572________________\u2571    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518             \n                                                                           \u2502no                                \u2502                                  \n                                                                           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500     \n                                                                                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bd\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                            \n                                                                                \u2502compute TCO and, if     \u2502                                            \n                                                                                \u2502applicable, acceleration\u2502                                            \n                                                                                \u2502and grade performance   \u2502                                            \n                                                                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                            \n                                                                                \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bd\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                                           \n                                                                                \u2502Optimizer keeps cycling  \u2502                                           \n                                                                                \u2502trying to find lowest TCO\u2502                                           \n                                                                                \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                                           \n</code></pre> <p>diagrams generated with https://arthursonzogni.com/Diagon/#Flowchart</p>"},{"location":"Global/","title":"Global Sub-Module","text":""},{"location":"Global/#t3co.run.Global","title":"<code>t3co.run.Global</code>","text":"<p>Global constants Stores paths to directories used for input files, as well as constants referenced throughout the code base</p>"},{"location":"Global/#t3co.run.Global.ANN_TRAVEL_TSV","title":"<code>ANN_TRAVEL_TSV = 'annual-travel.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.BEV","title":"<code>BEV = vehicle.BEV</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.CONV","title":"<code>CONV = vehicle.CONV</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.DieselGalPerGasGal","title":"<code>DieselGalPerGasGal = 0.887</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.EMISSION_RATE_TSV","title":"<code>EMISSION_RATE_TSV = 'emission-rate.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.FASTSIM_INPUTS","title":"<code>FASTSIM_INPUTS = OPTIMIZATION_RESOURCES_AUX / FASTSIM_INPUTS_FILE</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.FASTSIM_INPUTS_FILE","title":"<code>FASTSIM_INPUTS_FILE = 'FASTSimInputsHeader.csv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.FC_EFF_TYPES","title":"<code>FC_EFF_TYPES = {1: 'SI', 2: 'Diesel - ISB280', 3: 'Diesel', 4: 'Fuel Cell', 5: 'Hybrid Diesel', 6: 'Diesel - HD', 7: 'Diesel - HDISM Scaled', 8: 'Diesel - HDISM Scaled', 9: 'CNG'}</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.FUEL_EFF_TSV","title":"<code>FUEL_EFF_TSV = 'fuel-efficiency.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.FUEL_EXPENSE_TSV","title":"<code>FUEL_EXPENSE_TSV = 'fuel-expense.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.FUEL_SPLIT_TSV","title":"<code>FUEL_SPLIT_TSV = 'fuel-split.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.HEV","title":"<code>HEV = vehicle.HEV</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.KG_2_LB","title":"<code>KG_2_LB = 2.20462</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.MARKET_SHARE_TSV","title":"<code>MARKET_SHARE_TSV = 'market-share.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.MOO_KNOB_SWEEP_PLOTS_DIR","title":"<code>MOO_KNOB_SWEEP_PLOTS_DIR = Path(os.path.abspath(__file__)).parents[1] / 'tco_results' / 'knob_sweep_results'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.OPTIMIZATION_AND_TCO_RCRS","title":"<code>OPTIMIZATION_AND_TCO_RCRS = Path(os.path.abspath(__file__)).parents[1] / 'resources'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.OPTIMIZATION_DRIVE_CYCLES","title":"<code>OPTIMIZATION_DRIVE_CYCLES = OPTIMIZATION_AND_TCO_RCRS / 'cycles'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.OPTIMIZATION_RESOURCES_AUX","title":"<code>OPTIMIZATION_RESOURCES_AUX = OPTIMIZATION_AND_TCO_RCRS / 'auxiliary'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.OTHER_INPUTS","title":"<code>OTHER_INPUTS = OPTIMIZATION_RESOURCES_AUX / OTHER_INPUTS_FILE</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.OTHER_INPUTS_FILE","title":"<code>OTHER_INPUTS_FILE = 'OtherInputs.csv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.PHEV","title":"<code>PHEV = vehicle.PHEV</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.PT_TYPES_NUM_TO_STR","title":"<code>PT_TYPES_NUM_TO_STR = {CONV: 'Conv', HEV: 'HEV', PHEV: 'PHEV', BEV: 'BEV'}</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.REGIONAL_FUEL_PRICES_BY_TYPE_BY_YEAR","title":"<code>REGIONAL_FUEL_PRICES_BY_TYPE_BY_YEAR = OPTIMIZATION_RESOURCES_AUX / 'FuelPrices.csv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.REGIONAL_SALES_TSV","title":"<code>REGIONAL_SALES_TSV = 'regional-sales.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.RESIDUAL_VALUE_PER_YEAR","title":"<code>RESIDUAL_VALUE_PER_YEAR = OPTIMIZATION_RESOURCES_AUX / 'ResidualValues.csv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.SURVIVAL_TSV","title":"<code>SURVIVAL_TSV = 'survival.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.SWEEP_PATH","title":"<code>SWEEP_PATH = Path(os.path.abspath(__file__)).parents[1] / 'sweep.py'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.T2COBENCHMARKDATADIR","title":"<code>T2COBENCHMARKDATADIR = OPTIMIZATION_AND_TCO_RCRS / 'benchmarkdata'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.T3CO_INPUTS_DIR","title":"<code>T3CO_INPUTS_DIR = OPTIMIZATION_AND_TCO_RCRS / 'inputs'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TCO","title":"<code>TCO = 'tests'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TCO_INTERMEDIATES","title":"<code>TCO_INTERMEDIATES = None</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TCO_RESULTS","title":"<code>TCO_RESULTS = None</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TCO_RES_FIGS","title":"<code>TCO_RES_FIGS = None</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TESTCYCLES","title":"<code>TESTCYCLES = TESTSDIR / 'test_cycles'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TESTSCENARIOINPUTS","title":"<code>TESTSCENARIOINPUTS = TESTSDIR / 'TCO_SCENARIO_TEST_INPUTS.csv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TESTSDIR","title":"<code>TESTSDIR = Path(os.path.abspath(__file__)).parents[1] / f'{TCO}/tco_tests'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TESTVEHICLEINPUTS","title":"<code>TESTVEHICLEINPUTS = TESTSDIR / 'TCO_VEHICLE_TEST_INPUTS.csv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TESTVEHICLES","title":"<code>TESTVEHICLES = TESTSDIR / 'test_vehicles'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.TRAVEL_EXP_TSV","title":"<code>TRAVEL_EXP_TSV = 'travel-expense.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.VEH_EXP_TSV","title":"<code>VEH_EXP_TSV = 'vehicle-expense.tsv'</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.evGVWRAllowanceLbs","title":"<code>evGVWRAllowanceLbs = 0</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.global_opt_range_cycle","title":"<code>global_opt_range_cycle = None</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.kgH2_per_gge","title":"<code>kgH2_per_gge = 1.019</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.kwh_per_gge","title":"<code>kwh_per_gge = 33.7</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.m_to_mi","title":"<code>m_to_mi = 0.000621371</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.maxGvwrKg","title":"<code>maxGvwrKg = 0</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.mps_to_mph","title":"<code>mps_to_mph = 2.23694</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.vocation_scenario","title":"<code>vocation_scenario = None</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.wkdir","title":"<code>wkdir = Path(__file__).parent.parent</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.write_files","title":"<code>write_files = False</code>  <code>module-attribute</code>","text":""},{"location":"Global/#t3co.run.Global.get_kwh_per_gge","title":"<code>get_kwh_per_gge()</code>","text":"<p>This is a getter for kwh_per_gge, sim and scenario dependant var that can change important to get from one location each time so we can track when and how it's used</p> <p>Returns:</p> Name Type Description <code>kwh_per_gge</code> <code>float</code> <p>kWh per Gasoline Gallon Equivalent</p> Source code in <code>t3co/run/Global.py</code> Python<pre><code>def get_kwh_per_gge():\n    \"\"\"\n    This is a getter for kwh_per_gge, sim and scenario dependant var that can change\n    important to get from one location each time so we can track when and how it's used\n\n    Returns:\n        kwh_per_gge (float): kWh per Gasoline Gallon Equivalent\n    \"\"\"\n    return kwh_per_gge\n</code></pre>"},{"location":"Global/#t3co.run.Global.kg_to_lbs","title":"<code>kg_to_lbs(kgs: float) -&gt; float</code>","text":"<p>This function converts kg to lb</p> <p>Parameters:</p> Name Type Description Default <code>kgs</code> <code>float</code> <p>mass in kg</p> required <p>Returns:</p> Type Description <code>float</code> <p>mass in pounds</p> Source code in <code>t3co/run/Global.py</code> Python<pre><code>def kg_to_lbs(kgs: float) -&gt; float:\n    \"\"\"\n    This function converts kg to lb\n\n    Args:\n        kgs (float): mass in kg\n\n    Returns:\n        (float): mass in pounds\n    \"\"\"\n    return kgs * KG_2_LB\n</code></pre>"},{"location":"Global/#t3co.run.Global.lbs_to_kgs","title":"<code>lbs_to_kgs(lbs: float) -&gt; float</code>","text":"<p>This function converts lb to kg</p> <p>Parameters:</p> Name Type Description Default <code>lbs</code> <code>float</code> <p>mass in pounds</p> required <p>Returns:</p> Type Description <code>float</code> <p>mass in kg</p> Source code in <code>t3co/run/Global.py</code> Python<pre><code>def lbs_to_kgs(lbs: float) -&gt; float:\n    \"\"\"\n    This function converts lb to kg\n\n    Args:\n        lbs (float): mass in pounds\n\n    Returns:\n        (float): mass in kg\n    \"\"\"\n    return lbs / KG_2_LB\n</code></pre>"},{"location":"Global/#t3co.run.Global.not_falsy","title":"<code>not_falsy(var: float) -&gt; bool</code>","text":"<p>This function returns True to verify that var is NOT falsy: not in [None, np.nan, 0, False]</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>float</code> <p>variable to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if not in [None, 0, False]</p> Source code in <code>t3co/run/Global.py</code> Python<pre><code>def not_falsy(var: float) -&gt; bool:\n    \"\"\"\n    This function returns True to verify that var is NOT falsy: not in [None, np.nan, 0, False]\n\n\n    Args:\n        var (float): variable to check\n\n    Returns:\n        (bool): True if not in [None, 0, False]\n    \"\"\"\n    return var not in [None, 0, False]\n</code></pre>"},{"location":"Global/#t3co.run.Global.set_tco_intermediates","title":"<code>set_tco_intermediates()</code>","text":"<p>This function sets path for TCO_INTERMEDIATES to save tsv files</p> Source code in <code>t3co/run/Global.py</code> Python<pre><code>def set_tco_intermediates():\n    \"\"\"\n    This function sets path for TCO_INTERMEDIATES to save tsv files\n    \"\"\"\n    global TCO_INTERMEDIATES\n\n    # ./t3co/resources/f'vehicles/{vocation_scenario}/tco/tco_intermediates'\n    TCO_INTERMEDIATES = (\n        OPTIMIZATION_AND_TCO_RCRS\n        / f\"vehicles/{vocation_scenario}/tco/tco_intermediates\"\n    )\n    if not TCO_INTERMEDIATES.exists():\n        TCO_INTERMEDIATES.mkdir(parents=True)\n</code></pre>"},{"location":"Global/#t3co.run.Global.set_tco_results","title":"<code>set_tco_results()</code>","text":"<p>This function sets path for TCO_RESULTS</p> Source code in <code>t3co/run/Global.py</code> Python<pre><code>def set_tco_results():\n    \"\"\"\n    This function sets path for TCO_RESULTS\n    \"\"\"\n    global TCO_RESULTS\n    # ./t3co/resources/f'vehicles/{vocation_scenario}/tco/tco_results'\n    TCO_RESULTS = (\n        OPTIMIZATION_AND_TCO_RCRS / f\"vehicles/{vocation_scenario}/tco/tco_results\"\n    )\n    if not TCO_RESULTS.exists():\n        TCO_RESULTS.mkdir(parents=True)\n\n    global TCO_RES_FIGS\n    # ./t3co/resources/f'vehicles/{vocation_scenario}/result_figures/'\n    TCO_RES_FIGS = (\n        OPTIMIZATION_AND_TCO_RCRS / f\"vehicles/{vocation_scenario}/result_figures/\"\n    )\n    if not TCO_RES_FIGS.exists():\n        TCO_RES_FIGS.mkdir(parents=True)\n</code></pre>"},{"location":"T3CO_Overview/","title":"Overview","text":""},{"location":"T3CO_Overview/#t3co-introduction","title":"T3CO Introduction","text":"<p>NREL's Transportation Technology Total Cost of Ownership (T3CO) tool enables levelized assessments of the full life cycle costs of current and advanced technology commercial vehicles.</p>"},{"location":"T3CO_Overview/#code-flow","title":"Code Flow","text":"<p>Generally speaking, T3CO can be used in two ways:</p> <ul> <li> <p>The first option generates total cost of ownership (TCO) and performance metrics for a pre-defined vehicle.</p> </li> <li> <p>The second option optimizes a vehicle's component specifications to achieve the lowest total cost of ownership possible while meeting performance objectives. Since optimization requires gathering TCO and performance metrics during each step of optimization, it essentially is an expansion of the first option for using T3CO.</p> </li> </ul>"},{"location":"T3CO_Overview/#generating-tco-and-performance","title":"Generating TCO and performance","text":"<p>There are a few main components of a vehicle's total cost of ownership: MSRP (the cost of the vehicle at time of purchase), fuel costs (based on $ per gallon of gasoline equivalent for every operational year's fuel used, other operating costs maintenance [\\$/mile]), fueling dwell time labor [\\$/hr], opportunity cost for payload loss and downtime, and resale value at end of ownership.</p> <p>Fuel costs are computed after determining the vehicle energy efficiency (e.g. miles per gallon of fuel) and factoring in the annual miles driven and the fuel price for each year and region where the vehicle operates. The performance metrics estimated for the vehicle are: miles of range, acceleration time, and gradeability.</p> <p>More details on performance metrics are included below under optimization flow. If the analysis does not include optimization, these metrics are simply reported in the results.</p>"},{"location":"T3CO_Overview/#t3co-input-files","title":"T3CO Input Files","text":"<p>There are three main files that form the basis of T3CO TCO calculations and T3CO optimizations. The first is the Vehicle File which provides vehicle model inputs for FASTSim simulation. The second type of file is the T3CO input file, or Scenario File, which specifies the cost assumption parameters for the TCO calculation. These include technology cost assumptions (e.g. $ per kilowatt for engine or motor size), operating conditions, (e.g. annual VMT and geographic region), financial inputs (e.g. operating years and discount rate), analysis option controls (e.g. whether to optimize the vehicle or not), and performance requirements if optimizing (e.g. range, grade and acceleration targets). The third file is the Config File, which provides an easier way to manage analyses with minimal command line inputs, containing overrides for major scenario input parameters.</p> <p>T3CO provides some example Vehicle and Scenario models to assist the user in getting started. There are demo versions of the Vehicle file and Scenario file available in the <code>/t3co/resources/inputs/demo/</code> folder. The Config file is available in the <code>/t3co/resources/</code> folder. They are also available in the demo_inputs folder if the <code>install_t3co_demo_inputs</code> command is used to copy the required input files to your local directory.</p>"},{"location":"T3CO_Overview/#optimization-flow","title":"Optimization Flow","text":"<p>The TCO &amp; Performance metric targets described below are the core of the optimization loop. T3CO has the capability to take vehicle specifications, such as engine size, motor size, battery size, coefficient of aerodynamic drag, vehicle weight, etc. and modify them in order to find the set of specifications that yields the lowest TCO while still meeting minimum performance requirements in acceleration, grade and range. Adjusting these vehicle specifications impacts the vehicle\u2019s MSRP and also, by changing its energy consumption per mile, its operating costs. If including engine efficiency, aerodynamic drag, and light-weighting in the optimization, additional input files are required to specify the cost of improving these features.</p> <p>Optimization is handled in the optimization module, inheriting from the PyMOO module.</p>"},{"location":"T3CO_Overview/#performance-constraints","title":"Performance Constraints","text":"<p>The user must specify targets for the following performance metrics to constrain the optimization</p> <ul> <li> <p>Gradeability is the measure of the vehicle's max speed achieved at 1.25 and 6 percent grades, while the vehicle is operating at max allowable GVWR (including EV weight credit kilograms)</p> </li> <li> <p>Acceleration is the measure of the time in seconds the vehicle takes to reach 30 miles per hour and 60 miles per hour. This constraint can be specified at max allowable GVWR or calculated vehicle weight using input payload.</p> </li> <li> <p>Range is the computation of the vehicle's range in miles based on the computed fuel efficiency (MPGGE - miles per gallon gasoline equivalent) and vehicle fuel or energy storage; MPGGE is attained using a design cycle (cycle or cycles determined to be representative of vehicle operation). The design cycle can be a single drive cycle or a weighted composite of multiple drive cycles.</p> </li> </ul>"},{"location":"accel/","title":"Acceleration Test Sub-Module","text":""},{"location":"accel/#t3co.objectives.accel","title":"<code>t3co.objectives.accel</code>","text":"<p>Module for simulating acceleration performance.</p>"},{"location":"accel/#t3co.objectives.accel.PHEV","title":"<code>PHEV = 365</code>  <code>module-attribute</code>","text":""},{"location":"accel/#t3co.objectives.accel.init_socs","title":"<code>init_socs = [i for i in np.linspace(v.min_soc, v.max_soc, 10)]</code>  <code>module-attribute</code>","text":""},{"location":"accel/#t3co.objectives.accel.scenario_inputs_path","title":"<code>scenario_inputs_path = Path(gl.T3CO_INPUTS_DIR / 'tda_example/TDA_FY22_scenario_assumptions.csv').resolve()</code>  <code>module-attribute</code>","text":""},{"location":"accel/#t3co.objectives.accel.v","title":"<code>v = run_scenario.get_vehicle(PHEV, vehicle_input_path)</code>  <code>module-attribute</code>","text":""},{"location":"accel/#t3co.objectives.accel.vehicle_input_path","title":"<code>vehicle_input_path = Path(gl.T3CO_INPUTS_DIR / 'tda_example/TDA_FY22_vehicle_model_assumptions.csv').resolve()</code>  <code>module-attribute</code>","text":""},{"location":"accel/#t3co.objectives.accel.zero_to_sixties","title":"<code>zero_to_sixties = []</code>  <code>module-attribute</code>","text":""},{"location":"accel/#t3co.objectives.accel.get_accel","title":"<code>get_accel(analysis_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario = None, set_weight_to_max_kg: bool = True, verbose=False, ess_init_soc=None) -&gt; Tuple[float, float, fastsim.vehicle.Vehicle]</code>","text":"<p>This function runs a simdrive for getting 0-to-60 and 0-30 mph time with fully laden weight at GVWR (plus gvwr_credit_kg?)</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for current selection. Defaults to None.</p> <code>None</code> <code>set_weight_to_max_kg</code> <code>bool</code> <p>if True, runs run_scenario.set_test_weight(). Defaults to True.</p> <code>True</code> <code>verbose</code> <code>bool</code> <p>if True, prints the process steps. Defaults to False.</p> <code>False</code> <code>ess_init_soc</code> <code>float</code> <p>ESS initial SOC override. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>zero_to_sixty</code> <code>float</code> <p>0-60 mph acceleration time in sec</p> <code>zero_to_thirty</code> <code>float</code> <p>0-30 mph acceleration time in sec</p> <code>accel_simdrive</code> <code>fastsim.simdrive.SimDrive</code> <p>FASTSim.simdrive.SimDrive object for running the acceleration drivecycle</p> Source code in <code>t3co/objectives/accel.py</code> Python<pre><code>def get_accel(\n    analysis_vehicle: fastsim.vehicle.Vehicle,\n    scenario: run_scenario.Scenario = None,\n    set_weight_to_max_kg: bool = True,\n    verbose=False,\n    ess_init_soc=None,\n) -&gt; Tuple[float, float, fastsim.vehicle.Vehicle]:\n    \"\"\"\n    This function runs a simdrive for getting 0-to-60 and 0-30 mph time with fully laden weight at GVWR (plus gvwr_credit_kg?)\n\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object for analysis vehicle\n        scenario (run_scenario.Scenario, optional): Scenario object for current selection. Defaults to None.\n        set_weight_to_max_kg (bool, optional): if True, runs run_scenario.set_test_weight(). Defaults to True.\n        verbose (bool, optional): if True, prints the process steps. Defaults to False.\n        ess_init_soc (float, optional): ESS initial SOC override. Defaults to None.\n\n    Returns:\n        zero_to_sixty (float): 0-60 mph acceleration time in sec\n        zero_to_thirty (float): 0-30 mph acceleration time in sec\n        accel_simdrive (fastsim.simdrive.SimDrive): FASTSim.simdrive.SimDrive object for running the acceleration drivecycle\n\n    \"\"\"\n    CYC_MPH = 90\n\n    kg_before = None\n    if set_weight_to_max_kg and scenario is not None:\n        kg_before = analysis_vehicle.veh_kg\n        run_scenario.set_test_weight(analysis_vehicle, scenario)\n\n    # load the vehicle\n    t0 = time.time()\n\n    if verbose:\n        print(f\"f'{Path(__file__).name}:: Vehicle load time: {time.time() - t0:.3f} s\")\n    # load the cycles\n    t0 = time.time()\n    accel_cyc_secs = np.arange(300)\n    cyc_dict = {\n        \"time_s\": accel_cyc_secs,\n        \"mps\": np.append(\n            [0], np.ones(len(accel_cyc_secs) - 1) * CYC_MPH / params.MPH_PER_MPS\n        ),\n        \"cycGrade\": np.zeros(len(accel_cyc_secs)),\n    }\n\n    cyc_accel = cycle.Cycle.from_dict(cyc_dict)\n\n    accel_simdrive = run_scenario.get_objective_simdrive(analysis_vehicle, cyc_accel)\n\n    run_scenario.run_grade_or_accel(\n        \"accel\", analysis_vehicle, accel_simdrive, ess_init_soc\n    )\n    # print(f'accel:get_accel::&gt;&gt;&gt; {type(accel_simdrive.sim_params)} accel_simdrive.sim_params.trace_miss_dist_tol', accel_simdrive.sim_params.trace_miss_dist_tol)\n    # print(f'accel:get_accel::&gt;&gt;&gt; {type(accel_simdrive.sim_params)} accel_simdrive.sim_params.trace_miss_speed_mps_tol ', accel_simdrive.sim_params.trace_miss_speed_mps_tol )\n    assert (\n        accel_simdrive.trace_miss_dist_frac\n        &lt;= accel_simdrive.sim_params.trace_miss_dist_tol\n    )\n\n    def test_accel(speed_mph_target: float) -&gt; float:\n        \"\"\"\n        This function gets the time it takes to reach target speed\n\n        Args:\n            speed_mph_target (float): Target speed for acceleration time\n\n        Returns:\n            zero_to_target_mph_s (float): Time taken to reach target speed\n        \"\"\"\n        # seconds to target mph test\n        if (np.array(accel_simdrive.mph_ach) &gt;= speed_mph_target).any():\n            zero_to_target_mph_s = np.interp(\n                x=speed_mph_target,\n                xp=np.array(accel_simdrive.mph_ach),\n                fp=cyc_accel.time_s,\n            )\n        else:\n            # in case vehicle never exceeds speed_mph_target mph, penalize it a lot with a high number\n            # print(analysis_vehicle.scenario_name + f' did not achieve {speed_mph_target} mph during the accel test')\n            zero_to_target_mph_s = -accel_simdrive.mph_ach[-1]\n\n        return zero_to_target_mph_s\n\n    # seconds to 60 test\n    zero_to_sixty = test_accel(60)\n    # seconds to 30 test\n    zero_to_thirty = test_accel(30)\n\n    #  an assert to ensure that vehicle weight is reset correctly\n    if set_weight_to_max_kg and scenario is not None:\n        run_scenario.reset_vehicle_weight(analysis_vehicle)\n        kg_after = analysis_vehicle.veh_kg\n        assert (\n            kg_after == kg_before\n        ), f\"total vehicle kg (veh_kg) kg_after must be to kg_before, {kg_after} != {kg_before}\"\n\n    return zero_to_sixty, zero_to_thirty, accel_simdrive\n</code></pre>"},{"location":"charts/","title":"Charts Sub-Module","text":""},{"location":"charts/#t3co.visualization.charts","title":"<code>t3co.visualization.charts</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts","title":"<code>T3COCharts</code>","text":"<p>This class takes T3CO output CSV file as input and generates different plots to gain insights from T3CO Results</p> Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>class T3COCharts:\n    \"\"\"\n    This class takes T3CO output CSV file as input and generates different plots to gain insights from T3CO Results\n\n    \"\"\"\n\n    t3co_results: pd.DataFrame\n    results_guide: pd.DataFrame\n    value_cols: List[float]\n\n    def __init__(\n        self,\n        filename: str = None,\n        results_df: pd.DataFrame = None,\n        results_guide: str | Path = Path(__file__).parents[1]\n        / \"resources\"\n        / \"visualization\"\n        / \"t3co_outputs_guide.csv\",\n    ) -&gt; None:\n        \"\"\"\n        This constructor initializes the T3COCharts object either from a dataframe or a CSV file path.\n\n        Args:\n            filename (str, optional): Filepath to T3CO Results CSV File. Defaults to None.\n            results_df (pd.DataFrame, optional): Input pandas dataframe containing T3CO Results. Defaults to None.\n            results_guide (str | Path, optional): File path to t3co_outputs_guide.csv file that contains useful parameter descriptions and axis labels. Defaults to Path(__file__).parents[1]/\"resources\"/\"visualization\"/\"t3co_outputs_guide.csv\".\n        \"\"\"\n        print(\"Initializing T3COCharts\")\n        if filename is not None:\n            self.from_file(filename)\n        else:\n            self.from_df(results_df)\n\n        self.parse_scenario_name()\n\n        self.results_guide = pd.read_csv(results_guide)\n        self.value_cols = self.results_guide.loc[\n            self.results_guide[\"data_type\"] == \"float\", \"t3co_output_parameter\"\n        ].values\n\n        self.group_columns = [\n            \"None\",\n            \"vehicle_weight_class\",\n            \"veh_year\",\n            \"vehicle_type\",\n            \"tech_progress\",\n            \"vehicle_fuel_type\",\n        ]\n        self.cost_cols = {\n            \"residual_cost_dol\": \"#6C7B8B\",\n            \"glider_cost_dol\": \"#8b7355\",\n            \"fuel_converter_cost_dol\": \"#228B22\",\n            \"fuel_storage_cost_dol\": \"#8B4513\",\n            \"motor_control_power_elecs_cost_dol\": \"#1874CD\",\n            \"plug_cost_dol\": \"#6A5ACD\",\n            \"battery_cost_dol\": \"#7EC0EE\",\n            \"purchase_tax_dol\": \"#CD5B45\",\n            \"insurance_cost_dol\": \"#CDC673\",\n            \"total_maintenance_cost_dol\": \"#DAA520\",\n            \"total_fuel_cost_dol\": \"#4682B4\",\n            \"fueling_dwell_labor_cost_dol\": \"#CD2626\",\n            \"discounted_downtime_oppy_cost_dol\": \"#8B0000\",\n            \"payload_capacity_cost_dol\": \"#CD8C95\",\n        }\n        self.t3co_results = self.t3co_results.convert_dtypes()\n        for costcol in self.cost_cols.keys():\n            self.t3co_results[costcol] = self.t3co_results[costcol].astype(float).round(2)\n        self.t3co_results[\"discounted_tco_dol\"] = self.t3co_results[\n            \"discounted_tco_dol\"\n        ].astype(float)\n        self.full_form_dict = dict(\n            zip(\n                self.results_guide[\"t3co_output_parameter\"],\n                self.results_guide[\"full_form\"],\n            )\n        )\n        self.cost_col_names = self.results_guide[\"full_form\"][\n            self.results_guide[\"t3co_output_parameter\"].isin(self.cost_cols.keys())\n        ]\n\n        self.edgecolors = [\n            \"none\",\n            \"black\",\n            \"gray\",\n            \"white\",\n        ]\n\n    def from_file(\n        self,\n        filename: str | Path = None,\n    ) -&gt; None:\n        \"\"\"\n        This method reads a T3CO Results CSV file into a dataframe\n\n        Args:\n            filename (str | Path, optional): Path to T3CO Results CSV File. Defaults to None.\n        \"\"\"\n        self.t3co_results = pd.read_csv(filename)\n\n    def from_df(self, results_df: pd.DataFrame) -&gt; None:\n        \"\"\"\n        This method reads t3co_results from a dataframe\n\n        Args:\n            results_df (pd.DataFrame): Input T3CO Results dataframe\n        \"\"\"\n        self.t3co_results = results_df\n\n    def to_df(self) -&gt; pd.DataFrame:\n        \"\"\"\n        This returns the self.t3co_results member\n\n        Returns:\n            pd.DataFrame: T3CO Results dataframe\n        \"\"\"\n        return self.t3co_results\n\n    def parse_scenario_name(self) -&gt; None:\n        \"\"\"\n        This method parses 'scenario_name' into 'vehicle_type', 'tech_progress', and 'vehicle_fuel_type' and uses 'scenario_gvwr_kg' to create 'vehicle_weight_class'\n        \"\"\"\n        weight_class_ranges = {\n            \"1\": [0, 2722],\n            \"2a\": [2722, 3856],\n            \"2b\": [3856, 4536],\n            \"3\": [4536, 6350],\n            \"4\": [6350, 7257],\n            \"5\": [7257, 8845],\n            \"6\": [8845, 11793],\n            \"7\": [11793, 14969],\n            \"8\": [14969, 50000],\n        }\n        self.t3co_results[\"vehicle_weight_class\"] = \"\"\n        for i in range(len(self.t3co_results)):\n            for wt_class, lims in weight_class_ranges.items():\n                if (\n                    float(self.t3co_results[\"scenario_gvwr_kg\"][i]) &gt; lims[0]\n                    and float(self.t3co_results[\"scenario_gvwr_kg\"][i]) &lt;= lims[1]\n                ):\n                    self.t3co_results.loc[[i], \"vehicle_weight_class\"] = (\n                        \"Class \" + wt_class\n                    )\n                    break\n\n        self.t3co_results[\"vehicle_type\"] = (\n            self.t3co_results[\"scenario_name\"]\n            .str.split(\"(\")\n            .apply(lambda x: \" \".join(x[0].split(\" \")[2:]))\n        )\n\n        self.t3co_results[\"tech_progress\"] = (\n            self.t3co_results[\"scenario_name\"]\n            .str.split(\"(\")\n            .apply(lambda x: x[1].split(\",\")[-1].split(\")\")[0])\n        )\n        self.t3co_results[\"vehicle_fuel_type\"] = (\n            self.t3co_results[\"scenario_name\"]\n            .str.split(\"(\")\n            .apply(lambda x: x[1].split(\",\")[0])\n        )\n\n    def generate_tco_plots(\n        self,\n        x_group_col: str,\n        y_group_col: str,\n        subplot_group_col: str = \"vehicle_fuel_type\",\n        fig_x_size: int = 8,\n        fig_y_size: int = 8,\n        bar_width: float = 0.8,\n        legend_pos: float = 0.25,\n        edgecolor: str = \"none\",\n    ) -&gt; matplotlib.figure.Figure:\n        \"\"\"\n        This method generates a TCO Breakdown plot based on input arguments.\n        If x_group_col and/or y_group_col are provided, then a matrix/grid of subplots are generated within the same figure based on row- and column-wise groupings\n\n        Args:\n            x_group_col (str): T3CO Results parameter name to group on x-axis, i.e., grouping criteria for columns in subplots grid\n            y_group_col (str): T3CO Results parameter name to group on y-axis, i.e., grouping criteria for rows in subplots grid\n            subplot_group_col (str, optional): T3CO Results parameter to display within each subplots cell. Defaults to \"vehicle_fuel_type\".\n            fig_x_size (int, optional): Figure width relative to each bar on x-axis within subplot. Defaults to 8.\n            fig_y_size (int, optional): Figure height relative to each subplot cell. Defaults to 8.\n            bar_width (float, optional): Relative width of bars based on available width. Takes values between 0.0 and 1.0. Defaults to 0.8.\n            legend_pos (float, optional): Relative position of legend on the right side of plots. Takes values between 0.0 and 1.0. Defaults to 0.25.\n            edgecolor (str, optional): Edge color to distinguish cost elements in the stacked bars. Defaults to \"none\".\n\n        Returns:\n            matplotlib.figure.Figure: TCO Breakdown Figure object\n        \"\"\"\n        print(\"running generate_tco_plots\")\n        disc_tco_label = self.results_guide[\"full_form\"][\n            self.results_guide[\"t3co_output_parameter\"] == \"discounted_tco_dol\"\n        ]\n        legend_cols = list(disc_tco_label) + list(self.cost_col_names)\n        x_groups = (\n            self.t3co_results[x_group_col].unique() if x_group_col != \"None\" else [0]\n        )\n        y_groups = (\n            self.t3co_results[y_group_col].unique() if y_group_col != \"None\" else [0]\n        )\n        fontsize = 25\n\n        if (x_group_col == \"None\" and y_group_col == \"None\") or (\n            len(x_groups) == 1 and len(y_groups) == 1\n        ):\n            fig, ax = plt.subplots(\n                1,\n                1,\n                figsize=(\n                    min(len(self.t3co_results) * fig_x_size + 4, 50),\n                    min(4 + fig_y_size, 50),\n                ),\n                sharex=True,\n            )\n            # bottom = np.zeros(len(groups))\n            # width = 0.15\n            x_values = range(\n                len(self.t3co_results)\n            )  # X-values based on the index of the DataFrame\n            y_values = self.t3co_results[\"discounted_tco_dol\"]\n\n            ax.scatter(\n                x_values,\n                y_values,\n                color=\"red\",\n                label=disc_tco_label,\n                zorder=3,\n                marker=\"D\",\n                s=100,\n            )\n            self.t3co_results.plot.bar(\n                y=self.cost_cols.keys(),\n                stacked=True,\n                figsize=(min(len(self.t3co_results) * fig_x_size, 50), 6 + fig_y_size),\n                width=bar_width,\n                ax=ax,\n                legend=False,\n                color=self.cost_cols,\n                edgecolor=(edgecolor if edgecolor in self.edgecolors else \"none\"),\n                alpha=0.8,\n            )\n\n            xlabels = [\n                \"\\n\".join(wrap(x, 25)) for x in self.t3co_results[\"scenario_name\"]\n            ]\n\n            # bars = ax.patches\n            # hatches = [p for p in patterns for i in range(len(self.t3co_results[self.cost_cols.keys()]))]\n            # for bar, hatch in zip(bars, hatches):\n            #     bar.set_hatch(hatch)\n            # self.t3co_results.plot.line(x = ['scenario_name'], y= ['discounted_tco_dol'], ax= ax)\n            ax.set_xlabel(\"Scenarios\", fontsize=fontsize, labelpad=10)\n            ax.get_yaxis().set_major_formatter(\n                FuncFormatter(lambda x, p: \"$\" + format(int(x), \",\"))\n            )\n            ax.set_xticklabels(self.t3co_results[\"scenario_name\"])\n            ax.set_ylabel(r\"Cost [$]\", fontsize=fontsize, labelpad=10)\n            ax.minorticks_on()\n            ax.set_xlim(-0.5, len(self.t3co_results) - 0.5)\n\n            ax.set_xlim(-0.5, len(x_values) - 0.5)\n\n            # plt.tight_layout()\n            ax.set_xticks(range(len(self.t3co_results)), xlabels)\n            ax.tick_params(labelsize=fontsize)\n            handles, labels = [], []\n            for h, l in zip(*ax.get_legend_handles_labels()):\n                handles.append(h)\n                labels.append(l)\n\n            fig.legend(\n                handles,\n                legend_cols,\n                loc=\"center right\",\n                bbox_to_anchor=(1 + legend_pos, 0.5),\n                fontsize=fontsize,\n            )\n\n            fig.suptitle(\n                \"Total Cost Of Ownership Breakdown\",\n                fontsize=fontsize * 1.5,\n                fontweight=\"bold\",\n            )\n            fig = ax.get_figure()\n\n        elif len(x_groups) &gt; 1 and len(y_groups) == 1:\n            fig, ax = plt.subplots(\n                1,\n                len(x_groups),\n                sharey=True,\n                sharex=True,\n                figsize=(min(len(x_groups) * fig_x_size + 8, 50), min(4 + fig_y_size,50)),\n            )\n            # print(self.t3co_results.loc[ self.t3co_results[x_group_col] == x_groups[0]])\n\n            max_x = 1\n            # print(f'maxn = {maxn}')\n            for i in range(len(x_groups)):\n                x_values = range(\n                    len(\n                        self.t3co_results.loc[\n                            self.t3co_results[x_group_col] == x_groups[i]\n                        ]\n                    )\n                )  # X-values based on the index of the DataFrame\n                y_values = self.t3co_results.loc[\n                    self.t3co_results[x_group_col] == x_groups[i], \"discounted_tco_dol\"\n                ]\n                ax[i].scatter(\n                    x_values,\n                    y_values,\n                    color=\"red\",\n                    label=disc_tco_label,\n                    zorder=3,\n                    marker=\"D\",\n                )\n\n                self.t3co_results.loc[\n                    self.t3co_results[x_group_col] == x_groups[i]\n                ].plot.bar(\n                    x=subplot_group_col,\n                    y=self.cost_cols.keys(),\n                    stacked=True,\n                    ax=ax[i],\n                    figsize=(\n                        min(len(self.t3co_results) * fig_x_size, 50),\n                        min(len(y_groups) * fig_y_size + 4, 50),\n                    ),\n                    legend=False,\n                    width=bar_width,\n                    color=self.cost_cols,\n                    edgecolor=edgecolor,\n                    alpha=0.7,\n                )\n                ax[i].minorticks_on()\n\n                max_x = max(len(x_values), max_x)\n\n                ax[i].set_xticks(\n                    x_values,\n                    self.t3co_results.loc[\n                        self.t3co_results[x_group_col] == x_groups[i], subplot_group_col\n                    ],\n                )\n\n                ax[i].set_xlabel(f\"{x_groups[i]}\", fontsize=fontsize, labelpad=10)\n                ax[i].tick_params(axis=\"x\", labelsize=fontsize, labelrotation=90)\n                ax[i].tick_params(axis=\"y\", labelsize=fontsize, labelrotation=0)\n\n                ax[i].get_yaxis().set_major_formatter(\n                    FuncFormatter(lambda x, p: \"$\" + format(int(x), \",\"))\n                )\n\n            for i in range(len(x_groups)):\n                ax[i].set_xlim(-0.5, max_x - 0.5)\n\n            fig.supylabel(r\"Cost [$]\", fontsize=fontsize)\n\n            fig.suptitle(\n                \"Total Cost Of Ownership Breakdown\",\n                fontsize=fontsize * 1.5,\n                fontweight=\"bold\",\n            )\n\n            handles, labels = [], []\n            for h, l in zip(*ax[-1].get_legend_handles_labels()):\n                handles.append(h)\n                labels.append(l)\n\n            fig.legend(\n                handles,\n                legend_cols,\n                loc=\"center right\",\n                bbox_to_anchor=(1 + legend_pos, 0.5),\n                fontsize=fontsize,\n            )\n\n            fig.supxlabel(\n                self.full_form_dict[x_group_col],\n                fontsize=fontsize,\n            )\n            plt.subplots_adjust(bottom=0.21)\n\n        elif len(y_groups) &gt; 1 and len(x_groups) == 1:\n            fontsize = 25\n            max_x = 1\n            fig, ax = plt.subplots(\n                len(y_groups),\n                sharex=True,\n                sharey=True,\n                figsize=(\n                    min(10 + fig_x_size, 50),\n                    min(len(y_groups) * fig_y_size + 4, 50),\n                ),\n            )\n\n            for i in range(len(y_groups)):\n                x_values = range(\n                    len(\n                        self.t3co_results.loc[\n                            self.t3co_results[y_group_col] == y_groups[i]\n                        ]\n                    )\n                )  # X-values based on the index of the DataFrame\n                y_values = self.t3co_results.loc[\n                    self.t3co_results[y_group_col] == y_groups[i], \"discounted_tco_dol\"\n                ]\n                ax[i].scatter(\n                    x_values,\n                    y_values,\n                    color=\"red\",\n                    label=disc_tco_label,\n                    zorder=3,\n                    marker=\"D\",\n                )\n\n                self.t3co_results.loc[\n                    self.t3co_results[y_group_col] == y_groups[i]\n                ].plot.bar(\n                    x=subplot_group_col,\n                    y=self.cost_cols.keys(),\n                    stacked=True,\n                    figsize=(\n                        min(len(self.t3co_results) * fig_x_size, 50),\n                        min(len(y_groups) * fig_y_size, 50),\n                    ),\n                    ax=ax[i],\n                    legend=False,\n                    width=bar_width,\n                    color=self.cost_cols,\n                    edgecolor=edgecolor,\n                    alpha=0.7,\n                )\n\n                ax[i].get_yaxis().set_major_formatter(\n                    FuncFormatter(lambda x, p: \"$\" + format(int(x), \",\"))\n                )\n\n                ax[i].minorticks_on()\n\n                ax2 = ax[i].twinx()\n                ax2.set_ylabel(y_groups[i], fontsize=fontsize, labelpad=10)\n                ax2.set_yticks([])\n                max_x = max(len(x_values), max_x)\n\n                ax[i].tick_params(axis=\"x\", labelsize=fontsize, labelrotation=90)\n                ax[i].tick_params(axis=\"y\", labelsize=fontsize, labelrotation=0)\n\n            for i in range(len(y_groups)):\n                ax[i].set_xlim(-0.5, max_x - 0.5)\n                ax[i].set_xlabel(\"\")\n\n            handles, labels = [], []\n            for h, l in zip(*ax[-1].get_legend_handles_labels()):\n                handles.append(h)\n                labels.append(l)\n\n            fig.legend(\n                handles,\n                legend_cols,\n                loc=\"center right\",\n                bbox_to_anchor=(1 + legend_pos, 0.5),\n                fontsize=fontsize,\n            )\n\n            fig.supylabel(r\"Cost [$]\", fontsize=fontsize)\n            fig.supxlabel(\n                self.full_form_dict[subplot_group_col],\n                fontsize=fontsize,\n            )\n            fig.suptitle(\n                \"Total Cost Of Ownership Breakdown\",\n                fontsize=fontsize * 1.5,\n                fontweight=\"bold\",\n            )\n\n        else:\n            fontsize = 25\n            max_x = 1\n            fig, ax = plt.subplots(\n                len(y_groups),\n                len(x_groups),\n                sharey=True,\n                sharex=True,\n                figsize=(\n                    min(len(y_groups) * fig_x_size + 3, 50),\n                    min(len(x_groups) * fig_y_size + 7, 50),\n                ),\n            )\n\n            for i in range(len(y_groups)):\n                for j in range(len(x_groups)):\n                    x_values = range(\n                        len(\n                            self.t3co_results.loc[\n                                (self.t3co_results[y_group_col] == y_groups[i])\n                                &amp; (self.t3co_results[x_group_col] == x_groups[j])\n                            ]\n                        )\n                    )  # X-values based on the index of the DataFrame\n\n                    y_values = self.t3co_results.loc[\n                        (self.t3co_results[y_group_col] == y_groups[i])\n                        &amp; (self.t3co_results[x_group_col] == x_groups[j]),\n                        \"discounted_tco_dol\",\n                    ]\n                    ax[i][j].scatter(\n                        x_values,\n                        y_values,\n                        color=\"red\",\n                        label=disc_tco_label,\n                        zorder=3,\n                        marker=\"D\",\n                    )\n\n                    ax[i][j].set_xlabel(\n                        f\"{x_groups[j]}\", fontsize=fontsize, labelpad=10\n                    )\n                    ax2 = ax[i][j].twinx()\n                    ax2.set_ylabel(f\"{y_groups[i]}\", fontsize=fontsize, labelpad=10)\n                    ax2.set_yticks([])\n\n                    ax[i][j].tick_params(axis=\"x\", labelsize=fontsize, labelrotation=90)\n                    ax[i][j].tick_params(axis=\"y\", labelsize=fontsize, labelrotation=0)\n\n                    if self.t3co_results.loc[\n                        (self.t3co_results[y_group_col] == y_groups[i])\n                        &amp; (self.t3co_results[x_group_col] == x_groups[j])\n                    ].empty:\n                        continue\n\n                    self.t3co_results.loc[\n                        (self.t3co_results[y_group_col] == y_groups[i])\n                        &amp; (self.t3co_results[x_group_col] == x_groups[j])\n                    ].plot.bar(\n                        x=subplot_group_col,\n                        y=self.cost_cols.keys(),\n                        stacked=True,\n                        ax=ax[i][j],\n                        legend=False,\n                        width=bar_width,\n                        color=self.cost_cols,\n                    )\n\n                    max_x = max(len(x_values), max_x)\n\n            for i in range(len(y_groups)):\n                for j in range(len(x_groups)):\n                    ax[i][j].set_xlim(-0.5, max_x - 0.5)\n\n            handles, labels = [], []\n            for h, l in zip(*ax[-1][-1].get_legend_handles_labels()):\n                handles.append(h)\n                labels.append(l)\n\n            fig.legend(\n                handles,\n                legend_cols,\n                loc=\"center right\",\n                bbox_to_anchor=(1 + legend_pos, 0.5),\n                fontsize=fontsize,\n            )\n\n            fig.supylabel(r\"Cost [$]\", fontsize=fontsize)\n            fig.supxlabel(\n                self.full_form_dict[subplot_group_col],\n                fontsize=fontsize,\n            )\n            fig.suptitle(\n                \"Total Cost Of Ownership Breakdown\",\n                fontsize=fontsize * 1.25,\n                fontweight=\"bold\",\n            )\n\n        return fig\n\n    def generate_violin_plot(\n        self, x_group_col: str, y_group_col: str = \"discounted_tco_dol\", fig_width:float =8, fig_height:float = 5,\n    ) -&gt; matplotlib.figure.Figure:\n        \"\"\"\n        This method generates a violin plot based on x-axis group column and y-axis column name.\n\n        Args:\n            x_group_col (str): T3CO Results parameter to group by on x-axis inside violinplot\n            y_group_col (str, optional): T3CO Results parameter to plot on y-axis. Defaults to \"discounted_tco_dol\".\n\n        Returns:\n            matplotlib.figure.Figure: Violin Plot Figure object\n        \"\"\"\n        print(\"Running Violin plots\")\n        fontsize = 10\n        fig, ax = plt.subplots(1,1,figsize = (fig_width,fig_height))\n        self.t3co_results[y_group_col] = self.t3co_results[y_group_col].astype(float).round(5)\n        sns.violinplot(\n            x=x_group_col,\n            y=y_group_col,\n            data=self.t3co_results,\n            ax=ax,\n            palette=\"colorblind\",\n            cut=0,\n            density_norm=\"count\",\n            inner=\"quart\",\n            hue=x_group_col,\n            legend=False,\n        )\n        if \"dol\" in y_group_col:\n            ax.get_yaxis().set_major_formatter(\n                FuncFormatter(lambda x, p: \"$\" + format(int(x), \",\"))\n            )\n\n        ax.set_title(\"Violin Plot\",fontsize=fontsize * 1.5,\n                fontweight=\"bold\",)\n        ax.set_ylabel(self.full_form_dict[y_group_col])\n        ax.set_xlabel(self.full_form_dict[x_group_col])\n        return fig\n\n    def generate_histogram(\n        self, hist_col: str, n_bins: int, fig_width:float =8, fig_height:float = 5, show_pct: bool = False\n    ) -&gt; matplotlib.figure.Figure:\n        \"\"\"\n        This method generates a histogram plot based on inputs hist_col and n_bins\n\n        Args:\n            hist_col (str): T3CO column name to plot histogram\n            n_bins (int): Number of bins in histogram\n            fig_width (float): Figure total width\n            fig_height (float):  Figure total height\n            show_pct (bool, optional): If True, plots percentage on y-axis instead of number of items. Defaults to False.\n\n        Returns:\n            matplotlib.figure.Figure: Histogram figure object\n        \"\"\"\n        print(\"Running Histogram\")\n        fig, ax = plt.subplots(1,1,figsize = (fig_width,fig_height))\n        fontsize = 10\n        self.t3co_results[hist_col] = self.t3co_results[hist_col].astype(float).round(4)\n        if len(self.t3co_results[hist_col]) &gt; 0:\n            if show_pct:\n                hist, bins = np.histogram(\n                    np.array(self.t3co_results[hist_col]), bins=n_bins\n                )\n                ax.bar(\n                    bins[:-1],\n                    hist.astype(np.float32) / hist.sum() * 100,\n                    width=(bins[1] - bins[0]),\n                )\n                ax.set_ylabel(\"Percentage of Scenarios [%]\")\n            else:\n                ax.hist(x=self.t3co_results[hist_col], bins=n_bins)\n                ax.set_ylabel(\"Number of Scenarios\")\n            ax.set_title(\"Histogram Plot\", fontsize=fontsize * 1.25,\n                fontweight=\"bold\",)\n            ax.set_xlabel(self.full_form_dict[hist_col])\n        return fig\n</code></pre>"},{"location":"charts/#t3co.visualization.charts.T3COCharts.cost_col_names","title":"<code>cost_col_names = self.results_guide['full_form'][self.results_guide['t3co_output_parameter'].isin(self.cost_cols.keys())]</code>  <code>instance-attribute</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts.cost_cols","title":"<code>cost_cols = {'residual_cost_dol': '#6C7B8B', 'glider_cost_dol': '#8b7355', 'fuel_converter_cost_dol': '#228B22', 'fuel_storage_cost_dol': '#8B4513', 'motor_control_power_elecs_cost_dol': '#1874CD', 'plug_cost_dol': '#6A5ACD', 'battery_cost_dol': '#7EC0EE', 'purchase_tax_dol': '#CD5B45', 'insurance_cost_dol': '#CDC673', 'total_maintenance_cost_dol': '#DAA520', 'total_fuel_cost_dol': '#4682B4', 'fueling_dwell_labor_cost_dol': '#CD2626', 'discounted_downtime_oppy_cost_dol': '#8B0000', 'payload_capacity_cost_dol': '#CD8C95'}</code>  <code>instance-attribute</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts.edgecolors","title":"<code>edgecolors = ['none', 'black', 'gray', 'white']</code>  <code>instance-attribute</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts.full_form_dict","title":"<code>full_form_dict = dict(zip(self.results_guide['t3co_output_parameter'], self.results_guide['full_form']))</code>  <code>instance-attribute</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts.group_columns","title":"<code>group_columns = ['None', 'vehicle_weight_class', 'veh_year', 'vehicle_type', 'tech_progress', 'vehicle_fuel_type']</code>  <code>instance-attribute</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts.results_guide","title":"<code>results_guide: pd.DataFrame = pd.read_csv(results_guide)</code>  <code>instance-attribute</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts.t3co_results","title":"<code>t3co_results: pd.DataFrame = self.t3co_results.convert_dtypes()</code>  <code>instance-attribute</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts.value_cols","title":"<code>value_cols: List[float] = self.results_guide.loc[self.results_guide['data_type'] == 'float', 't3co_output_parameter'].values</code>  <code>instance-attribute</code>","text":""},{"location":"charts/#t3co.visualization.charts.T3COCharts.__init__","title":"<code>__init__(filename: str = None, results_df: pd.DataFrame = None, results_guide: str | Path = Path(__file__).parents[1] / 'resources' / 'visualization' / 't3co_outputs_guide.csv') -&gt; None</code>","text":"<p>This constructor initializes the T3COCharts object either from a dataframe or a CSV file path.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Filepath to T3CO Results CSV File. Defaults to None.</p> <code>None</code> <code>results_df</code> <code>pd.DataFrame</code> <p>Input pandas dataframe containing T3CO Results. Defaults to None.</p> <code>None</code> <code>results_guide</code> <code>str | Path</code> <p>File path to t3co_outputs_guide.csv file that contains useful parameter descriptions and axis labels. Defaults to Path(file).parents[1]/\"resources\"/\"visualization\"/\"t3co_outputs_guide.csv\".</p> <code>Path(__file__).parents[1] / 'resources' / 'visualization' / 't3co_outputs_guide.csv'</code> Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>def __init__(\n    self,\n    filename: str = None,\n    results_df: pd.DataFrame = None,\n    results_guide: str | Path = Path(__file__).parents[1]\n    / \"resources\"\n    / \"visualization\"\n    / \"t3co_outputs_guide.csv\",\n) -&gt; None:\n    \"\"\"\n    This constructor initializes the T3COCharts object either from a dataframe or a CSV file path.\n\n    Args:\n        filename (str, optional): Filepath to T3CO Results CSV File. Defaults to None.\n        results_df (pd.DataFrame, optional): Input pandas dataframe containing T3CO Results. Defaults to None.\n        results_guide (str | Path, optional): File path to t3co_outputs_guide.csv file that contains useful parameter descriptions and axis labels. Defaults to Path(__file__).parents[1]/\"resources\"/\"visualization\"/\"t3co_outputs_guide.csv\".\n    \"\"\"\n    print(\"Initializing T3COCharts\")\n    if filename is not None:\n        self.from_file(filename)\n    else:\n        self.from_df(results_df)\n\n    self.parse_scenario_name()\n\n    self.results_guide = pd.read_csv(results_guide)\n    self.value_cols = self.results_guide.loc[\n        self.results_guide[\"data_type\"] == \"float\", \"t3co_output_parameter\"\n    ].values\n\n    self.group_columns = [\n        \"None\",\n        \"vehicle_weight_class\",\n        \"veh_year\",\n        \"vehicle_type\",\n        \"tech_progress\",\n        \"vehicle_fuel_type\",\n    ]\n    self.cost_cols = {\n        \"residual_cost_dol\": \"#6C7B8B\",\n        \"glider_cost_dol\": \"#8b7355\",\n        \"fuel_converter_cost_dol\": \"#228B22\",\n        \"fuel_storage_cost_dol\": \"#8B4513\",\n        \"motor_control_power_elecs_cost_dol\": \"#1874CD\",\n        \"plug_cost_dol\": \"#6A5ACD\",\n        \"battery_cost_dol\": \"#7EC0EE\",\n        \"purchase_tax_dol\": \"#CD5B45\",\n        \"insurance_cost_dol\": \"#CDC673\",\n        \"total_maintenance_cost_dol\": \"#DAA520\",\n        \"total_fuel_cost_dol\": \"#4682B4\",\n        \"fueling_dwell_labor_cost_dol\": \"#CD2626\",\n        \"discounted_downtime_oppy_cost_dol\": \"#8B0000\",\n        \"payload_capacity_cost_dol\": \"#CD8C95\",\n    }\n    self.t3co_results = self.t3co_results.convert_dtypes()\n    for costcol in self.cost_cols.keys():\n        self.t3co_results[costcol] = self.t3co_results[costcol].astype(float).round(2)\n    self.t3co_results[\"discounted_tco_dol\"] = self.t3co_results[\n        \"discounted_tco_dol\"\n    ].astype(float)\n    self.full_form_dict = dict(\n        zip(\n            self.results_guide[\"t3co_output_parameter\"],\n            self.results_guide[\"full_form\"],\n        )\n    )\n    self.cost_col_names = self.results_guide[\"full_form\"][\n        self.results_guide[\"t3co_output_parameter\"].isin(self.cost_cols.keys())\n    ]\n\n    self.edgecolors = [\n        \"none\",\n        \"black\",\n        \"gray\",\n        \"white\",\n    ]\n</code></pre>"},{"location":"charts/#t3co.visualization.charts.T3COCharts.from_df","title":"<code>from_df(results_df: pd.DataFrame) -&gt; None</code>","text":"<p>This method reads t3co_results from a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>results_df</code> <code>pd.DataFrame</code> <p>Input T3CO Results dataframe</p> required Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>def from_df(self, results_df: pd.DataFrame) -&gt; None:\n    \"\"\"\n    This method reads t3co_results from a dataframe\n\n    Args:\n        results_df (pd.DataFrame): Input T3CO Results dataframe\n    \"\"\"\n    self.t3co_results = results_df\n</code></pre>"},{"location":"charts/#t3co.visualization.charts.T3COCharts.from_file","title":"<code>from_file(filename: str | Path = None) -&gt; None</code>","text":"<p>This method reads a T3CO Results CSV file into a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str | Path</code> <p>Path to T3CO Results CSV File. Defaults to None.</p> <code>None</code> Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>def from_file(\n    self,\n    filename: str | Path = None,\n) -&gt; None:\n    \"\"\"\n    This method reads a T3CO Results CSV file into a dataframe\n\n    Args:\n        filename (str | Path, optional): Path to T3CO Results CSV File. Defaults to None.\n    \"\"\"\n    self.t3co_results = pd.read_csv(filename)\n</code></pre>"},{"location":"charts/#t3co.visualization.charts.T3COCharts.generate_histogram","title":"<code>generate_histogram(hist_col: str, n_bins: int, fig_width: float = 8, fig_height: float = 5, show_pct: bool = False) -&gt; matplotlib.figure.Figure</code>","text":"<p>This method generates a histogram plot based on inputs hist_col and n_bins</p> <p>Parameters:</p> Name Type Description Default <code>hist_col</code> <code>str</code> <p>T3CO column name to plot histogram</p> required <code>n_bins</code> <code>int</code> <p>Number of bins in histogram</p> required <code>fig_width</code> <code>float</code> <p>Figure total width</p> <code>8</code> <code>fig_height</code> <code>float</code> <p>Figure total height</p> <code>5</code> <code>show_pct</code> <code>bool</code> <p>If True, plots percentage on y-axis instead of number of items. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>matplotlib.figure.Figure: Histogram figure object</p> Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>def generate_histogram(\n    self, hist_col: str, n_bins: int, fig_width:float =8, fig_height:float = 5, show_pct: bool = False\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"\n    This method generates a histogram plot based on inputs hist_col and n_bins\n\n    Args:\n        hist_col (str): T3CO column name to plot histogram\n        n_bins (int): Number of bins in histogram\n        fig_width (float): Figure total width\n        fig_height (float):  Figure total height\n        show_pct (bool, optional): If True, plots percentage on y-axis instead of number of items. Defaults to False.\n\n    Returns:\n        matplotlib.figure.Figure: Histogram figure object\n    \"\"\"\n    print(\"Running Histogram\")\n    fig, ax = plt.subplots(1,1,figsize = (fig_width,fig_height))\n    fontsize = 10\n    self.t3co_results[hist_col] = self.t3co_results[hist_col].astype(float).round(4)\n    if len(self.t3co_results[hist_col]) &gt; 0:\n        if show_pct:\n            hist, bins = np.histogram(\n                np.array(self.t3co_results[hist_col]), bins=n_bins\n            )\n            ax.bar(\n                bins[:-1],\n                hist.astype(np.float32) / hist.sum() * 100,\n                width=(bins[1] - bins[0]),\n            )\n            ax.set_ylabel(\"Percentage of Scenarios [%]\")\n        else:\n            ax.hist(x=self.t3co_results[hist_col], bins=n_bins)\n            ax.set_ylabel(\"Number of Scenarios\")\n        ax.set_title(\"Histogram Plot\", fontsize=fontsize * 1.25,\n            fontweight=\"bold\",)\n        ax.set_xlabel(self.full_form_dict[hist_col])\n    return fig\n</code></pre>"},{"location":"charts/#t3co.visualization.charts.T3COCharts.generate_tco_plots","title":"<code>generate_tco_plots(x_group_col: str, y_group_col: str, subplot_group_col: str = 'vehicle_fuel_type', fig_x_size: int = 8, fig_y_size: int = 8, bar_width: float = 0.8, legend_pos: float = 0.25, edgecolor: str = 'none') -&gt; matplotlib.figure.Figure</code>","text":"<p>This method generates a TCO Breakdown plot based on input arguments. If x_group_col and/or y_group_col are provided, then a matrix/grid of subplots are generated within the same figure based on row- and column-wise groupings</p> <p>Parameters:</p> Name Type Description Default <code>x_group_col</code> <code>str</code> <p>T3CO Results parameter name to group on x-axis, i.e., grouping criteria for columns in subplots grid</p> required <code>y_group_col</code> <code>str</code> <p>T3CO Results parameter name to group on y-axis, i.e., grouping criteria for rows in subplots grid</p> required <code>subplot_group_col</code> <code>str</code> <p>T3CO Results parameter to display within each subplots cell. Defaults to \"vehicle_fuel_type\".</p> <code>'vehicle_fuel_type'</code> <code>fig_x_size</code> <code>int</code> <p>Figure width relative to each bar on x-axis within subplot. Defaults to 8.</p> <code>8</code> <code>fig_y_size</code> <code>int</code> <p>Figure height relative to each subplot cell. Defaults to 8.</p> <code>8</code> <code>bar_width</code> <code>float</code> <p>Relative width of bars based on available width. Takes values between 0.0 and 1.0. Defaults to 0.8.</p> <code>0.8</code> <code>legend_pos</code> <code>float</code> <p>Relative position of legend on the right side of plots. Takes values between 0.0 and 1.0. Defaults to 0.25.</p> <code>0.25</code> <code>edgecolor</code> <code>str</code> <p>Edge color to distinguish cost elements in the stacked bars. Defaults to \"none\".</p> <code>'none'</code> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>matplotlib.figure.Figure: TCO Breakdown Figure object</p> Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>def generate_tco_plots(\n    self,\n    x_group_col: str,\n    y_group_col: str,\n    subplot_group_col: str = \"vehicle_fuel_type\",\n    fig_x_size: int = 8,\n    fig_y_size: int = 8,\n    bar_width: float = 0.8,\n    legend_pos: float = 0.25,\n    edgecolor: str = \"none\",\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"\n    This method generates a TCO Breakdown plot based on input arguments.\n    If x_group_col and/or y_group_col are provided, then a matrix/grid of subplots are generated within the same figure based on row- and column-wise groupings\n\n    Args:\n        x_group_col (str): T3CO Results parameter name to group on x-axis, i.e., grouping criteria for columns in subplots grid\n        y_group_col (str): T3CO Results parameter name to group on y-axis, i.e., grouping criteria for rows in subplots grid\n        subplot_group_col (str, optional): T3CO Results parameter to display within each subplots cell. Defaults to \"vehicle_fuel_type\".\n        fig_x_size (int, optional): Figure width relative to each bar on x-axis within subplot. Defaults to 8.\n        fig_y_size (int, optional): Figure height relative to each subplot cell. Defaults to 8.\n        bar_width (float, optional): Relative width of bars based on available width. Takes values between 0.0 and 1.0. Defaults to 0.8.\n        legend_pos (float, optional): Relative position of legend on the right side of plots. Takes values between 0.0 and 1.0. Defaults to 0.25.\n        edgecolor (str, optional): Edge color to distinguish cost elements in the stacked bars. Defaults to \"none\".\n\n    Returns:\n        matplotlib.figure.Figure: TCO Breakdown Figure object\n    \"\"\"\n    print(\"running generate_tco_plots\")\n    disc_tco_label = self.results_guide[\"full_form\"][\n        self.results_guide[\"t3co_output_parameter\"] == \"discounted_tco_dol\"\n    ]\n    legend_cols = list(disc_tco_label) + list(self.cost_col_names)\n    x_groups = (\n        self.t3co_results[x_group_col].unique() if x_group_col != \"None\" else [0]\n    )\n    y_groups = (\n        self.t3co_results[y_group_col].unique() if y_group_col != \"None\" else [0]\n    )\n    fontsize = 25\n\n    if (x_group_col == \"None\" and y_group_col == \"None\") or (\n        len(x_groups) == 1 and len(y_groups) == 1\n    ):\n        fig, ax = plt.subplots(\n            1,\n            1,\n            figsize=(\n                min(len(self.t3co_results) * fig_x_size + 4, 50),\n                min(4 + fig_y_size, 50),\n            ),\n            sharex=True,\n        )\n        # bottom = np.zeros(len(groups))\n        # width = 0.15\n        x_values = range(\n            len(self.t3co_results)\n        )  # X-values based on the index of the DataFrame\n        y_values = self.t3co_results[\"discounted_tco_dol\"]\n\n        ax.scatter(\n            x_values,\n            y_values,\n            color=\"red\",\n            label=disc_tco_label,\n            zorder=3,\n            marker=\"D\",\n            s=100,\n        )\n        self.t3co_results.plot.bar(\n            y=self.cost_cols.keys(),\n            stacked=True,\n            figsize=(min(len(self.t3co_results) * fig_x_size, 50), 6 + fig_y_size),\n            width=bar_width,\n            ax=ax,\n            legend=False,\n            color=self.cost_cols,\n            edgecolor=(edgecolor if edgecolor in self.edgecolors else \"none\"),\n            alpha=0.8,\n        )\n\n        xlabels = [\n            \"\\n\".join(wrap(x, 25)) for x in self.t3co_results[\"scenario_name\"]\n        ]\n\n        # bars = ax.patches\n        # hatches = [p for p in patterns for i in range(len(self.t3co_results[self.cost_cols.keys()]))]\n        # for bar, hatch in zip(bars, hatches):\n        #     bar.set_hatch(hatch)\n        # self.t3co_results.plot.line(x = ['scenario_name'], y= ['discounted_tco_dol'], ax= ax)\n        ax.set_xlabel(\"Scenarios\", fontsize=fontsize, labelpad=10)\n        ax.get_yaxis().set_major_formatter(\n            FuncFormatter(lambda x, p: \"$\" + format(int(x), \",\"))\n        )\n        ax.set_xticklabels(self.t3co_results[\"scenario_name\"])\n        ax.set_ylabel(r\"Cost [$]\", fontsize=fontsize, labelpad=10)\n        ax.minorticks_on()\n        ax.set_xlim(-0.5, len(self.t3co_results) - 0.5)\n\n        ax.set_xlim(-0.5, len(x_values) - 0.5)\n\n        # plt.tight_layout()\n        ax.set_xticks(range(len(self.t3co_results)), xlabels)\n        ax.tick_params(labelsize=fontsize)\n        handles, labels = [], []\n        for h, l in zip(*ax.get_legend_handles_labels()):\n            handles.append(h)\n            labels.append(l)\n\n        fig.legend(\n            handles,\n            legend_cols,\n            loc=\"center right\",\n            bbox_to_anchor=(1 + legend_pos, 0.5),\n            fontsize=fontsize,\n        )\n\n        fig.suptitle(\n            \"Total Cost Of Ownership Breakdown\",\n            fontsize=fontsize * 1.5,\n            fontweight=\"bold\",\n        )\n        fig = ax.get_figure()\n\n    elif len(x_groups) &gt; 1 and len(y_groups) == 1:\n        fig, ax = plt.subplots(\n            1,\n            len(x_groups),\n            sharey=True,\n            sharex=True,\n            figsize=(min(len(x_groups) * fig_x_size + 8, 50), min(4 + fig_y_size,50)),\n        )\n        # print(self.t3co_results.loc[ self.t3co_results[x_group_col] == x_groups[0]])\n\n        max_x = 1\n        # print(f'maxn = {maxn}')\n        for i in range(len(x_groups)):\n            x_values = range(\n                len(\n                    self.t3co_results.loc[\n                        self.t3co_results[x_group_col] == x_groups[i]\n                    ]\n                )\n            )  # X-values based on the index of the DataFrame\n            y_values = self.t3co_results.loc[\n                self.t3co_results[x_group_col] == x_groups[i], \"discounted_tco_dol\"\n            ]\n            ax[i].scatter(\n                x_values,\n                y_values,\n                color=\"red\",\n                label=disc_tco_label,\n                zorder=3,\n                marker=\"D\",\n            )\n\n            self.t3co_results.loc[\n                self.t3co_results[x_group_col] == x_groups[i]\n            ].plot.bar(\n                x=subplot_group_col,\n                y=self.cost_cols.keys(),\n                stacked=True,\n                ax=ax[i],\n                figsize=(\n                    min(len(self.t3co_results) * fig_x_size, 50),\n                    min(len(y_groups) * fig_y_size + 4, 50),\n                ),\n                legend=False,\n                width=bar_width,\n                color=self.cost_cols,\n                edgecolor=edgecolor,\n                alpha=0.7,\n            )\n            ax[i].minorticks_on()\n\n            max_x = max(len(x_values), max_x)\n\n            ax[i].set_xticks(\n                x_values,\n                self.t3co_results.loc[\n                    self.t3co_results[x_group_col] == x_groups[i], subplot_group_col\n                ],\n            )\n\n            ax[i].set_xlabel(f\"{x_groups[i]}\", fontsize=fontsize, labelpad=10)\n            ax[i].tick_params(axis=\"x\", labelsize=fontsize, labelrotation=90)\n            ax[i].tick_params(axis=\"y\", labelsize=fontsize, labelrotation=0)\n\n            ax[i].get_yaxis().set_major_formatter(\n                FuncFormatter(lambda x, p: \"$\" + format(int(x), \",\"))\n            )\n\n        for i in range(len(x_groups)):\n            ax[i].set_xlim(-0.5, max_x - 0.5)\n\n        fig.supylabel(r\"Cost [$]\", fontsize=fontsize)\n\n        fig.suptitle(\n            \"Total Cost Of Ownership Breakdown\",\n            fontsize=fontsize * 1.5,\n            fontweight=\"bold\",\n        )\n\n        handles, labels = [], []\n        for h, l in zip(*ax[-1].get_legend_handles_labels()):\n            handles.append(h)\n            labels.append(l)\n\n        fig.legend(\n            handles,\n            legend_cols,\n            loc=\"center right\",\n            bbox_to_anchor=(1 + legend_pos, 0.5),\n            fontsize=fontsize,\n        )\n\n        fig.supxlabel(\n            self.full_form_dict[x_group_col],\n            fontsize=fontsize,\n        )\n        plt.subplots_adjust(bottom=0.21)\n\n    elif len(y_groups) &gt; 1 and len(x_groups) == 1:\n        fontsize = 25\n        max_x = 1\n        fig, ax = plt.subplots(\n            len(y_groups),\n            sharex=True,\n            sharey=True,\n            figsize=(\n                min(10 + fig_x_size, 50),\n                min(len(y_groups) * fig_y_size + 4, 50),\n            ),\n        )\n\n        for i in range(len(y_groups)):\n            x_values = range(\n                len(\n                    self.t3co_results.loc[\n                        self.t3co_results[y_group_col] == y_groups[i]\n                    ]\n                )\n            )  # X-values based on the index of the DataFrame\n            y_values = self.t3co_results.loc[\n                self.t3co_results[y_group_col] == y_groups[i], \"discounted_tco_dol\"\n            ]\n            ax[i].scatter(\n                x_values,\n                y_values,\n                color=\"red\",\n                label=disc_tco_label,\n                zorder=3,\n                marker=\"D\",\n            )\n\n            self.t3co_results.loc[\n                self.t3co_results[y_group_col] == y_groups[i]\n            ].plot.bar(\n                x=subplot_group_col,\n                y=self.cost_cols.keys(),\n                stacked=True,\n                figsize=(\n                    min(len(self.t3co_results) * fig_x_size, 50),\n                    min(len(y_groups) * fig_y_size, 50),\n                ),\n                ax=ax[i],\n                legend=False,\n                width=bar_width,\n                color=self.cost_cols,\n                edgecolor=edgecolor,\n                alpha=0.7,\n            )\n\n            ax[i].get_yaxis().set_major_formatter(\n                FuncFormatter(lambda x, p: \"$\" + format(int(x), \",\"))\n            )\n\n            ax[i].minorticks_on()\n\n            ax2 = ax[i].twinx()\n            ax2.set_ylabel(y_groups[i], fontsize=fontsize, labelpad=10)\n            ax2.set_yticks([])\n            max_x = max(len(x_values), max_x)\n\n            ax[i].tick_params(axis=\"x\", labelsize=fontsize, labelrotation=90)\n            ax[i].tick_params(axis=\"y\", labelsize=fontsize, labelrotation=0)\n\n        for i in range(len(y_groups)):\n            ax[i].set_xlim(-0.5, max_x - 0.5)\n            ax[i].set_xlabel(\"\")\n\n        handles, labels = [], []\n        for h, l in zip(*ax[-1].get_legend_handles_labels()):\n            handles.append(h)\n            labels.append(l)\n\n        fig.legend(\n            handles,\n            legend_cols,\n            loc=\"center right\",\n            bbox_to_anchor=(1 + legend_pos, 0.5),\n            fontsize=fontsize,\n        )\n\n        fig.supylabel(r\"Cost [$]\", fontsize=fontsize)\n        fig.supxlabel(\n            self.full_form_dict[subplot_group_col],\n            fontsize=fontsize,\n        )\n        fig.suptitle(\n            \"Total Cost Of Ownership Breakdown\",\n            fontsize=fontsize * 1.5,\n            fontweight=\"bold\",\n        )\n\n    else:\n        fontsize = 25\n        max_x = 1\n        fig, ax = plt.subplots(\n            len(y_groups),\n            len(x_groups),\n            sharey=True,\n            sharex=True,\n            figsize=(\n                min(len(y_groups) * fig_x_size + 3, 50),\n                min(len(x_groups) * fig_y_size + 7, 50),\n            ),\n        )\n\n        for i in range(len(y_groups)):\n            for j in range(len(x_groups)):\n                x_values = range(\n                    len(\n                        self.t3co_results.loc[\n                            (self.t3co_results[y_group_col] == y_groups[i])\n                            &amp; (self.t3co_results[x_group_col] == x_groups[j])\n                        ]\n                    )\n                )  # X-values based on the index of the DataFrame\n\n                y_values = self.t3co_results.loc[\n                    (self.t3co_results[y_group_col] == y_groups[i])\n                    &amp; (self.t3co_results[x_group_col] == x_groups[j]),\n                    \"discounted_tco_dol\",\n                ]\n                ax[i][j].scatter(\n                    x_values,\n                    y_values,\n                    color=\"red\",\n                    label=disc_tco_label,\n                    zorder=3,\n                    marker=\"D\",\n                )\n\n                ax[i][j].set_xlabel(\n                    f\"{x_groups[j]}\", fontsize=fontsize, labelpad=10\n                )\n                ax2 = ax[i][j].twinx()\n                ax2.set_ylabel(f\"{y_groups[i]}\", fontsize=fontsize, labelpad=10)\n                ax2.set_yticks([])\n\n                ax[i][j].tick_params(axis=\"x\", labelsize=fontsize, labelrotation=90)\n                ax[i][j].tick_params(axis=\"y\", labelsize=fontsize, labelrotation=0)\n\n                if self.t3co_results.loc[\n                    (self.t3co_results[y_group_col] == y_groups[i])\n                    &amp; (self.t3co_results[x_group_col] == x_groups[j])\n                ].empty:\n                    continue\n\n                self.t3co_results.loc[\n                    (self.t3co_results[y_group_col] == y_groups[i])\n                    &amp; (self.t3co_results[x_group_col] == x_groups[j])\n                ].plot.bar(\n                    x=subplot_group_col,\n                    y=self.cost_cols.keys(),\n                    stacked=True,\n                    ax=ax[i][j],\n                    legend=False,\n                    width=bar_width,\n                    color=self.cost_cols,\n                )\n\n                max_x = max(len(x_values), max_x)\n\n        for i in range(len(y_groups)):\n            for j in range(len(x_groups)):\n                ax[i][j].set_xlim(-0.5, max_x - 0.5)\n\n        handles, labels = [], []\n        for h, l in zip(*ax[-1][-1].get_legend_handles_labels()):\n            handles.append(h)\n            labels.append(l)\n\n        fig.legend(\n            handles,\n            legend_cols,\n            loc=\"center right\",\n            bbox_to_anchor=(1 + legend_pos, 0.5),\n            fontsize=fontsize,\n        )\n\n        fig.supylabel(r\"Cost [$]\", fontsize=fontsize)\n        fig.supxlabel(\n            self.full_form_dict[subplot_group_col],\n            fontsize=fontsize,\n        )\n        fig.suptitle(\n            \"Total Cost Of Ownership Breakdown\",\n            fontsize=fontsize * 1.25,\n            fontweight=\"bold\",\n        )\n\n    return fig\n</code></pre>"},{"location":"charts/#t3co.visualization.charts.T3COCharts.generate_violin_plot","title":"<code>generate_violin_plot(x_group_col: str, y_group_col: str = 'discounted_tco_dol', fig_width: float = 8, fig_height: float = 5) -&gt; matplotlib.figure.Figure</code>","text":"<p>This method generates a violin plot based on x-axis group column and y-axis column name.</p> <p>Parameters:</p> Name Type Description Default <code>x_group_col</code> <code>str</code> <p>T3CO Results parameter to group by on x-axis inside violinplot</p> required <code>y_group_col</code> <code>str</code> <p>T3CO Results parameter to plot on y-axis. Defaults to \"discounted_tco_dol\".</p> <code>'discounted_tco_dol'</code> <p>Returns:</p> Type Description <code>matplotlib.figure.Figure</code> <p>matplotlib.figure.Figure: Violin Plot Figure object</p> Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>def generate_violin_plot(\n    self, x_group_col: str, y_group_col: str = \"discounted_tco_dol\", fig_width:float =8, fig_height:float = 5,\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"\n    This method generates a violin plot based on x-axis group column and y-axis column name.\n\n    Args:\n        x_group_col (str): T3CO Results parameter to group by on x-axis inside violinplot\n        y_group_col (str, optional): T3CO Results parameter to plot on y-axis. Defaults to \"discounted_tco_dol\".\n\n    Returns:\n        matplotlib.figure.Figure: Violin Plot Figure object\n    \"\"\"\n    print(\"Running Violin plots\")\n    fontsize = 10\n    fig, ax = plt.subplots(1,1,figsize = (fig_width,fig_height))\n    self.t3co_results[y_group_col] = self.t3co_results[y_group_col].astype(float).round(5)\n    sns.violinplot(\n        x=x_group_col,\n        y=y_group_col,\n        data=self.t3co_results,\n        ax=ax,\n        palette=\"colorblind\",\n        cut=0,\n        density_norm=\"count\",\n        inner=\"quart\",\n        hue=x_group_col,\n        legend=False,\n    )\n    if \"dol\" in y_group_col:\n        ax.get_yaxis().set_major_formatter(\n            FuncFormatter(lambda x, p: \"$\" + format(int(x), \",\"))\n        )\n\n    ax.set_title(\"Violin Plot\",fontsize=fontsize * 1.5,\n            fontweight=\"bold\",)\n    ax.set_ylabel(self.full_form_dict[y_group_col])\n    ax.set_xlabel(self.full_form_dict[x_group_col])\n    return fig\n</code></pre>"},{"location":"charts/#t3co.visualization.charts.T3COCharts.parse_scenario_name","title":"<code>parse_scenario_name() -&gt; None</code>","text":"<p>This method parses 'scenario_name' into 'vehicle_type', 'tech_progress', and 'vehicle_fuel_type' and uses 'scenario_gvwr_kg' to create 'vehicle_weight_class'</p> Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>def parse_scenario_name(self) -&gt; None:\n    \"\"\"\n    This method parses 'scenario_name' into 'vehicle_type', 'tech_progress', and 'vehicle_fuel_type' and uses 'scenario_gvwr_kg' to create 'vehicle_weight_class'\n    \"\"\"\n    weight_class_ranges = {\n        \"1\": [0, 2722],\n        \"2a\": [2722, 3856],\n        \"2b\": [3856, 4536],\n        \"3\": [4536, 6350],\n        \"4\": [6350, 7257],\n        \"5\": [7257, 8845],\n        \"6\": [8845, 11793],\n        \"7\": [11793, 14969],\n        \"8\": [14969, 50000],\n    }\n    self.t3co_results[\"vehicle_weight_class\"] = \"\"\n    for i in range(len(self.t3co_results)):\n        for wt_class, lims in weight_class_ranges.items():\n            if (\n                float(self.t3co_results[\"scenario_gvwr_kg\"][i]) &gt; lims[0]\n                and float(self.t3co_results[\"scenario_gvwr_kg\"][i]) &lt;= lims[1]\n            ):\n                self.t3co_results.loc[[i], \"vehicle_weight_class\"] = (\n                    \"Class \" + wt_class\n                )\n                break\n\n    self.t3co_results[\"vehicle_type\"] = (\n        self.t3co_results[\"scenario_name\"]\n        .str.split(\"(\")\n        .apply(lambda x: \" \".join(x[0].split(\" \")[2:]))\n    )\n\n    self.t3co_results[\"tech_progress\"] = (\n        self.t3co_results[\"scenario_name\"]\n        .str.split(\"(\")\n        .apply(lambda x: x[1].split(\",\")[-1].split(\")\")[0])\n    )\n    self.t3co_results[\"vehicle_fuel_type\"] = (\n        self.t3co_results[\"scenario_name\"]\n        .str.split(\"(\")\n        .apply(lambda x: x[1].split(\",\")[0])\n    )\n</code></pre>"},{"location":"charts/#t3co.visualization.charts.T3COCharts.to_df","title":"<code>to_df() -&gt; pd.DataFrame</code>","text":"<p>This returns the self.t3co_results member</p> <p>Returns:</p> Type Description <code>pd.DataFrame</code> <p>pd.DataFrame: T3CO Results dataframe</p> Source code in <code>t3co/visualization/charts.py</code> Python<pre><code>def to_df(self) -&gt; pd.DataFrame:\n    \"\"\"\n    This returns the self.t3co_results member\n\n    Returns:\n        pd.DataFrame: T3CO Results dataframe\n    \"\"\"\n    return self.t3co_results\n</code></pre>"},{"location":"config_inputs_descriptions/","title":"Config Input Parameters Descriptions","text":"Config Input Parameter Description Data Type(s) Accepted analysis_id Index for managing T3CO analyses or runs int analysis_name Name of T3CO Analysis for user's reference string vehicle_file Filepath to vehicle file relative to /t3co/ folder string scenario_file Filepath to scenario file relative to /t3co/ folder string dst_dir Filepath to results destination directory string write_tsv Boolean switch to save intermediate results files bool selections List of selections from vehicle/scenario files to include in the analysis. Takes input as an integer or list of integers. '-1' makes T3CO run all vehicles in the vehicle file int/list[int] vehicle_life_yr Override number of TCO years for all selections.. If left blank, T3CO uses selection specific vehicle_life_yr from scenario file int TCO_method Choose TCO Calculation method between 'DIRECT' and 'EFFICIENCY'. 'DIRECT' method uses scenario.downtime_oppy_cost_dol_per_hr to estimate downtime opportunity costs while 'EFFICIENCY' method uses a time-based efficiency value to implicitly include downtime opportunity costs in the discounted_tco_dol. Defaults to 'DIRECT' if left blank. str ess_max_charging_power_kw Override ESS max charging power for all selections. If left blank, T3CO uses selection specific ess_max_charging_power_kw from scenario file float fs_fueling_rate_kg_per_min Override gaseous fueling fill rate for all selections. If left blank, T3CO uses selection specific fs_fueling_rate_kg_per_min from scenario file float fs_fueling_rate_gasoline_gpm Override gasoline liquid fueling fill rate for all selections. If left blank, T3CO uses selection specific fs_fueling_rate_gasoline_gpm from scenario file float fs_fueling_rate_diesel_gpm Override diesel liquid fueling fill rate for all selections. If left blank, T3CO uses selection specific fs_fueling_rate_diesel_gpm from scenario file float algorithms Algorithm for pymoo optimization. Select from  [\"NSGA2\", \"PatternSearch\"] string lw_imp_curves Filepath to lightweighting improvement cost curve relative to /t3co/ folder string eng_eff_imp_curves Filepath to engine efficiency improvement cost curve relative to /t3co/ folder string aero_drag_imp_curves Filepath to aerodynamic drag coefficient improvement cost curve relative to /t3co/ folder string lw_imp_curve_sel Override selection of light weighting improvement curve from lw_imp_curves file for all selections string eng_eff_imp_curve_sel Override selection of engine efficiency improvement curve from eng_eff_imp_curves file for all selections string aero_drag_imp_curve_sel Override selection of aerodynamic drag improvement curve from aero_drag_imp_curves file for all selections string skip_all_opt Boolean switch to override skip optimization for all selections bool constraint_range Override boolean switch for optimization range constraint for all selections - if left blank, T3CO uses selection specific switch bool constraint_accel Override boolean switch for optimization acceleration constraint for all selections- if left blank, T3CO uses selection specific switch bool constraint_grade Override boolean switch for optimization gradeability constraint for all selections- if left blank, T3CO uses selection specific switch bool objective_tco Override boolean switch for optimization objective as TCO for all selections- if left blank, T3CO uses selection specific switch bool constraint_c_rate Override boolean switch for optimization charge rate constraint for all selections- if left blank, T3CO uses selection specific switch bool constraint_trace_miss_dist_percent_on Override boolean switch for optimization distance trace miss percentage for all selections- if left blank, T3CO uses selection specific switch bool objective_phev_minimize_fuel_use Override boolean switch for optimization objective for PHEV to minimize fuel consumption for all selections- if left blank, T3CO uses selection specific switch bool activate_tco_payload_cap_cost_multiplier Override boolean switch for lost payload capacity opportunity cost calculations- if left blank, T3CO uses selection specific switch bool activate_tco_fueling_dwell_time_cost Override boolean switch for fueling dwell time opportunity cost calculations- if left blank, T3CO uses selection specific switch bool fdt_frac_full_charge_bounds Override fraction of lower and upper bounds for fractional charge- if left blank, T3CO uses selection specific switch list activate_mr_downtime_cost Override boolean switch for maintenance and repair downtime opportunity cost calculations- if left blank, T3CO uses selection specific switch bool"},{"location":"fueleconomy/","title":"Fuel Economy Sub-Module","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy","title":"<code>t3co.objectives.fueleconomy</code>","text":"<p>Module containing functions for calculating fuel economy objectives.</p>"},{"location":"fueleconomy/#t3co.objectives.fueleconomy.CD","title":"<code>CD = 0</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.CS","title":"<code>CS = 1</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.PHEV","title":"<code>PHEV = 365</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.cd_elec_kwh_out_ach","title":"<code>cd_elec_kwh_out_ach = round(sum(np.array(sim_drives[CD].ess_kw_out_ach) / 3600), 1)</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.cd_elec_mpgge","title":"<code>cd_elec_mpgge = round(sum(sim_drives[CD].dist_mi) / cd_elec_kwh_out_ach / gl.get_kwh_per_gge(), 1)</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.cd_fuel_kwh_out_ach","title":"<code>cd_fuel_kwh_out_ach = round(sum(sim_drives[CD].fs_kwh_out_ach), 1)</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.cs_elec_kwh_out_ach","title":"<code>cs_elec_kwh_out_ach = round(sum(np.array(sim_drives[CS].ess_kw_out_ach) / 3600), 1)</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.cs_fuel_kwh_out_ach","title":"<code>cs_fuel_kwh_out_ach = round(sum(sim_drives[CS].fs_kwh_out_ach), 1)</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.cyc_file_path","title":"<code>cyc_file_path = gl.OPTIMIZATION_DRIVE_CYCLES / 'regional_haul.csv'</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.cycle","title":"<code>cycle = run_scenario.load_design_cycle_from_path(cyc_file_path)</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.fc_kwh_cummultive","title":"<code>fc_kwh_cummultive = np.cumsum(np.array(sim_drives[0].fc_kw_out_ach)) / 3600</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.fc_kwh_out","title":"<code>fc_kwh_out = np.array(sim_drives[0].fc_kw_out_ach) / 3600</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.mc_kwh_cummultive","title":"<code>mc_kwh_cummultive = np.cumsum(np.array(sim_drives[0].mc_mech_kw_out_ach)) / 3600</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.mk_kwh_out","title":"<code>mk_kwh_out = np.array(sim_drives[0].mc_mech_kw_out_ach) / 3600</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.scenario_inputs_path","title":"<code>scenario_inputs_path = Path(gl.T3CO_INPUTS_DIR / 'tda_example/TDA_FY22_scenario_assumptions.csv').resolve()</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.v","title":"<code>v = run_scenario.get_vehicle(PHEV, vehicle_input_path)</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.vehicle_input_path","title":"<code>vehicle_input_path = Path(gl.T3CO_INPUTS_DIR / 'tda_example/TDA_FY22_vehicle_model_assumptions.csv').resolve()</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.x","title":"<code>x = range(0, len(cycle.time_s))</code>  <code>module-attribute</code>","text":""},{"location":"fueleconomy/#t3co.objectives.fueleconomy.get_mpgge","title":"<code>get_mpgge(eff_range_cyc: fastsim.cycle.Cycle | List[Tuple[fastsim.cycle.Cycle, float]], v: fastsim.vehicle.Vehicle, scenario, diagnostic=False) -&gt; Tuple[dict, List[fastsim.simdrive.SimDrive], List[dict]]</code>","text":"<p>This helper method gets the composite mpgge fuel efficiency of vehicle for each efficiency_range Drive Cycle and weight. It runs the vehicle using efficiency range cycle(s) and returns mpgge based on the powertrain type</p> <p>Method computes a composite mpgge from multiple drive cycles and weights for each cycle. If the user passes in a single Drive Cycle rather than a list of tuples, the base case of a composite mpgge from a single Drive Cycle and a single weight, 1, is computed.</p> <p>Also updates the vehicle's corresponding scenario object</p> <p>Parameters:</p> Name Type Description Default <code>eff_range_cyc</code> <code>fastsim.cycle.Cycle | List[Tuple[fastsim.cycle.Cycle, float]]</code> <p>efficiency range cycle</p> required <code>v</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for current selection</p> required <code>diagnostic</code> <code>bool</code> <p>if True, returns all mpgge dicts. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>unknown vehicle powertrain type</p> <p>Returns:</p> Name Type Description <code>mpgge_comp</code> <code>dict</code> <p>Dictionary containing MPGGE breakdowns</p> <code>sim_drives</code> <code>List[fastsim.simdrive.SimDrive]</code> <p>List of simdrives for charge depleting and charge sustaining cycles</p> <code>mpgges</code> <code>(List[dict], optional)</code> <p>if diagnostic==True, returns additional</p> Source code in <code>t3co/objectives/fueleconomy.py</code> Python<pre><code>def get_mpgge(\n    eff_range_cyc: fastsim.cycle.Cycle | List[Tuple[fastsim.cycle.Cycle, float]],\n    v: fastsim.vehicle.Vehicle,\n    scenario,\n    diagnostic=False,\n) -&gt; Tuple[dict, List[fastsim.simdrive.SimDrive], List[dict]]:\n    \"\"\"\n    This helper method gets the composite mpgge fuel efficiency of vehicle for each efficiency_range Drive Cycle and weight.\n    It runs the vehicle using efficiency range cycle(s) and returns mpgge based on the powertrain type\n\n    Method computes a composite mpgge from multiple drive cycles and weights for each cycle.\n    If the user passes in a single Drive Cycle rather than a list of tuples, the base case of\n    a composite mpgge from a single Drive Cycle and a single weight, 1, is computed.\n\n    Also updates the vehicle's corresponding scenario object\n\n    Args:\n        eff_range_cyc (fastsim.cycle.Cycle | List[Tuple[fastsim.cycle.Cycle, float]]): efficiency range cycle\n        v (fastsim.vehicle.Vehicle): FASTSim vehicle object for analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object for current selection\n        diagnostic (bool, optional): if True, returns all mpgge dicts. Defaults to False.\n\n    Raises:\n        ValueError: unknown vehicle powertrain type\n\n    Returns:\n        mpgge_comp (dict): Dictionary containing MPGGE breakdowns\n        sim_drives (List[fastsim.simdrive.SimDrive]): List of simdrives for charge depleting and charge sustaining cycles\n        mpgges (List[dict], optional): if diagnostic==True, returns additional\n\n    \"\"\"\n\n    if not isinstance(eff_range_cyc, list):\n        eff_range_cyc = [(eff_range_cyc, 1)]\n\n    if v.veh_pt_type == gl.BEV:\n        assert (\n            v.mc_max_kw &gt; 0\n        ), \"motor size is 0 kw in BEV - will lead to faulty results\"\n        assert (\n            v.fs_kwh == 0 and v.fc_max_kw == 0\n        ), \"Error! BEV vehicle has non-zero ICE attributes - vehicle mass calculation may be off\"\n    elif v.veh_pt_type == gl.CONV:\n        assert (\n            v.fc_max_kw &gt; 0\n        ), \"engine size is 0 kw in CONV - will lead to faulty results\"\n        assert (\n            v.ess_max_kwh == 0 and v.mc_max_kw == 0\n        ), \"Error! CONV vehicle has non-zero BEV attributes - vehicle mass calculation may be off\"\n    elif v.veh_pt_type == gl.PHEV:\n        assert (\n            v.fc_max_kw &gt; 0\n        ), \"engine size is 0 kw in CONV - will lead to faulty results\"\n        assert (\n            v.mc_max_kw &gt; 0\n        ), \"motor size is 0 kw in BEV - will lead to faulty results\"\n    elif v.veh_pt_type == gl.HEV:\n        pass\n    else:\n        raise ValueError(f\"unknown vehicle powertrain type {v.veh_pt_type}\")\n\n    mpgges = []\n    weights = []\n    sim_drives = []\n    for cycle_weight in eff_range_cyc:\n        # efficiency-range cycle, weight\n        erc, w = cycle_weight\n\n        if v.veh_pt_type == gl.PHEV:\n            # get two copies of cycle, rename\n            cd_erc = erc.copy()\n            cs_erc = erc.copy()\n            cd_erc.name = \"CD_\" + erc.name\n\n            #\n            # Charge Depleting Cycle first\n            #\n            ess_max_kwh_orig = v.ess_max_kwh\n            ess_max_kw_orig = v.ess_max_kw\n            veh_kg_orig = v.veh_kg\n            # infinite battery hack (with no extra weight) to simulate charge depleting behavior\n            v.veh_override_kg = veh_kg_orig\n            run_scenario.set_max_battery_kwh(v, 50e3)\n            run_scenario.set_max_battery_power_kw(v, 1000)\n            # don't want extra weight from huge battery\n            sim_drive_cd = get_sim_drive(cd_erc, v, scenario)\n            assert (\n                sim_drive_cd.veh.veh_kg == veh_kg_orig\n            ), f\"sim_drive.veh.veh_kg == veh_kg_orig / {round(sim_drive_cd.veh.veh_kg)} == {round(veh_kg_orig)}\"\n            assert (\n                sim_drive_cd.veh.ess_max_kwh == v.ess_max_kwh\n            ), f\"sim_drive.veh.ess_max_kwh == v.ess_max_kwh / {round(sim_drive_cd.veh.ess_max_kwh)} == {round(v.ess_max_kwh)}\"\n            sim_drive_cd.sim_drive(init_soc=v.max_soc)\n            v.veh_override_kg = None\n\n            #\n            # Charge Sustaining Cycle second\n            #\n            # reset battery to inputs for charge sustaining behavior\n            run_scenario.set_max_battery_kwh(v, ess_max_kwh_orig)\n            run_scenario.set_max_battery_power_kw(v, ess_max_kw_orig)\n            # we're supposed to run this as a \"hybrid\" so set\n            # veh_pt_type to gl.HEV so that FASTSim does SOC balancing, run as an HEV, basically\n            v.veh_pt_type = gl.HEV\n            sim_drive_cs = get_sim_drive(cs_erc, v, scenario)\n            sim_drive_cs.sim_drive()\n\n            # CS calcs\n            assert (\n                sim_drive_cs.props.kwh_per_gge == gl.get_kwh_per_gge()\n            ), \"fuel LHV not consistent between T3CO and FASTSim\"\n            cs_fuel_kwh_out_ach = np.sum(sim_drive_cs.fs_kwh_out_ach)\n            cs_fuel_kwh__mi = cs_fuel_kwh_out_ach / np.sum(sim_drive_cs.dist_mi)\n\n            # CD calcs\n            # sim_drive_cd.fs_kwh_out_ach[i] = sim_drive_cd.fs_kw_out_ach[i] * sim_drive_cd.cyc.dt_s[i] * (1 / 3.6e3)\n            assert (\n                sim_drive_cd.props.kwh_per_gge == gl.get_kwh_per_gge()\n            ), \"fuel LHV not consistent between T3CO and FASTSim\"\n            cd_fuel_kwh_out_ach = np.sum(sim_drive_cd.fs_kwh_out_ach)\n            cd_elec_kwh_out_ach = np.sum(\n                np.array(sim_drive_cd.ess_kw_out_ach)\n                * np.array(sim_drive_cd.cyc.dt_s)\n                / 3.6e3\n            )\n            cd_elec_mpgge = np.sum(sim_drive_cd.dist_mi) / (\n                cd_elec_kwh_out_ach / gl.get_kwh_per_gge()\n            )\n            cd_electric_kwh__mi = cd_elec_kwh_out_ach / np.sum(sim_drive_cd.dist_mi)\n            cd_fuel_kwh__mi = cd_fuel_kwh_out_ach / np.sum(sim_drive_cd.dist_mi)\n\n            v.veh_pt_type = gl.PHEV\n            v.set_derived()\n            assert v.veh_kg == veh_kg_orig\n            assert v.ess_max_kwh == ess_max_kwh_orig\n            assert v.ess_max_kw == ess_max_kw_orig\n            assert v.veh_pt_type == gl.PHEV\n\n            # TODO: some CS sd's have sum(fs_kwh_out_ach) == 0 ... how?\n            # These are probably bad designs and should be skipped\n\n            # TODO: these kinds of outputs could be turned into a dataclass to set\n            # desired outputs and have stricter checks\n            mpgge = {\n                #### Charge depleting ####\n                \"cd_electric_mpgge\": cd_elec_mpgge,\n                \"cd_grid_electric_mpgge\": cd_elec_mpgge\n                * v.chg_eff,  # can be used for TCO CD mpgge electric\n                \"cd_fuel_mpgge\": sim_drive_cd.mpgge,\n                \"cd_fuel_mpgde\": sim_drive_cd.mpgge / gl.DieselGalPerGasGal,\n                \"cd_electric_kwh__mi\": cd_electric_kwh__mi,\n                \"cd_fuel_kwh__mi\": cd_fuel_kwh__mi,\n                \"cd_fuel_used_kwh\": cd_fuel_kwh_out_ach,\n                \"cd_elec_used_kwh\": cd_elec_kwh_out_ach,\n                #### Charge sustaining ####\n                \"cs_fuel_mpgge\": sim_drive_cs.mpgge,\n                \"cs_fuel_mpgde\": sim_drive_cs.mpgge / gl.DieselGalPerGasGal,\n                \"cs_fuel_kwh__mi\": cs_fuel_kwh__mi,\n            }\n            sim_drives.append(sim_drive_cd)\n            sim_drives.append(sim_drive_cs)\n        else:\n            sim_drive = get_sim_drive(erc, v, scenario)\n            sim_drive.sim_drive()\n\n            # FASTSim BEV and PHEV have two different fuel efficiencies, the mpgge from battery and the mpgge from grid\n            # grid_mpgge is really just mpgge multiplied by the charger efficiency fraction\n            # grid_mpgge is used for fuel cost calculations\n            # TCO fuel cost = vmt / mpgge * $/gge\n            # for CONV and HEV\n            # this is on an energy basis (mpgge has no electric component if the vehicle is CONV)\n            # if vehicle is HEV mpgge = mpgge_from_fs_kwh_used + mpgge_from_battery_kwh_used\n            if v.veh_pt_type in [gl.CONV, gl.HEV]:\n                mpgge_both = sim_drive.mpgge\n            else:\n                mpgge_both = (\n                    sim_drive.mpgge\n                    + (1 / sim_drive.electric_kwh_per_mi) * gl.get_kwh_per_gge()\n                )\n            mpgge = {\n                # combine ICE and electric PT components for overall mpgge\n                \"mpgge\": mpgge_both,\n                \"grid_mpgge\": mpgge_both * sim_drive.veh.chg_eff,\n                \"mpgde\": mpgge_both / gl.DieselGalPerGasGal,\n                # TODO, have this checked\n                \"kwh_per_mi\": (\n                    sum(sim_drive.fs_kwh_out_ach)\n                    + ((sim_drive.roadway_chg_kj + sim_drive.ess_dischg_kj) / 3.6e3)\n                )\n                / sum(sim_drive.dist_mi),\n            }\n            sim_drives.append(sim_drive)\n\n        mpgges.append(mpgge)\n        weights.append(w)\n\n    if v.veh_pt_type == gl.PHEV:\n        cs_fuel_mpgge_i = np.array([m[\"cs_fuel_mpgge\"] for m in mpgges])\n        cs_fuel_mpgde_i = np.array([m[\"cs_fuel_mpgde\"] for m in mpgges])\n        cs_fuel_kwh__mi_i = np.array([m[\"cs_fuel_kwh__mi\"] for m in mpgges])\n\n        cd_fuel_used_kwh_i = [m[\"cd_fuel_used_kwh\"] for m in mpgges]\n        cd_battery_used_kwh_i = [m[\"cd_elec_used_kwh\"] for m in mpgges]\n        cd_fuel_mpgge_i = np.array([m[\"cd_fuel_mpgge\"] for m in mpgges])\n        cd_fuel_mpgde_i = np.array([m[\"cd_fuel_mpgde\"] for m in mpgges])\n        cd_electric_mpgge_i = np.array([m[\"cd_electric_mpgge\"] for m in mpgges])\n        cd_grid_electric_mpgge_i = np.array(\n            [m[\"cd_grid_electric_mpgge\"] for m in mpgges]\n        )\n        cd_electric_kwh__mi_i = np.array([m[\"cd_electric_kwh__mi\"] for m in mpgges])\n        cd_fuel_kwh__mi_i = np.array([m[\"cd_fuel_kwh__mi\"] for m in mpgges])\n\n        mpgge_comp = {\n            # Charge sustaining\n            \"cs_fuel_mpgge\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cs_fuel_mpgge_i,\n                    out=np.zeros_like(cs_fuel_mpgge_i),\n                    where=cs_fuel_mpgge_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"cs_fuel_mpgde\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cs_fuel_mpgde_i,\n                    out=np.zeros_like(cs_fuel_mpgde_i),\n                    where=cs_fuel_mpgde_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"cs_fuel_kwh__mi\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cs_fuel_kwh__mi_i,\n                    out=np.zeros_like(cs_fuel_kwh__mi_i),\n                    where=cs_fuel_kwh__mi_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            # Charge depleting\n            \"cd_fuel_used_kwh_total\": sum(cd_fuel_used_kwh_i),\n            \"cd_battery_used_kwh\": sum(cd_battery_used_kwh_i),\n            \"cd_fuel_mpgge\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cd_fuel_mpgge_i,\n                    out=np.zeros_like(cd_fuel_mpgge_i),\n                    where=cd_fuel_mpgge_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"cd_fuel_mpgde\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cd_fuel_mpgde_i,\n                    out=np.zeros_like(cd_fuel_mpgde_i),\n                    where=cd_fuel_mpgde_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"cd_electric_mpgge\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cd_electric_mpgge_i,\n                    out=np.zeros_like(cd_electric_mpgge_i),\n                    where=cd_electric_mpgge_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"cd_grid_electric_mpgge\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cd_grid_electric_mpgge_i,\n                    out=np.zeros_like(cd_grid_electric_mpgge_i),\n                    where=cd_grid_electric_mpgge_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"cd_electric_kwh__mi\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cd_electric_kwh__mi_i,\n                    out=np.zeros_like(cd_electric_kwh__mi_i),\n                    where=cd_electric_kwh__mi_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"cd_fuel_kwh__mi\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    cd_fuel_kwh__mi_i,\n                    out=np.zeros_like(cd_fuel_kwh__mi_i),\n                    where=cd_fuel_kwh__mi_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n        }\n        # also report: AveCombinedkWhperMile = UF*(CDelectricityKWhperMile + CDfuelKWhpermile) + (1-UF)*CSfuelKWhperMile\n        uf = run_scenario.get_phev_util_factor(scenario, v, mpgge)\n        mpgge_comp[\"ave_combined_kwh__mile\"] = (\n            uf * (mpgge_comp[\"cd_electric_kwh__mi\"] + mpgge_comp[\"cd_fuel_kwh__mi\"])\n            + (1 - uf) * mpgge_comp[\"cs_fuel_kwh__mi\"]\n        )\n    else:\n        mpgge_i = np.array([m[\"mpgge\"] for m in mpgges])\n        grid_mpgge_i = np.array([m[\"grid_mpgge\"] for m in mpgges])\n        mpgde_i = np.array([m[\"mpgde\"] for m in mpgges])\n        kwh_per_m_i = np.array([m[\"kwh_per_mi\"] for m in mpgges])\n        mpgge_comp = {\n            \"mpgge\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    mpgge_i,\n                    out=np.zeros_like(mpgge_i),\n                    where=mpgge_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"grid_mpgge\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    grid_mpgge_i,\n                    out=np.zeros_like(grid_mpgge_i),\n                    where=grid_mpgge_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            \"mpgde\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    mpgde_i,\n                    out=np.zeros_like(mpgde_i),\n                    where=mpgde_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n            # energy consumption kWh/mi is wt-averaged normally (doesn't require inverting / harmonic averaging)\n            \"kwh_per_mi\": np.sum(weights)\n            / np.sum(\n                np.divide(\n                    weights,\n                    kwh_per_m_i,\n                    out=np.zeros_like(kwh_per_m_i),\n                    where=kwh_per_m_i != 0,\n                    casting=\"unsafe\",\n                )\n            ),\n        }\n\n    if diagnostic:\n        return mpgge_comp, sim_drives, mpgges\n    return mpgge_comp, sim_drives\n</code></pre>"},{"location":"fueleconomy/#t3co.objectives.fueleconomy.get_range_mi","title":"<code>get_range_mi(mpgge_info: dict, vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario) -&gt; dict</code>","text":"<p>This funcion computes range [miles] from mpgge using vehicle powertrain type and energy (or fuel) store size.</p> <p>Considerations: - at some point each vehicle powertrain type could employ the concept of a \"first fuel\" or \"primary fuel\" - so return a primary fuel-based range for all powertrains. - PHEVs have two fuels (generally diesel and electricity). So return two ranges: -- One for determining range during optimization     i.e. the CD range that PHEVs are commonly specified with     (e.g. PHEV-50 = PHEV with 50 mi AER \"All-Electric Range\" ~= CD range) -- One that represents the \"true\" total PHEV range (CD + CS using both ESS and FS)</p> <p>Parameters:</p> Name Type Description Default <code>mpgge_info</code> <code>dict</code> <p>Dictionary containing MPGGE breakdown</p> required <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <p>Returns:</p> Name Type Description <code>range_dict</code> <code>dict</code> <p>Dictionary containing different range results</p> Source code in <code>t3co/objectives/fueleconomy.py</code> Python<pre><code>def get_range_mi(\n    mpgge_info: dict, vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n) -&gt; dict:\n    \"\"\"\n    This funcion computes range [miles] from mpgge using vehicle powertrain type and energy (or fuel) store size.\n\n    Considerations:\n    - at some point each vehicle powertrain type could employ the concept\n    of a \"first fuel\" or \"primary fuel\" - so return a primary fuel-based range for all\n    powertrains.\n    - PHEVs have two fuels (generally diesel and electricity). So return two ranges:\n    -- One for determining range during optimization\n        i.e. the CD range that PHEVs are commonly specified with\n        (e.g. PHEV-50 = PHEV with 50 mi AER \"All-Electric Range\" ~= CD range)\n    -- One that represents the \"true\" total PHEV range (CD + CS using both ESS and FS)\n\n    Args:\n        mpgge_info (dict): Dictionary containing MPGGE breakdown\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n\n    Returns:\n        range_dict (dict): Dictionary containing different range results\n    \"\"\"\n    range_dict = {}\n    kwh_per_gge = gl.get_kwh_per_gge()\n    if vehicle.veh_pt_type == gl.BEV:\n        assert (\n            vehicle.fs_kwh == 0 and vehicle.fc_max_kw == 0\n        ), \"Error! BEV vehicle has non-zero ICE attributes - vehicle mass calculation may be off\"\n        mpgge = mpgge_info[\"mpgge\"]  # use fuel efficiency from battery\n        range_mi = (\n            vehicle.ess_max_kwh\n            * (vehicle.max_soc - vehicle.min_soc)\n            * mpgge\n            / kwh_per_gge\n        )\n        range_dict[\"primary_fuel_range_mi\"] = range_mi\n    elif vehicle.veh_pt_type == gl.CONV:\n        assert (\n            vehicle.ess_max_kwh == 0 and vehicle.mc_max_kw == 0\n        ), \"Error! CONV vehicle has non-zero BEV attributes - vehicle mass calculation may be off\"\n        mpgge = mpgge_info[\"mpgge\"]\n        range_mi = (vehicle.fs_kwh / kwh_per_gge) * mpgge\n        range_dict[\"primary_fuel_range_mi\"] = range_mi\n    elif vehicle.veh_pt_type == gl.HEV:\n        mpgge = mpgge_info[\"mpgge\"]\n        elec_range_mi = (\n            vehicle.ess_max_kwh\n            * (vehicle.max_soc - vehicle.min_soc)\n            * mpgge\n            / kwh_per_gge\n        )\n        conv_range_mi = (vehicle.fs_kwh / kwh_per_gge) * mpgge\n        range_mi = elec_range_mi + conv_range_mi\n        range_dict[\"primary_fuel_range_mi\"] = range_mi\n    elif vehicle.veh_pt_type == gl.PHEV:\n        # https://github.nrel.gov/AVCI/FASTSim_TCO_Truck/issues/24#issuecomment-39958\n        # charge depleting range [miles]\n        # CDrangeMiles = MIN( ESSmaxKWh*(CDmaxSOC- CDminSOC)/ CDelectricityKWhperMile , maxFuelStorKWh/33.7/ CDfuelGGEperMile )\n        cd_range_mi = min(\n            vehicle.ess_max_kwh\n            * (vehicle.max_soc - vehicle.min_soc)\n            / mpgge_info[\"cd_electric_kwh__mi\"],\n            vehicle.fs_kwh / kwh_per_gge * mpgge_info[\"cd_fuel_mpgge\"],\n        )\n        # charge sustaining range [miles]\n        # note, CS range in this way of thinking, is essentially what range is *left over* after you've exhausted the battery to min SOC\n        # and switch into CS mode from CD mode, thus we subtract cd_gge_used from the GGE fuel stores of the vehicle\n        cd_gge_used = cd_range_mi / mpgge_info[\"cd_fuel_mpgge\"]\n        gge_capacity = vehicle.fs_kwh / kwh_per_gge\n        cs_range_mi = (gge_capacity - cd_gge_used) * mpgge_info[\"cs_fuel_mpgge\"]\n        true_range_mi = cd_range_mi + cs_range_mi\n        range_dict = {\n            \"cd_aer_phev_range_mi\": cd_range_mi,\n            \"cs_phev_range_mi\": cs_range_mi,\n            \"true_phev_range_mi\": true_range_mi,\n            \"primary_fuel_range_mi\": cd_range_mi,\n        }\n    # if sim_drive:\n    #     range_dict[\"cycle_distance_mi\"] = sum(sim_drive.cyc.mps * np.diff(sim_drive.cyc.time_s)[0]) * gl.m_to_mi\n    #     range_dict[\"mean_cyc_speed_mph\"] = sum(sim_drive.cyc.mps)/max(sim_drive.cyc.time_s) * gl.mps_to_mph\n    # elif range_cyc:\n    #     range_dict[\"cycle_distance_mi\"] = sum(range_cyc.mps * np.diff(range_cyc.time_s)[0]) * gl.m_to_mi\n    #     range_dict[\"mean_cyc_speed_mph\"] = sum(range_cyc.mps)/max(range_cyc.time_s) * gl.mps_to_mph\n    return range_dict\n</code></pre>"},{"location":"fueleconomy/#t3co.objectives.fueleconomy.get_sim_drive","title":"<code>get_sim_drive(erc, v, scenario)</code>","text":"<p>This helper method returns a FASTSim SimDrive object using the vehicle, drive cycle and scenario</p> <p>Parameters:</p> Name Type Description Default <code>erc</code> <code>fastsim.cycle.Cycle| List[Tuple[fastsim.cycle.Cycle, float</code> <p>FASTSim range cycle object or list of tuples of cycles</p> required <code>v</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for current selection</p> required <p>Returns:</p> Name Type Description <code>sim_drive</code> <code>fastsim.simdrive.SimDrive</code> <p>FASTSim SimDrive object</p> Source code in <code>t3co/objectives/fueleconomy.py</code> Python<pre><code>def get_sim_drive(erc, v, scenario):\n    \"\"\"\n    This helper method returns a FASTSim SimDrive object using the vehicle, drive cycle and scenario\n\n    Args:\n        erc (fastsim.cycle.Cycle| List[Tuple[fastsim.cycle.Cycle, float): FASTSim range cycle object or list of tuples of cycles\n        v (fastsim.vehicle.Vehicle): FASTSim vehicle object for analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object for current selection\n\n    Returns:\n        sim_drive (fastsim.simdrive.SimDrive): FASTSim SimDrive object\n    \"\"\"\n    sim_drive = fastsim.simdrive.SimDrive(erc, v)\n    sim_drive = sim_drive.to_rust()\n\n    sim_params = sim_drive.sim_params\n    sim_params.reset_orphaned()\n    # sim_params.verbose = False\n    if scenario.missed_trace_correction:\n        sim_params.missed_trace_correction = True\n        sim_params.max_time_dilation = scenario.max_time_dilation\n        sim_params.min_time_dilation = scenario.min_time_dilation\n        sim_params.time_dilation_tol = scenario.time_dilation_tol\n    sim_drive.sim_params = sim_params\n\n    props = sim_drive.props\n    props.reset_orphaned()  # see if this is needed\n    props.kwh_per_gge = gl.get_kwh_per_gge()\n    sim_drive.props = props\n\n    return sim_drive\n</code></pre>"},{"location":"generatedocs/","title":"Generate Documentation","text":""},{"location":"generatedocs/#generate-md-documentation-from-docstrings-for-developers","title":"Generate MD Documentation from Docstrings (For Developers)","text":"<p>On Windows</p> Bash<pre><code>pip install --user pipx\npipx ensurepath\n</code></pre> <p>On Mac Bash<pre><code>brew install pipx\npipx ensurepath\n</code></pre></p> <p>Then from T3CO root directory Bash<pre><code>pipx install pydoc-markdown\npydoc-markdown -I . -p t3co --render-toc &gt; docs/functions/CodeReference.md\n</code></pre> for specific modules, specify the module name after <code>-m</code>: <code>pydoc-markdown -I . -m t3co/sweep --render-toc &gt; docs/functions/sweep.md</code></p> <p>This generates CodeReference.md including a Table of Contents from all python docstrings in the T3CO package</p>"},{"location":"generatedocs/#generate-mkdocs-server-for-documentation-website-for-developers","title":"Generate MKDocs server for documentation website  (For Developers)","text":"<p>Use the <code>mkdocs.yml</code> file to configure the documentation website on localhost. <code>mkdocs</code> and <code>mkdocstrings</code> should get installed along with other dependencies when running <code>pip install -e .</code> from the root directory. In case it throws an error, these packages can be installed separately: Bash<pre><code>pip install mkdocs mkdocstrings-python\n</code></pre> On Mac</p> <p>List the processes using the 8000 port on localhost using the command: Bash<pre><code>lsof -i tcp:8000\n</code></pre> if a PID number shows up in the list for a process called <code>Python</code>, clear the port by killing it by replacing  in the following command:  Bash<pre><code>kill -9 &lt;PID&gt;\n</code></pre> Once the port is cleared, run the following line from the T3CO root directory to generate an MKDocs interactive documentation website on your localhost Bash<pre><code>mkdocs serve\n</code></pre>"},{"location":"generateinputs/","title":"Generate Inputs Sub-Module","text":""},{"location":"generateinputs/#t3co.run.generateinputs","title":"<code>t3co.run.generateinputs</code>","text":""},{"location":"generateinputs/#t3co.run.generateinputs.generate","title":"<code>generate(vocation: str, dst: str = gl.OPTIMIZATION_AND_TCO_RCRS)</code>","text":"<p>This function aggregates specifications from users for powertrains, desired ranges, component costs etc. into two csv files - FASTSimInputs and OtherInputs</p> <p>Parameters:</p> Name Type Description Default <code>vocation</code> <code>str</code> <p>Vocation type description</p> required <code>dst</code> <code>str</code> <p>results directory file path. Defaults to gl.OPTIMIZATION_AND_TCO_RCRS.</p> <code>gl.OPTIMIZATION_AND_TCO_RCRS</code> Source code in <code>t3co/run/generateinputs.py</code> Python<pre><code>def generate(vocation: str, dst: str = gl.OPTIMIZATION_AND_TCO_RCRS):\n    \"\"\"\n    This function aggregates specifications from users for powertrains, desired ranges, component costs etc. into two\n    csv files - FASTSimInputs and OtherInputs\n\n    Args:\n        vocation (str): Vocation type description\n        dst (str, optional): results directory file path. Defaults to gl.OPTIMIZATION_AND_TCO_RCRS.\n    \"\"\"\n\n    print(\"generating inputs\")\n\n    vehiclesdir = \"vehicles\"\n    srcdir = \"resources\"\n\n    BaselineVehicle_path = (\n        Path(__file__).parent\n        / srcdir\n        / vehiclesdir\n        / vocation\n        / \"specifications/BaselineVehicle.csv\"\n    )\n    OptimizerInitializationValues_path = (\n        Path(__file__).parent\n        / srcdir\n        / vehiclesdir\n        / vocation\n        / \"specifications/OptimizerInitializationValues.csv\"\n    )\n    PowertrainTechTargets_path = (\n        Path(__file__).parent\n        / srcdir\n        / vehiclesdir\n        / vocation\n        / \"specifications/PowertrainTechTargets.csv\"\n    )\n    VocationRequirements_path = (\n        Path(__file__).parent\n        / srcdir\n        / vehiclesdir\n        / vocation\n        / \"specifications/VocationRequirements.csv\"\n    )\n    FastsimHeader_path = (\n        Path(__file__).parent / \"resources\" / \"auxiliary\" / \"FASTSimInputsHeader.csv\"\n    )\n    Other_Inputs_Header_path = (\n        Path(__file__).parent / \"resources\" / \"auxiliary\" / \"OtherInputsHeader.csv\"\n    )\n\n    BaselineVehicleSpec = pd.read_csv(BaselineVehicle_path)\n    OptimizerInitializationValues = pd.read_csv(OptimizerInitializationValues_path)\n    PowertrainTechTargets = pd.read_csv(PowertrainTechTargets_path)\n    VocationRequirements = pd.read_csv(VocationRequirements_path)\n\n    TechYears = BaselineVehicleSpec.loc[:, \"Year\"].values\n    Nyears = len(TechYears)\n\n    Ranges = np.array(ast.literal_eval(VocationRequirements.at[1, \"MinRangeMiles\"]))\n    Nranges = len(Ranges)\n    Npowertrains = max(PowertrainTechTargets[\"PowertrainNumber\"].values)\n\n    FASTSimInputsDf = pd.read_csv(FastsimHeader_path)\n    OtherInputsDf = pd.read_csv(Other_Inputs_Header_path)\n\n    OtherInputsDf[\"vmt\"] = OtherInputsDf.vmt.astype(str)\n\n    v = 0\n    for pt in range(0, Npowertrains):\n        for y in range(0, Nyears):\n            for r in range(0, Nranges):\n                # FASTSimInputsDf.at[v, \"scenario_name\"] = f\"{v/3} {v}\"\n                FASTSimInputsDf.at[v, \"selection\"] = v + 1\n                FASTSimInputsDf.at[v, \"scenario_name\"] = (\n                    f\"{PowertrainTechTargets[PowertrainTechTargets.PowertrainNumber &gt; pt].iloc[0]['PowertrainName']} \"\n                    f\"{BaselineVehicleSpec.at[y, 'Year']} tech, \"\n                    f\" {Ranges[r]} mi range\"\n                )\n                FASTSimInputsDf.at[v, \"veh_pt_type\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"veh_pt_type\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"drag_coef\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"drag_coef\",\n                ]\n                FASTSimInputsDf.at[v, \"frontalAreaM2\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"frontalAreaM2\",\n                ]\n                FASTSimInputsDf.at[v, \"glider_kg\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"glider_kg\",\n                ]\n                FASTSimInputsDf.at[v, \"vehCgM\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"vehCgM\",\n                ]\n                FASTSimInputsDf.at[v, \"driveAxleWeightFrac\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"driveAxleWeightFrac\",\n                ]\n                FASTSimInputsDf.at[v, \"wheelBaseM\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"wheelBaseM\",\n                ]\n                FASTSimInputsDf.at[v, \"cargo_kg\"] = VocationRequirements.loc[\n                    y, \"cargo_kg\"\n                ]\n                FASTSimInputsDf.at[v, \"vehOverrideKg\"] = 0\n                FASTSimInputsDf.at[v, \"fs_max_kw\"] = OptimizerInitializationValues.loc[\n                    (OptimizerInitializationValues[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        OptimizerInitializationValues[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fs_max_kw\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"fuelStorSecsToPeakPwr\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"fuelStorSecsToPeakPwr\",\n                    ].values[0]\n                )\n                FASTSimInputsDf.at[v, \"fs_kwh\"] = OptimizerInitializationValues.loc[\n                    (OptimizerInitializationValues[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        OptimizerInitializationValues[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fs_kwh\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"fs_kwhPerKg\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fs_kwhPerKg\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"fc_max_kw\"] = OptimizerInitializationValues.loc[\n                    (OptimizerInitializationValues[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        OptimizerInitializationValues[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fc_max_kw\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"fc_eff_type\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fc_eff_type\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"fcAbsEffImpr\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fcAbsEffImpr\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"fuelConvSecsToPeakPwr\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"fuelConvSecsToPeakPwr\",\n                    ].values[0]\n                )\n                FASTSimInputsDf.at[v, \"fuelConvBaseKg\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fuelConvBaseKg\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"fuelConvKwPerKg\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fuelConvKwPerKg\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"mc_max_kw\"] = OptimizerInitializationValues.loc[\n                    (OptimizerInitializationValues[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        OptimizerInitializationValues[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"mc_max_kw\",\n                ].values[0]\n                # FASTSimInputsDf.at[v, \"motorPeakEff\"] =                 PowertrainTechTargets.loc[(PowertrainTechTargets['PowertrainNumber'] == (pt+1)) &amp; (PowertrainTechTargets['Year'] == BaselineVehicleSpec.at[y, 'Year']), 'motorPeakEff'].values[0]\n                FASTSimInputsDf.at[v, \"motorSecsToPeakPwr\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"motorSecsToPeakPwr\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"mcPeKgPerKw\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"mcPeKgPerKw\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"mcPeBaseKg\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"mcPeBaseKg\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"ess_max_kw\"] = OptimizerInitializationValues.loc[\n                    (OptimizerInitializationValues[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        OptimizerInitializationValues[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"ess_max_kw\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"ess_max_kwh\"] = (\n                    OptimizerInitializationValues.loc[\n                        (OptimizerInitializationValues[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            OptimizerInitializationValues[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"ess_max_kwh\",\n                    ].values[0]\n                )\n                FASTSimInputsDf.at[v, \"essKgPerKwh\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"essKgPerKwh\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"essBaseKg\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"essBaseKg\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"essRoundTripEff\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"essRoundTripEff\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"essLifeCoefA\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"essLifeCoefA\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"essLifeCoefB\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"essLifeCoefB\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"wheelInertiaKgM2\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"wheelInertiaKgM2\",\n                ]\n                FASTSimInputsDf.at[v, \"numWheels\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"numWheels\",\n                ]\n                FASTSimInputsDf.at[v, \"wheelRrCoef\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"wheelRrCoef\",\n                ]\n                FASTSimInputsDf.at[v, \"wheelRadiusM\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"wheelRadiusM\",\n                ]\n                FASTSimInputsDf.at[v, \"wheelCoefOfFric\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"wheelCoefOfFric\",\n                ]\n                FASTSimInputsDf.at[v, \"min_soc\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"min_soc\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"max_soc\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"max_soc\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"essDischgToFcMaxEffPerc\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"essDischgToFcMaxEffPerc\",\n                    ].values[0]\n                )\n                FASTSimInputsDf.at[v, \"essChgToFcMaxEffPerc\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"essChgToFcMaxEffPerc\",\n                    ].values[0]\n                )\n                FASTSimInputsDf.at[v, \"maxAccelBufferMph\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"maxAccelBufferMph\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"maxAccelBufferPercOfUseableSoc\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"maxAccelBufferPercOfUseableSoc\",\n                    ].values[0]\n                )\n                FASTSimInputsDf.at[v, \"percHighAccBuf\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"percHighAccBuf\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"mphFcOn\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"mphFcOn\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"kwDemandFcOn\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"kwDemandFcOn\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"altEff\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"altEff\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"chgEff\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"chgEff\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"auxKw\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"auxKw\",\n                ]\n                FASTSimInputsDf.at[v, \"forceAuxOnFC\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"forceAuxOnFC\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"transKg\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"transKg\",\n                ]\n                FASTSimInputsDf.at[v, \"transEff\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"transEff\",\n                ]\n                FASTSimInputsDf.at[v, \"comp_mass_multiplier\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"comp_mass_multiplier\",\n                ]\n                FASTSimInputsDf.at[v, \"essToFuelOkError\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"essToFuelOkError\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"maxRegen\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"maxRegen\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"minFcTimeOn\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"minFcTimeOn\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"idleFcKw\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"idleFcKw\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"fc_eff_map\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"engineMap\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"mcPwrOutPerc\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"mcPwrOutPerc\",\n                ].values[0]\n                FASTSimInputsDf.at[v, \"largeBaselineEff\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"largeBaselineEff\",\n                ].values[0]  # I'm not sure what this is\n                FASTSimInputsDf.at[v, \"smallBaselineEff\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"smallBaselineEff\",\n                ].values[0]  # I'm not sure what this is\n                FASTSimInputsDf.at[v, \"modernMax\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"modernMax\",\n                ].values[0]  # I'm not sure what this is\n                FASTSimInputsDf.at[v, \"stopStart\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"stopStart\",\n                ].values[0]  # I'm not sure what this is\n\n                FASTSimInputsDf.at[v, \"valUddsMpgge\"] = 0\n                FASTSimInputsDf.at[v, \"valHwyMpgge\"] = 0\n                FASTSimInputsDf.at[v, \"valCombMpgge\"] = 0\n                FASTSimInputsDf.at[v, \"valUddsKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"valHwyKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"valCombKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"valCdRangeMi\"] = 0\n                FASTSimInputsDf.at[v, \"valConst65MphKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"valConst60MphKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"valConst55MphKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"valConst45MphKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"valUnadjUddsKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"valUnadjHwyKwhPerMile\"] = 0\n                FASTSimInputsDf.at[v, \"val0To60Mph\"] = 0\n                FASTSimInputsDf.at[v, \"valEssLifeMiles\"] = 0\n                FASTSimInputsDf.at[v, \"valRangeMiles\"] = 0\n                FASTSimInputsDf.at[v, \"valVehBaseCost\"] = 0\n                FASTSimInputsDf.at[v, \"valMsrp\"] = 0\n\n                # Values to send to OtherInputs file\n\n                OtherInputsDf.at[v, \"selection\"] = v + 1\n                OtherInputsDf.at[v, \"vmt\"] = VocationRequirements.loc[\n                    VocationRequirements[\"Year\"] == VocationRequirements.at[y, \"Year\"],\n                    \"vmt\",\n                ].values[0]\n                OtherInputsDf.at[v, \"drive_cycle\"] = VocationRequirements.loc[\n                    VocationRequirements[\"Year\"] == VocationRequirements.at[y, \"Year\"],\n                    \"rangeDriveCycleFilePath\",\n                ].values[0]\n                OtherInputsDf.at[v, \"segment_name\"] = VocationRequirements.loc[\n                    VocationRequirements[\"Year\"] == VocationRequirements.at[y, \"Year\"],\n                    \"segment_name\",\n                ].values[0]\n                OtherInputsDf.at[v, \"gvwr_kg\"] = VocationRequirements.loc[\n                    VocationRequirements[\"Year\"] == VocationRequirements.at[y, \"Year\"],\n                    \"gvwr_kg\",\n                ].values[0]\n                OtherInputsDf.at[v, \"gvwr_credit_kg\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"gvwr_credit_kg\",\n                ].values[0]\n                OtherInputsDf.at[v, \"fuel_type\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fuel_type\",\n                ].values[0]\n                OtherInputsDf.at[v, \"maint_oper_cost_dol_per_mi\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"maint_oper_cost_dol_per_mi\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"constant_trip_distance_mi\"] = (\n                    VocationRequirements.loc[\n                        VocationRequirements[\"Year\"]\n                        == VocationRequirements.at[y, \"Year\"],\n                        \"constant_trip_distance_mi\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"vehicle_life_yr\"] = VocationRequirements.loc[\n                    VocationRequirements[\"Year\"] == VocationRequirements.at[y, \"Year\"],\n                    \"vehicle_life_yr\",\n                ].values[0]\n                OtherInputsDf.at[v, \"desired_ess_replacements\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"desired_ess_replacements\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"discount_rate_pct_per_yr\"] = (\n                    VocationRequirements.loc[\n                        VocationRequirements[\"Year\"]\n                        == VocationRequirements.at[y, \"Year\"],\n                        \"discount_rate_pct_per_yr\",\n                    ]\n                )\n                OtherInputsDf.at[v, \"ess_cost_dol_per_kw\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"ess_cost_dol_per_kw\",\n                ].values[0]\n                OtherInputsDf.at[v, \"ess_cost_dol_per_kwh\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"ess_cost_dol_per_kwh\",\n                ].values[0]\n                OtherInputsDf.at[v, \"ess_base_cost_dol\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"ess_base_cost_dol\",\n                ].values[0]\n                OtherInputsDf.at[v, \"ess_cost_reduction_dol_per_yr\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"ess_cost_reduction_dol_per_yr\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"ess_salvage_value_dol\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"ess_salvage_value_dol\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"pe_mc_cost_dol_per_kw\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"pe_mc_cost_dol_per_kw\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"pe_mc_base_cost_dol\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"pe_mc_base_cost_dol\",\n                ].values[0]\n                OtherInputsDf.at[v, \"fc_ice_cost_dol_per_kw\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"fc_ice_cost_dol_per_kw\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"fc_ice_base_cost_dol\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fc_ice_base_cost_dol\",\n                ].values[0]\n                OtherInputsDf.at[v, \"fc_fuelcell_cost_dol_per_kw\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"fc_fuelcell_cost_dol_per_kw\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"fs_cost_dol_per_kwh\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"fs_cost_dol_per_kwh\",\n                ].values[0]\n                OtherInputsDf.at[v, \"fs_h2_cost_dol_per_kwh\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"fs_h2_cost_dol_per_kwh\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"plug_base_cost_dol\"] = PowertrainTechTargets.loc[\n                    (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                    &amp; (\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"]\n                    ),\n                    \"plug_base_cost_dol\",\n                ].values[0]\n                OtherInputsDf.at[v, \"markup_pct\"] = BaselineVehicleSpec.loc[\n                    PowertrainTechTargets[\"Year\"] == BaselineVehicleSpec.at[y, \"Year\"],\n                    \"markup_pct\",\n                ]\n                OtherInputsDf.at[v, \"fc_cng_ice_cost_dol_per_kw\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"fc_cng_ice_cost_dol_per_kw\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"fs_cng_cost_dol_per_kwh\"] = (\n                    PowertrainTechTargets.loc[\n                        (PowertrainTechTargets[\"PowertrainNumber\"] == (pt + 1))\n                        &amp; (\n                            PowertrainTechTargets[\"Year\"]\n                            == BaselineVehicleSpec.at[y, \"Year\"]\n                        ),\n                        \"fs_cng_cost_dol_per_kwh\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"vehicle_glider_cost_dol\"] = (\n                    BaselineVehicleSpec.loc[\n                        PowertrainTechTargets[\"Year\"]\n                        == BaselineVehicleSpec.at[y, \"Year\"],\n                        \"vehicle_glider_cost_dol\",\n                    ]\n                )\n                OtherInputsDf.at[v, \"tax_rate_pct\"] = VocationRequirements.loc[\n                    VocationRequirements[\"Year\"] == VocationRequirements.at[y, \"Year\"],\n                    \"tax_rate_pct\",\n                ]\n                OtherInputsDf.at[v, \"vocation\"] = VocationRequirements.loc[\n                    VocationRequirements[\"Year\"] == VocationRequirements.at[y, \"Year\"],\n                    \"vocation\",\n                ].values[0]\n                OtherInputsDf.at[v, \"model_year\"] = BaselineVehicleSpec.at[y, \"Year\"]\n                OtherInputsDf.at[v, \"region\"] = VocationRequirements.loc[\n                    VocationRequirements[\"Year\"] == VocationRequirements.at[y, \"Year\"],\n                    \"region\",\n                ].values[0]\n                OtherInputsDf.at[v, \"target_range_mi\"] = Ranges[r]\n                OtherInputsDf.at[v, \"min_speed_at_6pct_grade_in_5min_mph\"] = (\n                    VocationRequirements.loc[\n                        VocationRequirements[\"Year\"]\n                        == VocationRequirements.at[y, \"Year\"],\n                        \"min_speed_at_6pct_grade_in_5min_mph\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"min_speed_at_1p25pct_grade_in_5min_mph\"] = (\n                    VocationRequirements.loc[\n                        VocationRequirements[\"Year\"]\n                        == VocationRequirements.at[y, \"Year\"],\n                        \"min_speed_at_1p25pct_grade_in_5min_mph\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"max_time_0_to_60mph_at_gvwr_s\"] = (\n                    VocationRequirements.loc[\n                        VocationRequirements[\"Year\"]\n                        == VocationRequirements.at[y, \"Year\"],\n                        \"max_time_0_to_60mph_at_gvwr_s\",\n                    ].values[0]\n                )\n                OtherInputsDf.at[v, \"max_time_0_to_30mph_at_gvwr_s\"] = (\n                    VocationRequirements.loc[\n                        VocationRequirements[\"Year\"]\n                        == VocationRequirements.at[y, \"Year\"],\n                        \"max_time_0_to_30mph_at_gvwr_s\",\n                    ].values[0]\n                )\n                # OtherInputsDf.at[v, \"Powertrain\"] =                  PowertrainTechTargets.loc[(PowertrainTechTargets['PowertrainNumber'] == (pt+1)) &amp; (PowertrainTechTargets['Year'] == BaselineVehicleSpec.at[y, 'Year']), 'PowertrainName'].values[0]\n\n                v += 1\n\n    FASTSimInputsDf.set_index(\n        pd.Series(range(1, len(FASTSimInputsDf) + 1)), inplace=True\n    )\n    FASTSimInputsDf.to_csv(\n        dst / gl.FASTSIM_INPUTS_FILE, index=False\n    )  # ####Make this into a results folder\n\n    OtherInputsDf.set_index(pd.Series(range(1, len(OtherInputsDf) + 1)), inplace=True)\n    OtherInputsDf.to_csv(\n        dst / gl.OTHER_INPUTS_FILE, index=False\n    )  # ####Make this into a results folder\n</code></pre>"},{"location":"gradeability/","title":"Gradeability Test Sub-Module","text":""},{"location":"gradeability/#t3co.objectives.gradeability","title":"<code>t3co.objectives.gradeability</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.PHEV","title":"<code>PHEV = 365</code>  <code>module-attribute</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.analysis_vehicle","title":"<code>analysis_vehicle = run_scenario.get_vehicle(PHEV, vehicle_input_path)</code>  <code>module-attribute</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.g6mphachs","title":"<code>g6mphachs = []</code>  <code>module-attribute</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.init_socs","title":"<code>init_socs = [i for i in np.linspace(v.min_soc, v.max_soc, 10)]</code>  <code>module-attribute</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.scenario_inputs_path","title":"<code>scenario_inputs_path = Path(gl.T3CO_INPUTS_DIR / 'phev-testing/TDA_FY22_scenario_assumptions.csv').resolve()</code>  <code>module-attribute</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.soc_used","title":"<code>soc_used = []</code>  <code>module-attribute</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.v","title":"<code>v = analysis_vehicle</code>  <code>module-attribute</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.vehicle_input_path","title":"<code>vehicle_input_path = Path(gl.T3CO_INPUTS_DIR / 'phev-testing/TDA_FY22_vehicle_model_assumptions.csv').resolve()</code>  <code>module-attribute</code>","text":""},{"location":"gradeability/#t3co.objectives.gradeability.get_gradeability","title":"<code>get_gradeability(analysis_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario = None, verbose: bool = False, ess_init_soc: float = None, set_weight_to_max_kg: bool = True) -&gt; Tuple[float, float, fastsim.simdrive.SimDrive, fastsim.simdrive.SimDrive]</code>","text":"<p>This function runs SimDrives to determine the gradeability at given speed and the grade vehicle is evaluated at how much it meets or exceeds target speed at the target grade.</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for current selection. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>if True, prints process steps. Defaults to False.</p> <code>False</code> <code>ess_init_soc</code> <code>float</code> <p>ESS Initial SOC override. Defaults to None.</p> <code>None</code> <code>set_weight_to_max_kg</code> <code>bool</code> <p>if True, run_scenario.set_test_weight() overrides vehice weight to GVWR. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>grade_6percent_mph_ach</code> <code>float</code> <p>Achieved speed on 6% grade test</p> <code>grade_1pt25percent_mph_ach</code> <code>float</code> <p>Achieved speed on 1.25% grade test</p> <code>grade_6_simdrive</code> <code>fastsim.simdrive.SimDrive</code> <p>FASTSim SimDrive for gradeability test of 6% grade</p> <code>grade_1p25_simdrive</code> <code>fastsim.simdrive.SimDrive</code> <p>FASTSim SimDrive for gradeability test of 1.25% grade</p> Source code in <code>t3co/objectives/gradeability.py</code> Python<pre><code>def get_gradeability(\n    analysis_vehicle: fastsim.vehicle.Vehicle,\n    scenario: run_scenario.Scenario = None,\n    verbose: bool = False,\n    ess_init_soc: float = None,\n    set_weight_to_max_kg: bool = True,\n) -&gt; Tuple[float, float, fastsim.simdrive.SimDrive, fastsim.simdrive.SimDrive]:\n    \"\"\"\n    This function runs SimDrives to determine the gradeability at given speed and the grade vehicle is\n    evaluated at how much it meets or exceeds target speed at the target grade.\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object for analysis vehicle\n        scenario (run_scenario.Scenario, optional): Scenario object for current selection. Defaults to None.\n        verbose (bool, optional): if True, prints process steps. Defaults to False.\n        ess_init_soc (float, optional): ESS Initial SOC override. Defaults to None.\n        set_weight_to_max_kg (bool, optional): if True, run_scenario.set_test_weight() overrides vehice weight to GVWR. Defaults to True.\n\n    Returns:\n        grade_6percent_mph_ach (float): Achieved speed on 6% grade test\n        grade_1pt25percent_mph_ach (float): Achieved speed on 1.25% grade test\n        grade_6_simdrive (fastsim.simdrive.SimDrive): FASTSim SimDrive for gradeability test of 6% grade\n        grade_1p25_simdrive (fastsim.simdrive.SimDrive): FASTSim SimDrive for gradeability test of 1.25% grade\n    \"\"\"\n    SIX_GRADE = 0.06\n    ONE_POINT_TWENTY_FIVE_GRADE = 0.0125\n    CYC_SECONDS = 100\n    CYC_MPH = 90\n\n    t0 = time.time()\n\n    if scenario is not None and set_weight_to_max_kg:\n        kg_before = analysis_vehicle.veh_kg\n        run_scenario.set_test_weight(analysis_vehicle, scenario)\n\n    if verbose:\n        print(f\"f'{Path(__file__).name}:: Vehicle load time: {time.time() - t0:.3f} s\")\n    # load the cycles\n\n    def get_grade_perf(target_grade: float) -&gt; Tuple[float, fastsim.simdrive.SimDrive]:\n        \"\"\"\n        This function obtains the maximum speed achieved on gradeability test for target grade\n\n        Args:\n            target_grade (float): Input constant grade for gradeability test\n\n        Returns:\n            target_grade_mph_ach (float): Achieved maximum speed mph on gradeability test\n            grade_simdrive (fastsim.simdrive.SimDrive): FASTSim SimDrive object for constant grade cycle\n        \"\"\"\n        # Test speed achieved at end of 5 minutes at 6% grade (default)\n        first_time_step_mph = 0\n        if scenario is not None:\n            if target_grade == SIX_GRADE:\n                first_time_step_mph = scenario.min_speed_at_6pct_grade_in_5min_mph\n                if verbose:\n                    print(\n                        f\"f'{Path(__file__).name}:: scenario.min_speed_at_6pct_grade_in_5min_mph: {scenario.min_speed_at_6pct_grade_in_5min_mph}\"\n                    )\n            if target_grade == ONE_POINT_TWENTY_FIVE_GRADE:\n                first_time_step_mph = scenario.min_speed_at_1p25pct_grade_in_5min_mph\n                if verbose:\n                    print(\n                        f\"f'{Path(__file__).name}:: scenario.min_speed_at_1p25pct_grade_in_5min_mph: {scenario.min_speed_at_1p25pct_grade_in_5min_mph}\"\n                    )\n        if verbose:\n            print(\n                f\"f'{Path(__file__).name}:: first_time_step_mph: {first_time_step_mph}\"\n            )\n        target_grade_cyc_secs = np.arange(CYC_SECONDS)\n        cyc_dict = {\n            \"cycSecs\": target_grade_cyc_secs,\n            \"cycMps\": np.append(\n                [first_time_step_mph], np.ones(CYC_SECONDS - 1) * CYC_MPH\n            )\n            / params.MPH_PER_MPS,\n            \"cycGrade\": np.ones(CYC_SECONDS) * target_grade,\n        }\n\n        grade_cycle = cycle.Cycle.from_dict(cyc_dict)\n\n        if verbose:\n            print(\n                f\"f'{Path(__file__).name}:: Cycle load time: {time.time() - t0:.3f} s\"\n            )\n\n        grade_simdrive = run_scenario.get_objective_simdrive(\n            analysis_vehicle, grade_cycle\n        )\n\n        run_scenario.run_grade_or_accel(\n            \"grade\", analysis_vehicle, grade_simdrive, ess_init_soc\n        )\n\n        assert (\n            grade_simdrive.trace_miss_dist_frac\n            &lt;= grade_simdrive.sim_params.trace_miss_dist_tol\n        )\n\n        target_grade_mph_ach = grade_simdrive.mph_ach[-1]\n        return target_grade_mph_ach, grade_simdrive\n\n    grade_6percent_mph_ach, grade_6_simdrive = get_grade_perf(SIX_GRADE)\n    grade_1pt25percent_mph_ach, grade_1p25_simdrive = get_grade_perf(\n        ONE_POINT_TWENTY_FIVE_GRADE\n    )\n    if scenario is not None and set_weight_to_max_kg:\n        run_scenario.reset_vehicle_weight(analysis_vehicle)\n        kg_after = analysis_vehicle.veh_kg\n        assert (\n            kg_after == kg_before\n        ), f\"total vehicle kg (veh_kg) kg_after must be equal to kg_before: kg_after/kg_before {round(kg_after,4)}/{round(kg_before, 4)}\"\n\n    return (\n        grade_6percent_mph_ach,\n        grade_1pt25percent_mph_ach,\n        grade_6_simdrive,\n        grade_1p25_simdrive,\n    )\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#setting-up-a-python-environment","title":"Setting Up a Python Environment","text":"<p>T3CO depends on Python&gt;=3.8 and &lt;=3.10. To create an environment containing the appropriate Python version and a built-in <code>pip</code>, there are two preferred ways:</p> <ol> <li> <p>First option is to use conda:</p> Bash<pre><code>conda create -n t3co python=3.10\nconda activate t3co\n</code></pre> </li> <li> <p>The other option is using venv</p> Bash<pre><code>python3.10 -m venv t3co\n</code></pre> <p>On macOS/Linux, activate the environment:</p> Bash<pre><code>source t3co/bin/activate\n</code></pre> <p>On Windows Powershell:</p> Bash<pre><code>t3co\\Scripts\\activate\n</code></pre> </li> </ol>"},{"location":"installation/#installing-t3co-python-package","title":"Installing T3CO Python Package","text":"<p>T3CO is available on PyPI and as a public access GitHub repository. This gives the user two ways of installing the T3CO Python Package.</p>"},{"location":"installation/#1-installing-from-pypi","title":"1. Installing From PyPI","text":"<p>T3CO can be easily installed from PyPI. This is the preferred method for using T3CO to run analysis with input files. To install the latest release: Bash<pre><code>pip install t3co\n</code></pre></p> <p>To install a specific version (for example T3CO v1.0.8): Bash<pre><code>pip install t3co==1.0.8\n</code></pre></p>"},{"location":"installation/#2-from-github","title":"2. From GitHub","text":"<p>T3CO can also be installed directly from the GitHub repository for accessing demo input files and running T3CO using the Command Line Interface.</p> <p>First, clone the repository from GitHub: Bash<pre><code>git clone https://github.com/NREL/T3CO.git T3CO\n</code></pre></p> <p>From within the Python environment Navigate to the parent directory containing the T3CO repository e.g. <code>cd GitHub/T3CO/</code> and run: Bash<pre><code>pip install -e .\n</code></pre> This installs the local version of the T3CO clone along with all its dependencies.</p> <p>FASTSim is installed along with other library dependancies. In case of <code>ModuleNotFoundError: No module named 'fastsim'</code> error: Bash<pre><code>pip install fastsim==2.1.1\n</code></pre></p> <p>Check that the right version of T3CO is installed in your environment: Bash<pre><code>pip show t3co\n</code></pre></p> <p>If there are updates or new releases to T3CO that don't show in the local version, use a <code>git pull</code> command the latest version from the <code>main</code> branch on the repo: Bash<pre><code>git pull origin main\n</code></pre></p>"},{"location":"installation/#copying-t3co-demo-input-files","title":"Copying T3CO Demo Input Files","text":"<p>The <code>t3co.resources</code> folder contains all the necessary input files needed for running T3CO. However, it sometimes is difficult to navigate to these files when installing. To help with this, run this command on the Command Line Interface.</p> Bash<pre><code>install_t3co_demo_inputs\n</code></pre> <p>The user will receive these questions on the command line:</p> <p><code>Do you want to copy the T3CO demo input files? (y/n):</code></p> <p><code>Enter the path where you want to copy demo input files:</code></p> <p>Choose <code>y</code> and provide the desired destination path to get a <code>demo_inputs</code> folder containing the <code>t3co.resources</code> files copied to your local directory. To copy the folder to the current directory you are on, answer the second question with \".\".</p>"},{"location":"installation/#running-your-first-analysis","title":"Running your first analysis","text":"<p>To learn about the tool and run your first T3CO analysis, proceed to the Quick Start Guide</p>"},{"location":"moo/","title":"MOO Sub-Module","text":""},{"location":"moo/#t3co.moopack.moo","title":"<code>t3co.moopack.moo</code>","text":""},{"location":"moo/#t3co.moopack.moo.ACCEL_GRADE_OVERSHOOT","title":"<code>ACCEL_GRADE_OVERSHOOT = 'accel_grade_overshoot_tol_constraint'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.ALGORITHMS","title":"<code>ALGORITHMS = [ALGO_NSGA2, ALGO_NelderMead, ALGO_PatternSearch, ALGO_PSO]</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.ALGO_NSGA2","title":"<code>ALGO_NSGA2 = 'NSGA2'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.ALGO_NelderMead","title":"<code>ALGO_NelderMead = 'NelderMead'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.ALGO_PSO","title":"<code>ALGO_PSO = 'PSO'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.ALGO_PatternSearch","title":"<code>ALGO_PatternSearch = 'PatternSearch'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.CONSTRAINTS","title":"<code>CONSTRAINTS = [RANGE, ACCEL30, ACCEL60, GRADE125, GRADE6, ACCEL_GRADE_OVERSHOOT, TRACE_MISS_DIST_PERCENT, C_RATE, PHEV_MINIMIZE_FUEL_USE_CONSTRAINT]</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.C_RATE","title":"<code>C_RATE = 'c_rate'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.EXCEPTION_THROWN","title":"<code>EXCEPTION_THROWN = 3</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.KNOBS","title":"<code>KNOBS = [KNOB_CDA, KNOB_FCMAXKW, KNOB_ess_max_kwh, KNOB_mc_max_kw, KNOB_FCPEAKEFF, KNOB_WTDELTAPERC, KNOB_fs_kwh]</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.KNOB_CDA","title":"<code>KNOB_CDA = 'CdA_perc_imp'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.KNOB_FCMAXKW","title":"<code>KNOB_FCMAXKW = 'fcMaxOutKw'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.KNOB_FCPEAKEFF","title":"<code>KNOB_FCPEAKEFF = 'fc_peak_eff'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.KNOB_WTDELTAPERC","title":"<code>KNOB_WTDELTAPERC = 'wt_delta_perc'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.KNOB_ess_max_kwh","title":"<code>KNOB_ess_max_kwh = 'ess_max_kwh'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.KNOB_fs_kwh","title":"<code>KNOB_fs_kwh = 'fs_kwh'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.KNOB_mc_max_kw","title":"<code>KNOB_mc_max_kw = 'mc_max_kw'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.OBJECTIVES","title":"<code>OBJECTIVES = [TCO, PHEV_MINIMIZE_FUEL_USE_OBJECTIVE]</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.OPTIMIZATION_FAILED_TO_CONVERGE","title":"<code>OPTIMIZATION_FAILED_TO_CONVERGE = 2</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.OPTIMIZATION_SUCCEEDED","title":"<code>OPTIMIZATION_SUCCEEDED = 1</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.PHEV_MINIMIZE_FUEL_USE_CONSTRAINT","title":"<code>PHEV_MINIMIZE_FUEL_USE_CONSTRAINT = 'PHEV_MINIMIZE_CD_FUEL_USE_PERCENTAGE_CONSTRAINT'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.PHEV_MINIMIZE_FUEL_USE_OBJECTIVE","title":"<code>PHEV_MINIMIZE_FUEL_USE_OBJECTIVE = 'objective_phev_minimize_fuel_use'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.TCO","title":"<code>TCO = 'tot_cost'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.TRACE_MISS_DIST_PERCENT","title":"<code>TRACE_MISS_DIST_PERCENT = 'constraint_trace_miss_dist_percent_on'</code>  <code>module-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3CODisplay","title":"<code>T3CODisplay</code>","text":"<p>               Bases: <code>Output</code></p> <p>This class contains the display object for Pymoo optimization printouts - pymoo.util.display.Display</p> <p>Parameters:</p> Name Type Description Default <code>Output</code> <code>pymoo.util.display.output.Output</code> <p>Pymoo minimize display object</p> required Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>class T3CODisplay(Output):\n    \"\"\"\n    This class contains the display object for Pymoo optimization printouts - pymoo.util.display.Display\n\n    Args:\n        Output (pymoo.util.display.output.Output): Pymoo minimize display object\n    \"\"\"\n\n    def __init__(self, **kwargs) -&gt; None:\n        \"\"\"\n        This constructor initializes the pymoo.util.display.Display object\n        \"\"\"\n        super().__init__(**kwargs)\n        self.term = MultiObjectiveSpaceTermination()\n\n    def _do(self, problem: T3COProblem, evaluator: float, algorithm: str) -&gt; None:\n        \"\"\"\n        This constructor creates the output printouts\n\n        Args:\n            problem (moo.T3COProblem): Pymoo optimization\n            evaluator (float): evaluator\n            algorithm (str): algorithm name\n        \"\"\"\n        super()._do(problem, evaluator, algorithm)\n        if problem.n_constr &gt; 0:\n            max_cv = np.max(algorithm.pop.get(\"G\"))\n            self.output.append(\"CV max\", f\"{max_cv:.3g}\", width=10)\n            # self.output.append(\"CV key\",\n            #     problem.constr_list[np.argmax(algorithm.pop.get('G')) % problem.n_constr] if max_cv &gt; 0 else '-----',\n            #     width=15\n            # )\n        if \"tot_cost\" in problem.obj_list:\n            tco_start_idx = problem.obj_list.index(\"tot_cost\")  # noqa: F841\n            # tco_min_for_pop = min(algorithm.pop.get('F')[tco_start_idx::len(problem.obj_list)])[0]\n            # self.output.append(\"min(TCO)\", f\"{tco_min_for_pop:.5g}\")\n        self.output.append(\"obj max\", f\"{np.max(algorithm.pop.get('F')):.5g}\", width=10)\n        self.output.append(\"n_nds\", len(algorithm.opt), width=7)\n\n        self.term.do_continue(algorithm)\n\n        max_from, eps = \"-\", \"-\"\n        if len(self.term.metrics) &gt; 0:\n            metric = self.term.metrics[-1]\n            tol = self.term.tol\n            delta_ideal, delta_nadir, delta_f = (\n                metric[\"delta_ideal\"],\n                metric[\"delta_nadir\"],\n                metric[\"delta_f\"],\n            )\n            if delta_ideal &gt; tol:\n                max_from = \"ideal\"\n                eps = delta_ideal\n            elif delta_nadir &gt; tol:\n                max_from = \"nadir\"\n                eps = delta_nadir\n            else:\n                max_from = \"f\"\n                eps = delta_f\n\n        self.output.append(\"eps\", eps)\n        self.output.append(\"indicator\", max_from)\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3CODisplay.term","title":"<code>term = MultiObjectiveSpaceTermination()</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3CODisplay.__init__","title":"<code>__init__(**kwargs) -&gt; None</code>","text":"<p>This constructor initializes the pymoo.util.display.Display object</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def __init__(self, **kwargs) -&gt; None:\n    \"\"\"\n    This constructor initializes the pymoo.util.display.Display object\n    \"\"\"\n    super().__init__(**kwargs)\n    self.term = MultiObjectiveSpaceTermination()\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem","title":"<code>T3COProblem</code>","text":"<p>               Bases: <code>ElementwiseProblem</code></p> <p>Class for creating PyMoo problem.</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>class T3COProblem(ElementwiseProblem):\n    \"\"\"\n    Class for creating PyMoo problem.\n    \"\"\"\n\n    moobasevehicle: fastsim.vehicle.Vehicle\n    mooadvancedvehicle: fastsim.vehicle.Vehicle\n    opt_scenario: run_scenario.Scenario\n    designcycle: fastsim.cycle.Cycle\n    config: run_scenario.Config\n    do_input_validation: bool\n\n    def setup_opt_records(self):\n        \"\"\"\n        This method sets up the empty optimization record arrays\n        \"\"\"\n        #\n\n        # objectives\n        self.r_tcos = []\n        self.r_cd_fc_kwh_percent = []\n        self.r_cd_fc_kwh_used = []\n        self.r_cd_elec_kwh_used = []\n\n        self.reporting_vars = None\n        self.r_grade_6s = []\n        self.r_grade_1p25s = []\n        self.r_accel_30l = []\n        self.r_accel_60l = []\n        self.r_ranges = []\n        self.r_fuel_efficiencies = []\n        self.r_wt_delta_perc_guess = []\n        self.r_CdA_reduction_perc = []\n        self.r_fc_peak_eff_guess = []\n        self.r_fc_max_out_kw_guess = []\n        self.r_fs_kwh_guess = []\n        self.r_max_ess_kwh_guess = []\n        self.r_max_motor_kw_guess = []\n        # constraint records\n        self.accel_30_constraint = []\n        self.accel_60_constraint = []\n        self.grade_6_constraint = []\n        self.grade_1p25_constraint = []\n        self.range_constraint = []\n        self.grade_accel_overshoot_tol_constraint = []\n        self.c_rate_constraint = []\n        self.trace_miss_distance_percent_constraint_record = []\n        self.phev_min_fuel_use_prcnt_const_record = []\n\n    def __init__(\n        self,\n        knobs_bounds: dict,\n        vnum: float,\n        optimize_pt: str,\n        obj_list: list = None,\n        constr_list: list = None,\n        verbose: bool = False,\n        config: run_scenario.Config = None,\n        do_input_validation: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"\n        This constructor initializes optimization input variables\n\n        Args:\n            knobs_bounds (dict): Dictionary containing knobs bounds for optimization\n            vnum (float): Vehicle selection number\n            optimize_pt (str, optional): Vehicle powertrain type - Conv, BEV, HEV, PHEV. Defaults to gl.BEV.\n            obj_list (list, optional): List of objectives. Defaults to None.\n            constr_list (list, optional): List of constraints. Defaults to None.\n            verbose (bool, optional): if True, prints process steps. Defaults to False.\n            config (run_scenario.Config, optional): T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.\n\n        \"\"\"\n        self.setup_opt_records()\n\n        # TODO there should probably not be any default values for kwargs\n\n        # TODO: figure out parallelization and then modify the following line accordingly\n        _ = kwargs.pop(\"parallelization\", None)\n\n        # possible TODO: make this a dict for grade, accel, and range tolerance\n        self.range_overshoot_tol = kwargs.pop(\"range_overshoot_tol\", None)\n        self.grade_accel_overshoot_tol = kwargs.pop(\n            \"grade_accel_overshoot_tol\", 0.01\n        )  # TODO default of 1% # user should explicitly turn this on and set this outside moo.py\n\n        # MOO optimization interpolation arrays and coefficients\n        # engine peak efficiecy percents\n        self.fc_eff_array = kwargs.pop(\n            \"fc_eff_array\", np.array([46, 46, 51, 51, 53, 53, 60]) / 100\n        )\n        # additional $ cost per kw of engine per engine efficiency percent\n        self.fc_cost_coeff_array = kwargs.pop(\n            \"fc_cost_coeff_array\", np.array([0, 0, 7, 16, 22, 40, 74])\n        )\n        # glider_kg light-weighted percents\n        self.ltwt_delta_percs = kwargs.pop(\n            \"ltwt_delta_percs\", np.array([0, 5, 5, 10, 10, 25]) / 100\n        )\n        # additional $ cost per kg light-weighted\n        self.ltwt_dol_per_kg_costs = kwargs.pop(\n            \"ltwt_dol_per_kg_costs\", np.array([4.41, 8.82, 13.23, 17.64, 22.05, 35.27])\n        )\n        # , if you want to keep default values, they should be 52.1 and 6.7\n        # To make it like what I sent before, Arthur can recalculate (should be enough decimals):\n        # a = 100*a\n        # b = 10000*b - Alicia\n        self.cda_cost_coeff_a = kwargs.pop(\"cda_cost_coeff_a\", 52.053)\n        self.cda_cost_coeff_b = kwargs.pop(\"cda_cost_coeff_b\", 6.7018)\n        self.cda_mass_coeff_a = kwargs.pop(\n            \"cda_mass_coeff_a\", 0\n        )  # default formula doesn't need a_M coeff, wt = 17967.9*p^2\n        self.cda_mass_coeff_b = kwargs.pop(\"cda_mass_coeff_b\", 1.79679)\n        self.cda_perc_imp_at_which_wt_penalty_maxes_out = kwargs.pop(\n            \"cda_perc_imp_at_which_wt_penalty_maxes_out\", 9999999999\n        )\n\n        # just checker values, knobs_bounds may not actually have all of these populated, so [0,0] is never used beyond the asserts\n        max_fc_bound = knobs_bounds.get(KNOB_FCPEAKEFF, (0, 0))[1]\n        max_ltwt_bound = knobs_bounds.get(KNOB_WTDELTAPERC, (0, 0))[1]\n        CdA_perc_imp_knob_max = knobs_bounds.get(KNOB_CDA, (0, 0))[1]\n\n        self.knobs_bounds = knobs_bounds\n\n        knobs = [key for key in knobs_bounds.keys()]\n        lower_bounds = anp.array([val[0] for bound, val in knobs_bounds.items()])\n        upper_bounds = anp.array([val[1] for bound, val in knobs_bounds.items()])\n\n        self.write_tsv = kwargs.pop(\"write_tsv\", False)\n\n        self.obj_list = obj_list\n        if obj_list is None:\n            # create default objective list\n            self.obj_list = [TCO]\n\n        self.constr_list = constr_list\n\n        # add acceleration and grade overshoot tolerance constraint implicitly if user is apply grade or acceleration constraints\n        if len(set(self.constr_list) &amp; set([ACCEL30, ACCEL60, GRADE125, GRADE6])):\n            self.constr_list.append(ACCEL_GRADE_OVERSHOOT)\n\n        n_constr = len(self.constr_list)\n        # input (f\"moo.py: T3COProblem __init__\\n{self.constr_list}, \\neffective constraints: {n_constr}\")\n        # make it so that knobs always need to be specified.\n        self.knobs = knobs\n\n        self.verbose = verbose\n\n        self.optimize_pt = optimize_pt\n\n        self.instantiate_moo_vehicles_and_scenario(vnum, config, do_input_validation)\n\n        # time dilation options, turned on for fuel efficiency cycle\n        if \"missed_trace_correction\" in kwargs:\n            self.opt_scenario.missed_trace_correction = kwargs.pop(\n                \"missed_trace_correction\"\n            )\n            self.opt_scenario.max_time_dilation = kwargs.pop(\"max_time_dilation\")\n            self.opt_scenario.min_time_dilation = kwargs.pop(\"min_time_dilation\")\n            self.opt_scenario.time_dilation_tol = kwargs.pop(\"time_dilation_tol\")\n\n        n_obj = len(self.obj_list)\n\n        n_args = len(knobs)\n\n        # asserts\n        assert (\n            self.optimize_pt == self.mooadvancedvehicle.veh_pt_type\n        ), \"instantiate_moo_vehicles_and_scenario should have handled this\"\n        for knob in self.knobs:\n            assert knob in KNOBS, f\"knob {knob} not in defined parameters: {KNOBS}\"\n        for constraint in self.constr_list:\n            assert (\n                constraint in CONSTRAINTS\n            ), f\"constraint {constraint} not in defined constraints: {CONSTRAINTS}\"\n            if constraint == PHEV_MINIMIZE_FUEL_USE_CONSTRAINT:\n                assert (\n                    self.opt_scenario.constraint_phev_minimize_fuel_use_percent &gt; 0\n                    and self.opt_scenario.constraint_phev_minimize_fuel_use_percent &lt; 1\n                )\n        assert len(OBJECTIVES) &gt;= 1, \"enable at least one objective\"\n        for obj in self.obj_list:\n            assert (\n                obj in OBJECTIVES\n            ), f\"objective {obj} not in defined objectives: {OBJECTIVES}\"\n        assert (\n            set(self.constr_list) &amp; set(self.obj_list) == set()\n        ), f\"cannot have constraints and objectives overlap constraints {self.constr_list} &amp; {self.obj_list}\"\n        if KNOB_fs_kwh in self.knobs:\n            assert (\n                self.optimize_pt in [gl.CONV, gl.HEV, gl.PHEV]\n            ), f\"input knob bounds: {knobs_bounds}\\naltering fuel store (tank, not battery) kwh size but vehicle powertrain to be optimized is {self.optimize_pt}\"\n        if KNOB_FCMAXKW in self.knobs:\n            assert (\n                self.optimize_pt in [gl.CONV, gl.HEV, gl.PHEV]\n            ), f\"input knob bounds: {knobs_bounds}\\naltering fuel converter size but vehicle powertrain is {self.optimize_pt}\"\n        if KNOB_ess_max_kwh in self.knobs:\n            assert (\n                self.optimize_pt in [gl.BEV, gl.HEV, gl.PHEV]\n            ), f\"input knob bounds: {knobs_bounds}\\naltering battery size but vehicle powertrain to be optimized is {self.optimize_pt}\"\n        if KNOB_mc_max_kw in self.knobs:\n            assert (\n                self.optimize_pt in [gl.BEV, gl.HEV, gl.PHEV]\n            ), f\"input knob bounds: {knobs_bounds}\\naltering motor size but vehicle powertrain to be optimized is {self.optimize_pt}\"\n        assert (\n            max_fc_bound &lt;= max(self.fc_eff_array)\n        ), f\"max eng eff knob val greater than max of eng eff array {max_fc_bound} &gt; {self.fc_eff_array}, could yield free efficiency\"\n        assert (\n            max_ltwt_bound &lt;= max(self.ltwt_delta_percs)\n        ), f\"max light-weight knob val greater than max of light-weighting percent array {max_ltwt_bound} &gt; {self.ltwt_delta_percs}, could yield free light-weighting\"\n        assert (\n            max_fc_bound &lt;= 1\n        ), f\"knob bounds must be decimal format, max_fc_bound: {max_fc_bound}\"\n        assert (\n            max_ltwt_bound &lt;= 1\n        ), f\"knob bounds must be decimal format, max_ltwt_bound: {max_ltwt_bound}\"\n        assert (\n            CdA_perc_imp_knob_max &lt;= 1\n        ), f\"knob bounds must be decimal format, CdA_perc_imp_knob_max: {CdA_perc_imp_knob_max}\"\n\n        # n_ieq_constr, number of constraints that must yield &lt; 0\n        super().__init__(\n            n_var=n_args,\n            n_obj=n_obj,\n            n_ieq_constr=n_constr,\n            # lower bounds\n            xl=lower_bounds,\n            # upper bounds\n            xu=upper_bounds,\n            **kwargs,\n        )\n\n        if len(kwargs) &gt; 0:\n            warnings.warn(\n                f\"Possible unused/invalid kwargs provided:\\n {list(kwargs.keys())}\"\n            )\n\n    def compile_reporting_vars(self) -&gt; None:\n        \"\"\"\n        This method creates an output dictionary containing optimization results\n        \"\"\"\n        d = {\n            \"objective_TCOs\": self.r_tcos,\n            \"objective_fc_khw_percent\": self.r_cd_fc_kwh_percent,\n            \"objective_fc_khw_used\": self.r_cd_fc_kwh_used,\n            \"objective_elec_khw_used\": self.r_cd_elec_kwh_used,\n            \"r_mph_ach_grade_6s\": self.r_grade_6s,\n            \"r_mph_ach_grade_1p25s\": self.r_grade_1p25s,\n            \"r_sec_to_ach_30mph_ldd\": self.r_accel_30l,\n            \"r_sec_to_ach_60mph_ldd\": self.r_accel_60l,\n            \"r_ach_ranges_mi\": self.r_ranges,\n            \"target_mph_grade_6s\": [\n                self.opt_scenario.min_speed_at_6pct_grade_in_5min_mph\n            ]\n            * len(self.r_grade_6s),\n            \"target_mph_grade_1p25s\": [\n                self.opt_scenario.min_speed_at_1p25pct_grade_in_5min_mph\n            ]\n            * len(self.r_grade_6s),\n            \"target_sec_to_30mph_ldd\": [self.opt_scenario.max_time_0_to_30mph_at_gvwr_s]\n            * len(self.r_grade_6s),\n            \"target_sec_to_60mph_ldd\": [self.opt_scenario.max_time_0_to_60mph_at_gvwr_s]\n            * len(self.r_grade_6s),\n            \"target_range_mi\": [self.opt_scenario.target_range_mi]\n            * len(self.r_grade_6s),\n            \"r_ach_fuel_efficiencies\": self.r_fuel_efficiencies,\n            \"accel_30_constraint_vals\": self.accel_30_constraint,\n            \"accel_60_constraint_vals\": self.accel_60_constraint,\n            \"grade_6_constraint_vals\": self.grade_6_constraint,\n            \"grade_1p25_constraint_vals\": self.grade_1p25_constraint,\n            \"range_constraint_vals\": self.range_constraint,\n            \"grade_accel_overshoot_tol_constraint_vals\": self.grade_accel_overshoot_tol_constraint,\n            \"trace_miss_dist_percent_constraint_vals\": self.trace_miss_distance_percent_constraint_record,\n            \"phev_min_fuel_use_pct_constraint_vals\": self.phev_min_fuel_use_prcnt_const_record,\n            \"r_wt_delta_perc_guess\": self.r_wt_delta_perc_guess,\n            \"r_CdA_reduction_perc\": self.r_CdA_reduction_perc,\n            \"r_fc_peak_eff_guess\": self.r_fc_peak_eff_guess,\n            \"r_fc_max_out_kw_guess\": self.r_fc_max_out_kw_guess,\n            \"r_fs_kwh_guess\": self.r_fs_kwh_guess,\n            \"r_max_ess_kwh_guess\": self.r_max_ess_kwh_guess,\n            \"r_max_motor_kw_guess\": self.r_max_motor_kw_guess,\n        }\n        self.reporting_vars = pd.DataFrame(data=d)\n\n    def instantiate_moo_vehicles_and_scenario(\n        self,\n        vnum: int,\n        config: run_scenario.Config = None,\n        do_input_validation: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        This method instantiates the multi-objective optimization problem vehicles and scenarios, starting with the baseline Conventional vehicle.\n\n        Args:\n            vnum (int): vehicle selection number\n            config (run_scenario.Config, optional): T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.\n\n        Raises:\n            TypeError: Invalid optimize_pt selection\n        \"\"\"\n        self.moobasevehicle = run_scenario.get_vehicle(\n            vnum,\n            veh_input_path=config.vehicle_file,\n        )\n\n        self.opt_scenario, self.designcycle = run_scenario.get_scenario_and_cycle(\n            vnum,\n            config.scenario_file,\n            config=config,\n            do_input_validation=do_input_validation,\n        )\n\n        if (\n            self.opt_scenario.fuel_type == \"diesel and electricity\"\n            and self.moobasevehicle.veh_pt_type == gl.HEV\n        ):\n            self.opt_scenario.fuel_type = \"diesel\"\n\n        # save baseline values for optimization diffs\n        self.opt_scenario.originalGliderPrice = (\n            self.opt_scenario.vehicle_glider_cost_dol\n        )\n        self.opt_scenario.originalglider_kg = self.moobasevehicle.glider_kg\n        self.opt_scenario.originalIceDolPerKw = self.opt_scenario.fc_ice_cost_dol_per_kw\n        self.opt_scenario.origfc_eff_map = self.moobasevehicle.fc_eff_map.copy()\n        self.opt_scenario.originalcargo_kg = self.moobasevehicle.cargo_kg\n        self.opt_scenario.originaldrag_coef = self.moobasevehicle.drag_coef\n\n        self.mooadvancedvehicle = copy.copy(self.moobasevehicle)\n\n        if self.optimize_pt == gl.BEV:\n            self.mooadvancedvehicle.veh_pt_type = gl.BEV\n            run_scenario.set_max_fuel_converter_kw(self.mooadvancedvehicle, 0)\n            # change to 0, based on Excel version direction when trying to run as EV\n            self.mooadvancedvehicle.fc_max_out_kw = 0\n            run_scenario.set_fuel_store_kwh(self.mooadvancedvehicle, 0)\n        elif self.optimize_pt == gl.CONV:\n            self.mooadvancedvehicle.veh_pt_type = gl.CONV\n            run_scenario.set_max_motor_kw(\n                self.mooadvancedvehicle, scenario=None, max_motor_kw=0\n            )\n            run_scenario.set_max_battery_kwh(self.mooadvancedvehicle, max_ess_kwh=0)\n        elif self.optimize_pt == gl.HEV:\n            self.mooadvancedvehicle.veh_pt_type = gl.HEV\n            # nothing to zero out for HEV/FCEV\n        elif self.optimize_pt == gl.PHEV:\n            self.mooadvancedvehicle.veh_pt_type = gl.PHEV\n        else:\n            raise TypeError(f\"invalid optimize_pt selection {self.optimize_pt}\")\n\n        # establish payload opp cost calc module\n        # TODO, this should include FCEV, and this TCO element should be True/False activated\n        # if self.opt_scenario.activate_tco_payload_cap_cost_multiplier or self.opt_scenario.activate_tco_fueling_dwell_time_cost or self.opt_scenario.activate_mr_downtime_cost:\n        #     self.oppcostobj = opportunity_cost.OpportunityCost(self.opt_scenario)\n\n    # --------- optimizer parameter application methods ---------\n    def cda_percent_delta_knob(\n        self, CdA_perc_reduction: str, optvehicle: fastsim.vehicle.Vehicle\n    ) -&gt; None:\n        \"\"\"\n        This method sets the drag_coef based on aero improvement curve and glider_kg based on cda_cost_coeff_a and cda_cost_coeff_b\n\n        Args:\n            CdA_perc_reduction (str): Name of aero improvement curve file\n            optvehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object for optimization vehicle\n\n        \"\"\"\n\n        # check value of CdA_reduction\n        # print(CdA_perc_reduction)\n\n        # functions that return cost, weight, and possibly other penalties w.r.t. various improvements\n\n        def get_cost_per_CdA_delta(x):\n            \"\"\"\n            Returns cost penalty given percent improvement in CdA.\n            \"\"\"\n            # COST:  a * cda_perc + b * cda_perc^2\n            a_C = self.cda_cost_coeff_a\n            b_C = self.cda_cost_coeff_b\n            x = x * 100\n            return a_C * x + b_C * x**2\n\n        def get_mass_per_CdA_delta(x):\n            \"\"\"\n            Returns weight penalty [Lb converted to kg] given % improvement in CdA.\n            These formulas are developed in pounds. Converted to kg for FASTSim at the end.\n            \"\"\"\n            # MASS: a * cda_perc + b * cda_perc^2\n            a_M = (\n                self.cda_mass_coeff_a\n            )  # default formula doesn't need a_M coeff, wt = 17967.9*p^2\n            b_M = self.cda_mass_coeff_b\n            x = x * 100\n            CdA_perc_imp_at_which_wt_penalty_maxes_out = (\n                self.cda_perc_imp_at_which_wt_penalty_maxes_out\n            )\n            return min(\n                gl.lbs_to_kgs(\n                    a_M * CdA_perc_imp_at_which_wt_penalty_maxes_out\n                    + b_M * CdA_perc_imp_at_which_wt_penalty_maxes_out**2\n                ),\n                gl.lbs_to_kgs(a_M * x + b_M * x**2),\n            )\n\n        # reset drag coefficient based on percent improvement\n        optvehicle.drag_coef = max(\n            0.01,  # this is an additional hard-coded bound on drag coefficient that should probably be removed (throw error or warning if drag_coef &lt; 0.01 instead of running and replacing with this default value)\n            self.opt_scenario.originaldrag_coef * (1 - CdA_perc_reduction),\n        )\n        # glider cost penalty due to CdA improvement\n        CdA_cost = get_cost_per_CdA_delta(CdA_perc_reduction)\n        self.opt_scenario.vehicle_glider_cost_dol = (\n            self.opt_scenario.vehicle_glider_cost_dol + CdA_cost\n        )\n        # mass adjustments. Add CdA mass FIRST, if applicable. Then limit cargo_kg if overweight from battery.\n        optvehicle.glider_kg = optvehicle.glider_kg + get_mass_per_CdA_delta(\n            CdA_perc_reduction\n        )\n        optvehicle.set_veh_mass()\n\n    def weight_delta_percent_knob(\n        self, wt_perc_reduction: float, optvehicle: fastsim.vehicle.Vehicle\n    ) -&gt; None:\n        \"\"\"\n        This method sets the knob from the lightweighting curve\n\n        Args:\n            wt_perc_reduction (float): Weight reduction percentage value from lightweighting curve\n            optvehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of the optimization vehicle\n        \"\"\"\n        wt_delta_cost_per_kg = np.interp(\n            x=wt_perc_reduction, xp=self.ltwt_delta_percs, fp=self.ltwt_dol_per_kg_costs\n        )\n        wt_delta_kg = optvehicle.glider_kg * wt_perc_reduction\n        # Calculate lightweight cost from curve as an integral\n        x_new = (\n            self.ltwt_delta_percs[self.ltwt_delta_percs &lt;= wt_perc_reduction]\n            * optvehicle.glider_kg\n        )\n        y_new = self.ltwt_dol_per_kg_costs[self.ltwt_delta_percs &lt;= wt_perc_reduction]\n        if wt_delta_kg not in x_new:\n            x_new = np.append(x_new, wt_delta_kg)\n            y_new = np.append(y_new, wt_delta_cost_per_kg)\n        self.opt_scenario.vehicle_glider_cost_dol = (\n            self.opt_scenario.vehicle_glider_cost_dol + np.trapz(y_new, x_new)\n        )\n        optvehicle.glider_kg = optvehicle.glider_kg - wt_delta_kg\n        optvehicle.set_veh_mass()\n\n    def fc_peak_eff_knob(\n        self, fc_peak_eff: float, optvehicle: fastsim.vehicle.Vehicle\n    ) -&gt; None:\n        \"\"\"\n        This method sets the knob from the engine efficiency curve\n\n        Args:\n            fc_peak_eff (float): Fuel converter peak effiency override from engine efficiency improvement curve\n            optvehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object for optimization vehicle\n        \"\"\"\n        fc_eff_array = self.fc_eff_array\n        cost_coeff_array = self.fc_cost_coeff_array\n        d_eff_dol_per_kw = np.interp(fc_peak_eff, fc_eff_array, cost_coeff_array)\n        self.opt_scenario.fc_ice_cost_dol_per_kw = (\n            self.opt_scenario.originalIceDolPerKw + d_eff_dol_per_kw\n        )\n        self.adjust_fc_peak_eff(fc_peak_eff, self.opt_scenario, optvehicle)\n\n    def get_objs(\n        self, x: dict, write_tsv: bool = False\n    ) -&gt; Tuple[np.array, np.array, dict]:\n        \"\"\"\n        This method gets called when PyMoo calls _evaluate. It initializes objectives and constraints and runs vehicle_scenario_sweep\n\n        x optimization knobs = [max motor kw, battery kwh, drag coeff % improvement]\n        Function for running FE cycles and accel tests then returning\n        fuel consumption and zero-to-sixty times.\n\n        x is a set of genes (or parameters), so kwh size is a gene\n        chromosome is a full gene, all values in x\n\n        Args:\n            x (dict): Dictionary containing optimization knobs - {max motor kw, battery kwh, drag coeff % improvement}\n            write_tsv (bool, optional): if True, save intermediate dataframes. Defaults to False.\n\n        Returns:\n            obj_arr_F (np.array): Array of objectives - tot_cost and phev_cd_fuel_used_kwh\n            constraint_results_G (np.array): Array of constraints\n            rs_sweep (dict): Output dictionary from vehicle_scenario_sweep\n        \"\"\"\n\n        # dict for providing mechanism for making sure all knobs get used\n        x_dict = {knob: x[self.knobs.index(knob)] for knob in self.knobs}\n\n        # if self.optimize_pt not in [gl.CONV, gl.BEV, gl.HEV]:\n        #     raise TypeError(f\"optimize_pt is not configured for {self.optimize_pt}\")\n        designcycle = self.designcycle\n        optvehicle = self.mooadvancedvehicle\n\n        # reset glider price and weight for light-weighting and/or CdA percent improvement\n        self.opt_scenario.vehicle_glider_cost_dol = (\n            self.opt_scenario.originalGliderPrice\n        )\n        optvehicle.glider_kg = self.opt_scenario.originalglider_kg\n\n        wt_delta_perc_guess = x_dict.pop(KNOB_WTDELTAPERC, None)\n        CdA_reduction_perc = x_dict.pop(KNOB_CDA, None)\n        fc_peak_eff_guess = x_dict.pop(KNOB_FCPEAKEFF, None)\n        fc_max_out_kw_guess = x_dict.pop(KNOB_FCMAXKW, None)\n        max_ess_kwh_guess = x_dict.pop(KNOB_ess_max_kwh, None)\n        max_motor_kw_guess = x_dict.pop(KNOB_mc_max_kw, None)\n        fs_kwh_guess = x_dict.pop(KNOB_fs_kwh, None)\n        # set knobs\n        if \"wt_delta_perc\" in self.knobs:\n            # confirmed with Alicia and Jason on 8/11/2021 that light-weighting should occur before CdA adjustment\n            self.weight_delta_percent_knob(wt_delta_perc_guess, optvehicle)\n        if \"CdA_perc_imp\" in self.knobs:\n            self.cda_percent_delta_knob(CdA_reduction_perc, optvehicle)\n        if \"fc_peak_eff\" in self.knobs:\n            self.fc_peak_eff_knob(fc_peak_eff_guess, optvehicle)\n        if \"fcMaxOutKw\" in self.knobs:\n            run_scenario.set_max_fuel_converter_kw(optvehicle, fc_max_out_kw_guess)\n        if KNOB_fs_kwh in self.knobs:\n            run_scenario.set_fuel_store_kwh(optvehicle, fs_kwh_guess)\n        if \"ess_max_kwh\" in self.knobs:\n            run_scenario.set_max_battery_kwh(optvehicle, max_ess_kwh_guess)\n        if \"mc_max_kw\" in self.knobs:\n            run_scenario.set_max_motor_kw(\n                optvehicle, self.opt_scenario, max_motor_kw_guess\n            )\n\n        # enforce 0 &lt;= cargo kg &lt;= initial cargo kg for BEV and HEV optimizations\n        if self.optimize_pt in [gl.BEV, gl.HEV]:\n            run_scenario.limit_cargo_kg_for_moo_hev_bev(self.opt_scenario, optvehicle)\n\n        # # TODO, this calculation and application of payload loss is still not finalized.\n        # this also needs to be used for FCEV, would be nice if there were an FCEV veh_pt_type!!!\n        # also it needs to have a Scenario File on/off activation\n\n        assert len(x_dict) == 0, f\"Unapplied knobs: {list(x_dict.keys())}\"\n\n        # calculate objectives\n        get_accel_loaded = False\n        get_grade = False\n        obj_arr_F = []\n        g6_acvhd, g125_acvhd, z60l_acvhd, z30l_acvhd, tco_acvhd, mpgge, range_achvd = [\n            None\n        ] * 7\n        if GRADE6 in self.constr_list or GRADE125 in self.constr_list:\n            get_grade = True\n        if ACCEL30 in self.constr_list or ACCEL60 in self.constr_list:\n            get_accel_loaded = True\n\n        rs_sweep = run_scenario.vehicle_scenario_sweep(\n            optvehicle,\n            self.opt_scenario,\n            designcycle,\n            verbose=self.verbose,\n            get_accel=False,  # don't want non-loaded accel values, for now\n            get_accel_loaded=get_accel_loaded,\n            get_gradeability=get_grade,\n            write_tsv=write_tsv,\n        )\n\n        mpgge = rs_sweep[\"mpgge\"]\n        g6_acvhd, g125_acvhd = (\n            rs_sweep[\"grade_6_mph_ach\"],\n            rs_sweep[\"grade_1_25_mph_ach\"],\n        )\n        z60l_acvhd, z30l_acvhd = (\n            rs_sweep[\"zero_to_60_loaded\"],\n            rs_sweep[\"zero_to_30_loaded\"],\n        )\n        tco_acvhd = rs_sweep[\"tot_cost\"]\n        if optvehicle.veh_pt_type in [gl.BEV, gl.CONV, gl.HEV]:\n            range_achvd = rs_sweep[\"primary_fuel_range_mi\"]\n        elif optvehicle.veh_pt_type == gl.PHEV:\n            # need range from PHEV that is used to compare to target_range_mi\n            range_achvd = rs_sweep[\"cd_aer_phev_range_mi\"]\n\n        if self.verbose:\n            print(\n                f\"grade_6_mph_ach {g6_acvhd} grade_1_25_mph_ach {g125_acvhd} zero_to_60_loaded {z60l_acvhd} \"\n                f\"zero_to_30_loaded {z30l_acvhd} tco {tco_acvhd} mpgge {mpgge} range {range_achvd}\"\n            )\n\n        # PHEV fuel usage stats\n        pct_fc_kwh = None\n        phev_cd_fuel_used_kwh = None\n        phev_cd_battery_used_kwh = None\n        if (\n            PHEV_MINIMIZE_FUEL_USE_OBJECTIVE in self.obj_list\n            or PHEV_MINIMIZE_FUEL_USE_CONSTRAINT in self.constr_list\n        ):\n            phev_cd_fuel_used_kwh = rs_sweep[\"mpgge\"][\"cd_fuel_used_kwh_total\"]\n            phev_cd_battery_used_kwh = rs_sweep[\"mpgge\"][\"cd_battery_used_kwh\"]\n            pct_fc_kwh = round(\n                phev_cd_fuel_used_kwh\n                / (phev_cd_battery_used_kwh + phev_cd_fuel_used_kwh),\n                2,\n            )\n        #                                                           #\n        # ********************** objectives  ********************** #\n        #                                                           #\n        if TCO in self.obj_list:\n            obj_arr_F.append(tco_acvhd)\n        if PHEV_MINIMIZE_FUEL_USE_OBJECTIVE in self.obj_list:\n            obj_arr_F.append(phev_cd_fuel_used_kwh)\n        #                                                           #\n        # ******************** end objectives  ******************** #\n        #                                                           #\n\n        #                                                           #\n        # ********************** constraints ********************** #\n        #\n        #                                                           #\n\n        self.accel_30_constraint.append(None)\n        self.accel_60_constraint.append(None)\n        self.grade_6_constraint.append(None)\n        self.grade_1p25_constraint.append(None)\n        self.range_constraint.append(None)\n        self.grade_accel_overshoot_tol_constraint.append(None)\n        self.c_rate_constraint.append(None)\n        self.trace_miss_distance_percent_constraint_record.append(None)\n        self.phev_min_fuel_use_prcnt_const_record.append(None)\n\n        constraint_results_G = []\n        # calculate constraint violations\n        # speed at grade minus target should be negative when constraint is met\n        if GRADE6 in self.constr_list:\n            constraint_results_G.append(\n                self.opt_scenario.min_speed_at_6pct_grade_in_5min_mph - g6_acvhd\n            )\n        if GRADE125 in self.constr_list:\n            constraint_results_G.append(\n                self.opt_scenario.min_speed_at_1p25pct_grade_in_5min_mph - g125_acvhd\n            )\n        if ACCEL60 in self.constr_list:\n            # zero-to-speed time should minus max allowable (target value) should\n            # be negative when constraint is met\n            # 9 sec achvd - 10 sec target = -1\n            constraint_results_G.append(\n                z60l_acvhd - self.opt_scenario.max_time_0_to_60mph_at_gvwr_s\n            )\n        if ACCEL30 in self.constr_list:\n            constraint_results_G.append(\n                z30l_acvhd - self.opt_scenario.max_time_0_to_30mph_at_gvwr_s\n            )\n\n        # calculate limiting grade/accel requirement if all constraints met\n        if ACCEL_GRADE_OVERSHOOT in self.constr_list:\n            constr_perc = {}\n            if GRADE125 in self.constr_list:\n                # todo, -abs() for all of these?\n                g125c = (\n                    -(\n                        g125_acvhd\n                        - self.opt_scenario.min_speed_at_1p25pct_grade_in_5min_mph\n                    )\n                    / self.opt_scenario.min_speed_at_1p25pct_grade_in_5min_mph\n                )\n                constr_perc[GRADE125] = g125c\n                self.grade_1p25_constraint[-1] = g125c\n            if GRADE6 in self.constr_list:\n                g6c = (\n                    -(g6_acvhd - self.opt_scenario.min_speed_at_6pct_grade_in_5min_mph)\n                    / self.opt_scenario.min_speed_at_6pct_grade_in_5min_mph\n                )\n                constr_perc[GRADE6] = g6c\n                self.grade_6_constraint[-1] = g6c\n            if ACCEL60 in self.constr_list:\n                z60c = (\n                    z60l_acvhd - self.opt_scenario.max_time_0_to_60mph_at_gvwr_s\n                ) / self.opt_scenario.max_time_0_to_60mph_at_gvwr_s\n                constr_perc[ACCEL60] = z60c\n                self.accel_60_constraint[-1] = z60c\n            if ACCEL30 in self.constr_list:\n                z30c = (\n                    z30l_acvhd - self.opt_scenario.max_time_0_to_30mph_at_gvwr_s\n                ) / self.opt_scenario.max_time_0_to_30mph_at_gvwr_s\n                constr_perc[ACCEL30] = z30c\n                self.accel_30_constraint[-1] = z30c\n\n            # if all constraints meet target, then find closest overshoot and ensure it's below tolerance\n            if (len(constr_perc) &gt; 0) &amp; (\n                np.array(list(constr_perc.values())) &lt; 0\n            ).all():\n                # say largest negative percent is -.1 (closest to target, 10% exceeding)\n                # tolerance is .05\n                # -(-.1) - 0.05 = 0.05, &gt;= 0, constraint is violated. Constraints are in bounds if they return &lt; 0\n                min_grade_accel_excess = (\n                    -constr_perc[max(constr_perc, key=constr_perc.get)]\n                    - self.grade_accel_overshoot_tol\n                )\n            else:\n                min_grade_accel_excess = -1  # no constraint to satisfy\n            constraint_results_G.append(min_grade_accel_excess)\n            self.grade_accel_overshoot_tol_constraint[-1] = min_grade_accel_excess\n\n        if RANGE in self.constr_list:\n            # if you fall short of range target\n            if self.range_overshoot_tol is None:\n                range_mi_cv = (\n                    self.opt_scenario.target_range_mi - range_achvd\n                )  # pos return, failed\n            else:\n                if range_achvd &lt;= self.opt_scenario.target_range_mi:\n                    range_mi_cv = (\n                        self.opt_scenario.target_range_mi - range_achvd\n                    )  # pos return, failed\n                else:\n                    range_mi_cv = range_achvd - (\n                        self.opt_scenario.target_range_mi\n                        * (1 + self.range_overshoot_tol)\n                    )\n\n            constraint_results_G.append(range_mi_cv)\n            self.range_constraint[-1] = range_mi_cv\n\n        # c rate constraint\n        if C_RATE in self.constr_list:\n            self.c_rate_constraint[-1] = (\n                self.mooadvancedvehicle.ess_max_kw / self.mooadvancedvehicle.ess_max_kwh\n                - np.interp(\n                    self.mooadvancedvehicle.ess_max_kwh,\n                    # TODO, this 2D array needs to be an input\n                    [1.0, 10.0, 188.0, 660.0],  # battery sizes kwh\n                    [24.0, 12.0, 2.0, 0.7],  # c rates (kw/kwh)\n                )\n            )\n            constraint_results_G.append(self.c_rate_constraint[-1])\n\n        # # trace miss constraint\n        if TRACE_MISS_DIST_PERCENT in self.constr_list:\n            assert (\n                self.opt_scenario.trace_miss_dist_percent &gt; 0\n                and self.opt_scenario.trace_miss_dist_percent &lt; 1\n            ), \"scenario file input trace_miss_dist_percent must be decimal value greater than 0 and less than 1\"\n            cycle_records = rs_sweep[\"design_cycle_sim_drive_record\"]\n            max_dist_frac_result = max(\n                sdr.trace_miss_dist_frac for sdr in cycle_records\n            )\n            # .1 -&gt; 10%\n            max_dist_frac_miss = self.opt_scenario.trace_miss_dist_percent\n            constraint_results_G.append(max_dist_frac_result - max_dist_frac_miss)\n            self.trace_miss_distance_percent_constraint_record[-1] = (\n                max_dist_frac_result - max_dist_frac_miss\n            )\n\n        if PHEV_MINIMIZE_FUEL_USE_CONSTRAINT in self.constr_list:\n            assert (\n                self.opt_scenario.constraint_phev_minimize_fuel_use_percent &gt; 0\n            ), \"scenario.constraint_phev_minimize_fuel_use_percent must be value &gt; 0 and &lt; 1\"\n            assert (\n                self.opt_scenario.constraint_phev_minimize_fuel_use_percent &lt; 1\n            ), \"scenario.constraint_phev_minimize_fuel_use_percent must be value &gt; 0 and &lt; 1\"\n            constraint_results_G.append(\n                pct_fc_kwh - self.opt_scenario.constraint_phev_minimize_fuel_use_percent\n            )\n            self.phev_min_fuel_use_prcnt_const_record[-1] = (\n                pct_fc_kwh - self.opt_scenario.constraint_phev_minimize_fuel_use_percent\n            )\n\n        #                                                           #\n        # ******************** end constraints ******************** #\n        #                                                           #\n\n        # append reporting variables\n        # obj vars\n        self.r_tcos.append(tco_acvhd)\n        self.r_cd_fc_kwh_percent.append(pct_fc_kwh)\n        self.r_cd_fc_kwh_used.append(phev_cd_fuel_used_kwh)\n        self.r_cd_elec_kwh_used.append(phev_cd_battery_used_kwh)\n\n        self.r_grade_6s.append(g6_acvhd)\n        self.r_grade_1p25s.append(g125_acvhd)\n        self.r_accel_60l.append(z60l_acvhd)\n        self.r_accel_30l.append(z30l_acvhd)\n        self.r_fuel_efficiencies.append(mpgge)\n        self.r_ranges.append(range_achvd)\n        self.r_wt_delta_perc_guess.append(wt_delta_perc_guess)\n        self.r_CdA_reduction_perc.append(CdA_reduction_perc)\n        self.r_fc_peak_eff_guess.append(fc_peak_eff_guess)\n        self.r_fc_max_out_kw_guess.append(fc_max_out_kw_guess)\n        self.r_fs_kwh_guess.append(fs_kwh_guess)\n        self.r_max_ess_kwh_guess.append(max_ess_kwh_guess)\n        self.r_max_motor_kw_guess.append(max_motor_kw_guess)\n\n        return np.array(obj_arr_F), np.array(constraint_results_G), rs_sweep\n\n    def _evaluate(self, x: dict, out: dict, *args, **kwargs) -&gt; None:\n        \"\"\"\n        This method runs T3COProblem.get_objs() when running Pymoo optimization\n\n        Args:\n            x (dict): Dictionary containing optimization knobs\n            out (dict): Dictionary containing TCO results for optimization runs\n        \"\"\"\n        obj_arr_F, constr_arr, _ = self.get_objs(x)\n        out[\"F\"] = obj_arr_F\n\n        if len(constr_arr) &gt; 0:\n            out[\"G\"] = constr_arr\n\n    def adjust_fc_peak_eff(\n        self,\n        fc_peak_eff: float,\n        scenario: run_scenario.Scenario,\n        optvehicle: fastsim.vehicle.Vehicle,\n    ) -&gt; None:\n        \"\"\"\n        This method augments an advanced vehicle fc_eff_array based on new fc_peak_eff using baseline fc_eff_array\n\n\n        Args:\n            fc_peak_eff (float): Fuel converter peak efficiency override\n            scenario (run_scenario.Scenario): Scenario object of current selection\n            optvehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of optimization vehicle\n        \"\"\"\n        old_peak_eff = scenario.origfc_eff_map.max()\n        optvehicle.fc_eff_map = scenario.origfc_eff_map * (\n            1 + (fc_peak_eff - old_peak_eff) / old_peak_eff\n        )\n        optvehicle.set_derived()\n\n    # ------------------------------------ utility functions ------------------------------------\n    def sweep_knob(\n        self,\n        knob: list,\n        definition: int = 100,\n        plot: bool = False,\n        optres: float = None,\n        **kwargs,\n    ) -&gt; list:\n        \"\"\"\n        This method sweeps the optimization knob of vehicle from lbound to ubound, return TCO \\\n            plot optres to see if there's agreement from opt solution and your sweep\n\n        Args:\n            knob (list): list of knobs names for optimization\n            definition (int, optional): Number of points. Defaults to 100.\n            plot (bool, optional): if True, saves plot of bounds and TCOs. Defaults to False.\n            optres (float, optional): Optimization resolution. Defaults to None.\n\n        Returns:\n            tcos (list): List of TCOs of length=definition\n        \"\"\"\n        label = kwargs.get(\"label\", \"\")\n        sweep_knob_accel_test = kwargs.get(\"sweep_knob_accel_test\", False)\n        # save knobs and obj list\n        temp_obj_list = self.obj_list\n        self.knobs = [knob]\n        self.obj_list = [TCO]\n        lbound, ubound = self.knobs_bounds[knob]\n        tcos = [self.get_objs([x])[0] for x in np.linspace(lbound, ubound, definition)]\n\n        if sweep_knob_accel_test:\n            opt_res_kw = np.inf\n            if optres is not None:\n                opt_res_kw = optres\n            assert knob in [KNOB_mc_max_kw, KNOB_FCMAXKW]\n            self.obj_list = [ACCEL30, ACCEL60]\n            # objs.extend([z60l, z30l]) {(60, 30),...(60, 30)}\n            thirty_mph_times = []\n            sixty_mph_times = []\n            largest_infeasible_30s_size = None\n            failed_30_s_time = None\n            largest_infeasible_60s_size = None\n            failed_60_s_time = None\n            for x in np.linspace(lbound, ubound, definition):\n                z60l, z30l = self.get_objs([x])\n                thirty_mph_times.append([z30l, x])\n                sixty_mph_times.append([z60l, x])\n            for res in sixty_mph_times:\n                z60l, x = res\n                if (\n                    z60l &gt; self.opt_scenario.max_time_0_to_60mph_at_gvwr_s\n                    and x &lt; opt_res_kw\n                ):\n                    largest_infeasible_60s_size = x\n                    failed_60_s_time = z60l\n            for res in sixty_mph_times:\n                z30l, x = res\n                if (\n                    z30l &gt; self.opt_scenario.max_time_0_to_30mph_at_gvwr_s\n                    and x &lt; opt_res_kw\n                ):\n                    largest_infeasible_30s_size = x\n                    failed_30_s_time = z30l\n\n        # todo, figure out how to get mpgge in the other y axis\n        if plot:\n            resdir = gl.MOO_KNOB_SWEEP_PLOTS_DIR\n            if not resdir.exists():\n                resdir.mkdir()\n            ts = strftime(\"%Y-%m-%d_%H-%M-%S\", gmtime())\n            plt.figure(figsize=(7, 4))\n            plt.ylabel(\"$TCO\")\n            plt.title(f\"{label}_{ts}_{knob}\")\n            plt.xlabel(f\"knob value for {definition} pts\")\n            plt.plot(\n                np.linspace(lbound, ubound, definition),\n                tcos,\n                label=f\"TCO from global optimum, sweeping {knob}\",\n            )\n            if optres is not None:\n                plt.vlines(\n                    optres,\n                    min(tcos),\n                    max(tcos),\n                    color=\"red\",\n                    label=f\"MOO {knob} solution: {optres}\",\n                )\n            if sweep_knob_accel_test:\n                if largest_infeasible_30s_size is not None:\n                    plt.vlines(\n                        largest_infeasible_30s_size,\n                        min(tcos),\n                        max(tcos),\n                        color=\"orange\",\n                        label=f\"failed accel test 0 to 30 res: {failed_30_s_time} target: {self.opt_scenario.max_time_0_to_30mph_at_gvwr_s} {knob} size: {largest_infeasible_30s_size}\",\n                    )\n                if largest_infeasible_60s_size is not None:\n                    plt.vlines(\n                        largest_infeasible_60s_size,\n                        min(tcos),\n                        max(tcos),\n                        color=\"yellow\",\n                        label=f\"failed accel test 0 to 60 res: {failed_60_s_time} target: {self.opt_scenario.max_time_0_to_60mph_at_gvwr_s} {knob} size: {largest_infeasible_30s_size}\",\n                    )\n            plt.legend()\n            plt.savefig(resdir / f\"{knob}_{label}_{ts}.png\")\n            print(f\"saving {knob} results to \", resdir)\n            plt.show()\n        self.knobs = self.knobs_bounds.keys()\n        self.obj_list = temp_obj_list\n        return tcos\n\n    def get_tco_from_moo_advanced_result(self, x: dict) -&gt; dict:\n        \"\"\"\n        This method is a utility function to get detailed TCO information from optimized MOO result\n\n        Args:\n            x (dict): Dictionary containing optimization knobs - [max motor kw, battery kwh, drag coeff % improvement]\n\n        Returns:\n            out (dict): Dictionary containing TCO results for optimization runs\n        \"\"\"\n        x_dict = {knob: x[self.knobs.index(knob)] for knob in self.knobs}\n        wt_delta_perc_guess = x_dict.pop(KNOB_WTDELTAPERC, None)\n        CdA_reduction_perc = x_dict.pop(KNOB_CDA, None)\n        fc_peak_eff_guess = x_dict.pop(KNOB_FCPEAKEFF, None)\n        fc_max_out_kw_guess = x_dict.pop(KNOB_FCMAXKW, None)\n        max_ess_kwh_guess = x_dict.pop(KNOB_ess_max_kwh, None)\n        max_motor_kw_guess = x_dict.pop(KNOB_mc_max_kw, None)\n        fs_kwh_guess = x_dict.pop(KNOB_fs_kwh, None)\n\n        print(\"MOO Final Solution:\")\n        if wt_delta_perc_guess is not None:\n            print(KNOB_WTDELTAPERC.rjust(20, \" \"), f\":{round(wt_delta_perc_guess, 4)}\")\n        if CdA_reduction_perc is not None:\n            print(KNOB_CDA.rjust(20, \" \"), f\":{round(CdA_reduction_perc, 4)}\")\n        if fc_peak_eff_guess is not None:\n            print(KNOB_FCPEAKEFF.rjust(20, \" \"), f\":{round(fc_peak_eff_guess, 4)}\")\n        if fc_max_out_kw_guess is not None:\n            print(KNOB_FCMAXKW.rjust(20, \" \"), f\":{round(fc_max_out_kw_guess, 4)}\")\n        if max_ess_kwh_guess is not None:\n            print(KNOB_ess_max_kwh.rjust(20, \" \"), f\":{round(max_ess_kwh_guess, 4)}\")\n        if max_motor_kw_guess is not None:\n            print(KNOB_mc_max_kw.rjust(20, \" \"), f\":{round(max_motor_kw_guess, 4)}\")\n        if fs_kwh_guess is not None:\n            print(KNOB_fs_kwh.rjust(20, \" \"), f\":{round(fs_kwh_guess, 4)}\")\n\n        _, _, out = self.get_objs(x, write_tsv=False)\n\n        return out\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.cda_cost_coeff_a","title":"<code>cda_cost_coeff_a = kwargs.pop('cda_cost_coeff_a', 52.053)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.cda_cost_coeff_b","title":"<code>cda_cost_coeff_b = kwargs.pop('cda_cost_coeff_b', 6.7018)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.cda_mass_coeff_a","title":"<code>cda_mass_coeff_a = kwargs.pop('cda_mass_coeff_a', 0)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.cda_mass_coeff_b","title":"<code>cda_mass_coeff_b = kwargs.pop('cda_mass_coeff_b', 1.79679)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.cda_perc_imp_at_which_wt_penalty_maxes_out","title":"<code>cda_perc_imp_at_which_wt_penalty_maxes_out = kwargs.pop('cda_perc_imp_at_which_wt_penalty_maxes_out', 9999999999)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.config","title":"<code>config: run_scenario.Config</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.constr_list","title":"<code>constr_list = constr_list</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.designcycle","title":"<code>designcycle: fastsim.cycle.Cycle</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.do_input_validation","title":"<code>do_input_validation: bool</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.fc_cost_coeff_array","title":"<code>fc_cost_coeff_array = kwargs.pop('fc_cost_coeff_array', np.array([0, 0, 7, 16, 22, 40, 74]))</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.fc_eff_array","title":"<code>fc_eff_array = kwargs.pop('fc_eff_array', np.array([46, 46, 51, 51, 53, 53, 60]) / 100)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.grade_accel_overshoot_tol","title":"<code>grade_accel_overshoot_tol = kwargs.pop('grade_accel_overshoot_tol', 0.01)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.knobs","title":"<code>knobs = knobs</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.knobs_bounds","title":"<code>knobs_bounds = knobs_bounds</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.ltwt_delta_percs","title":"<code>ltwt_delta_percs = kwargs.pop('ltwt_delta_percs', np.array([0, 5, 5, 10, 10, 25]) / 100)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.ltwt_dol_per_kg_costs","title":"<code>ltwt_dol_per_kg_costs = kwargs.pop('ltwt_dol_per_kg_costs', np.array([4.41, 8.82, 13.23, 17.64, 22.05, 35.27]))</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.mooadvancedvehicle","title":"<code>mooadvancedvehicle: fastsim.vehicle.Vehicle</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.moobasevehicle","title":"<code>moobasevehicle: fastsim.vehicle.Vehicle</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.obj_list","title":"<code>obj_list = obj_list</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.opt_scenario","title":"<code>opt_scenario: run_scenario.Scenario</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.optimize_pt","title":"<code>optimize_pt = optimize_pt</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.range_overshoot_tol","title":"<code>range_overshoot_tol = kwargs.pop('range_overshoot_tol', None)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.verbose","title":"<code>verbose = verbose</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.write_tsv","title":"<code>write_tsv = kwargs.pop('write_tsv', False)</code>  <code>instance-attribute</code>","text":""},{"location":"moo/#t3co.moopack.moo.T3COProblem.__init__","title":"<code>__init__(knobs_bounds: dict, vnum: float, optimize_pt: str, obj_list: list = None, constr_list: list = None, verbose: bool = False, config: run_scenario.Config = None, do_input_validation: bool = False, **kwargs) -&gt; None</code>","text":"<p>This constructor initializes optimization input variables</p> <p>Parameters:</p> Name Type Description Default <code>knobs_bounds</code> <code>dict</code> <p>Dictionary containing knobs bounds for optimization</p> required <code>vnum</code> <code>float</code> <p>Vehicle selection number</p> required <code>optimize_pt</code> <code>str</code> <p>Vehicle powertrain type - Conv, BEV, HEV, PHEV. Defaults to gl.BEV.</p> required <code>obj_list</code> <code>list</code> <p>List of objectives. Defaults to None.</p> <code>None</code> <code>constr_list</code> <code>list</code> <p>List of constraints. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>if True, prints process steps. Defaults to False.</p> <code>False</code> <code>config</code> <code>run_scenario.Config</code> <p>T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</p> <code>None</code> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def __init__(\n    self,\n    knobs_bounds: dict,\n    vnum: float,\n    optimize_pt: str,\n    obj_list: list = None,\n    constr_list: list = None,\n    verbose: bool = False,\n    config: run_scenario.Config = None,\n    do_input_validation: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    This constructor initializes optimization input variables\n\n    Args:\n        knobs_bounds (dict): Dictionary containing knobs bounds for optimization\n        vnum (float): Vehicle selection number\n        optimize_pt (str, optional): Vehicle powertrain type - Conv, BEV, HEV, PHEV. Defaults to gl.BEV.\n        obj_list (list, optional): List of objectives. Defaults to None.\n        constr_list (list, optional): List of constraints. Defaults to None.\n        verbose (bool, optional): if True, prints process steps. Defaults to False.\n        config (run_scenario.Config, optional): T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.\n\n    \"\"\"\n    self.setup_opt_records()\n\n    # TODO there should probably not be any default values for kwargs\n\n    # TODO: figure out parallelization and then modify the following line accordingly\n    _ = kwargs.pop(\"parallelization\", None)\n\n    # possible TODO: make this a dict for grade, accel, and range tolerance\n    self.range_overshoot_tol = kwargs.pop(\"range_overshoot_tol\", None)\n    self.grade_accel_overshoot_tol = kwargs.pop(\n        \"grade_accel_overshoot_tol\", 0.01\n    )  # TODO default of 1% # user should explicitly turn this on and set this outside moo.py\n\n    # MOO optimization interpolation arrays and coefficients\n    # engine peak efficiecy percents\n    self.fc_eff_array = kwargs.pop(\n        \"fc_eff_array\", np.array([46, 46, 51, 51, 53, 53, 60]) / 100\n    )\n    # additional $ cost per kw of engine per engine efficiency percent\n    self.fc_cost_coeff_array = kwargs.pop(\n        \"fc_cost_coeff_array\", np.array([0, 0, 7, 16, 22, 40, 74])\n    )\n    # glider_kg light-weighted percents\n    self.ltwt_delta_percs = kwargs.pop(\n        \"ltwt_delta_percs\", np.array([0, 5, 5, 10, 10, 25]) / 100\n    )\n    # additional $ cost per kg light-weighted\n    self.ltwt_dol_per_kg_costs = kwargs.pop(\n        \"ltwt_dol_per_kg_costs\", np.array([4.41, 8.82, 13.23, 17.64, 22.05, 35.27])\n    )\n    # , if you want to keep default values, they should be 52.1 and 6.7\n    # To make it like what I sent before, Arthur can recalculate (should be enough decimals):\n    # a = 100*a\n    # b = 10000*b - Alicia\n    self.cda_cost_coeff_a = kwargs.pop(\"cda_cost_coeff_a\", 52.053)\n    self.cda_cost_coeff_b = kwargs.pop(\"cda_cost_coeff_b\", 6.7018)\n    self.cda_mass_coeff_a = kwargs.pop(\n        \"cda_mass_coeff_a\", 0\n    )  # default formula doesn't need a_M coeff, wt = 17967.9*p^2\n    self.cda_mass_coeff_b = kwargs.pop(\"cda_mass_coeff_b\", 1.79679)\n    self.cda_perc_imp_at_which_wt_penalty_maxes_out = kwargs.pop(\n        \"cda_perc_imp_at_which_wt_penalty_maxes_out\", 9999999999\n    )\n\n    # just checker values, knobs_bounds may not actually have all of these populated, so [0,0] is never used beyond the asserts\n    max_fc_bound = knobs_bounds.get(KNOB_FCPEAKEFF, (0, 0))[1]\n    max_ltwt_bound = knobs_bounds.get(KNOB_WTDELTAPERC, (0, 0))[1]\n    CdA_perc_imp_knob_max = knobs_bounds.get(KNOB_CDA, (0, 0))[1]\n\n    self.knobs_bounds = knobs_bounds\n\n    knobs = [key for key in knobs_bounds.keys()]\n    lower_bounds = anp.array([val[0] for bound, val in knobs_bounds.items()])\n    upper_bounds = anp.array([val[1] for bound, val in knobs_bounds.items()])\n\n    self.write_tsv = kwargs.pop(\"write_tsv\", False)\n\n    self.obj_list = obj_list\n    if obj_list is None:\n        # create default objective list\n        self.obj_list = [TCO]\n\n    self.constr_list = constr_list\n\n    # add acceleration and grade overshoot tolerance constraint implicitly if user is apply grade or acceleration constraints\n    if len(set(self.constr_list) &amp; set([ACCEL30, ACCEL60, GRADE125, GRADE6])):\n        self.constr_list.append(ACCEL_GRADE_OVERSHOOT)\n\n    n_constr = len(self.constr_list)\n    # input (f\"moo.py: T3COProblem __init__\\n{self.constr_list}, \\neffective constraints: {n_constr}\")\n    # make it so that knobs always need to be specified.\n    self.knobs = knobs\n\n    self.verbose = verbose\n\n    self.optimize_pt = optimize_pt\n\n    self.instantiate_moo_vehicles_and_scenario(vnum, config, do_input_validation)\n\n    # time dilation options, turned on for fuel efficiency cycle\n    if \"missed_trace_correction\" in kwargs:\n        self.opt_scenario.missed_trace_correction = kwargs.pop(\n            \"missed_trace_correction\"\n        )\n        self.opt_scenario.max_time_dilation = kwargs.pop(\"max_time_dilation\")\n        self.opt_scenario.min_time_dilation = kwargs.pop(\"min_time_dilation\")\n        self.opt_scenario.time_dilation_tol = kwargs.pop(\"time_dilation_tol\")\n\n    n_obj = len(self.obj_list)\n\n    n_args = len(knobs)\n\n    # asserts\n    assert (\n        self.optimize_pt == self.mooadvancedvehicle.veh_pt_type\n    ), \"instantiate_moo_vehicles_and_scenario should have handled this\"\n    for knob in self.knobs:\n        assert knob in KNOBS, f\"knob {knob} not in defined parameters: {KNOBS}\"\n    for constraint in self.constr_list:\n        assert (\n            constraint in CONSTRAINTS\n        ), f\"constraint {constraint} not in defined constraints: {CONSTRAINTS}\"\n        if constraint == PHEV_MINIMIZE_FUEL_USE_CONSTRAINT:\n            assert (\n                self.opt_scenario.constraint_phev_minimize_fuel_use_percent &gt; 0\n                and self.opt_scenario.constraint_phev_minimize_fuel_use_percent &lt; 1\n            )\n    assert len(OBJECTIVES) &gt;= 1, \"enable at least one objective\"\n    for obj in self.obj_list:\n        assert (\n            obj in OBJECTIVES\n        ), f\"objective {obj} not in defined objectives: {OBJECTIVES}\"\n    assert (\n        set(self.constr_list) &amp; set(self.obj_list) == set()\n    ), f\"cannot have constraints and objectives overlap constraints {self.constr_list} &amp; {self.obj_list}\"\n    if KNOB_fs_kwh in self.knobs:\n        assert (\n            self.optimize_pt in [gl.CONV, gl.HEV, gl.PHEV]\n        ), f\"input knob bounds: {knobs_bounds}\\naltering fuel store (tank, not battery) kwh size but vehicle powertrain to be optimized is {self.optimize_pt}\"\n    if KNOB_FCMAXKW in self.knobs:\n        assert (\n            self.optimize_pt in [gl.CONV, gl.HEV, gl.PHEV]\n        ), f\"input knob bounds: {knobs_bounds}\\naltering fuel converter size but vehicle powertrain is {self.optimize_pt}\"\n    if KNOB_ess_max_kwh in self.knobs:\n        assert (\n            self.optimize_pt in [gl.BEV, gl.HEV, gl.PHEV]\n        ), f\"input knob bounds: {knobs_bounds}\\naltering battery size but vehicle powertrain to be optimized is {self.optimize_pt}\"\n    if KNOB_mc_max_kw in self.knobs:\n        assert (\n            self.optimize_pt in [gl.BEV, gl.HEV, gl.PHEV]\n        ), f\"input knob bounds: {knobs_bounds}\\naltering motor size but vehicle powertrain to be optimized is {self.optimize_pt}\"\n    assert (\n        max_fc_bound &lt;= max(self.fc_eff_array)\n    ), f\"max eng eff knob val greater than max of eng eff array {max_fc_bound} &gt; {self.fc_eff_array}, could yield free efficiency\"\n    assert (\n        max_ltwt_bound &lt;= max(self.ltwt_delta_percs)\n    ), f\"max light-weight knob val greater than max of light-weighting percent array {max_ltwt_bound} &gt; {self.ltwt_delta_percs}, could yield free light-weighting\"\n    assert (\n        max_fc_bound &lt;= 1\n    ), f\"knob bounds must be decimal format, max_fc_bound: {max_fc_bound}\"\n    assert (\n        max_ltwt_bound &lt;= 1\n    ), f\"knob bounds must be decimal format, max_ltwt_bound: {max_ltwt_bound}\"\n    assert (\n        CdA_perc_imp_knob_max &lt;= 1\n    ), f\"knob bounds must be decimal format, CdA_perc_imp_knob_max: {CdA_perc_imp_knob_max}\"\n\n    # n_ieq_constr, number of constraints that must yield &lt; 0\n    super().__init__(\n        n_var=n_args,\n        n_obj=n_obj,\n        n_ieq_constr=n_constr,\n        # lower bounds\n        xl=lower_bounds,\n        # upper bounds\n        xu=upper_bounds,\n        **kwargs,\n    )\n\n    if len(kwargs) &gt; 0:\n        warnings.warn(\n            f\"Possible unused/invalid kwargs provided:\\n {list(kwargs.keys())}\"\n        )\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.adjust_fc_peak_eff","title":"<code>adjust_fc_peak_eff(fc_peak_eff: float, scenario: run_scenario.Scenario, optvehicle: fastsim.vehicle.Vehicle) -&gt; None</code>","text":"<p>This method augments an advanced vehicle fc_eff_array based on new fc_peak_eff using baseline fc_eff_array</p> <p>Parameters:</p> Name Type Description Default <code>fc_peak_eff</code> <code>float</code> <p>Fuel converter peak efficiency override</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>optvehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of optimization vehicle</p> required Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def adjust_fc_peak_eff(\n    self,\n    fc_peak_eff: float,\n    scenario: run_scenario.Scenario,\n    optvehicle: fastsim.vehicle.Vehicle,\n) -&gt; None:\n    \"\"\"\n    This method augments an advanced vehicle fc_eff_array based on new fc_peak_eff using baseline fc_eff_array\n\n\n    Args:\n        fc_peak_eff (float): Fuel converter peak efficiency override\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        optvehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of optimization vehicle\n    \"\"\"\n    old_peak_eff = scenario.origfc_eff_map.max()\n    optvehicle.fc_eff_map = scenario.origfc_eff_map * (\n        1 + (fc_peak_eff - old_peak_eff) / old_peak_eff\n    )\n    optvehicle.set_derived()\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.cda_percent_delta_knob","title":"<code>cda_percent_delta_knob(CdA_perc_reduction: str, optvehicle: fastsim.vehicle.Vehicle) -&gt; None</code>","text":"<p>This method sets the drag_coef based on aero improvement curve and glider_kg based on cda_cost_coeff_a and cda_cost_coeff_b</p> <p>Parameters:</p> Name Type Description Default <code>CdA_perc_reduction</code> <code>str</code> <p>Name of aero improvement curve file</p> required <code>optvehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for optimization vehicle</p> required Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def cda_percent_delta_knob(\n    self, CdA_perc_reduction: str, optvehicle: fastsim.vehicle.Vehicle\n) -&gt; None:\n    \"\"\"\n    This method sets the drag_coef based on aero improvement curve and glider_kg based on cda_cost_coeff_a and cda_cost_coeff_b\n\n    Args:\n        CdA_perc_reduction (str): Name of aero improvement curve file\n        optvehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object for optimization vehicle\n\n    \"\"\"\n\n    # check value of CdA_reduction\n    # print(CdA_perc_reduction)\n\n    # functions that return cost, weight, and possibly other penalties w.r.t. various improvements\n\n    def get_cost_per_CdA_delta(x):\n        \"\"\"\n        Returns cost penalty given percent improvement in CdA.\n        \"\"\"\n        # COST:  a * cda_perc + b * cda_perc^2\n        a_C = self.cda_cost_coeff_a\n        b_C = self.cda_cost_coeff_b\n        x = x * 100\n        return a_C * x + b_C * x**2\n\n    def get_mass_per_CdA_delta(x):\n        \"\"\"\n        Returns weight penalty [Lb converted to kg] given % improvement in CdA.\n        These formulas are developed in pounds. Converted to kg for FASTSim at the end.\n        \"\"\"\n        # MASS: a * cda_perc + b * cda_perc^2\n        a_M = (\n            self.cda_mass_coeff_a\n        )  # default formula doesn't need a_M coeff, wt = 17967.9*p^2\n        b_M = self.cda_mass_coeff_b\n        x = x * 100\n        CdA_perc_imp_at_which_wt_penalty_maxes_out = (\n            self.cda_perc_imp_at_which_wt_penalty_maxes_out\n        )\n        return min(\n            gl.lbs_to_kgs(\n                a_M * CdA_perc_imp_at_which_wt_penalty_maxes_out\n                + b_M * CdA_perc_imp_at_which_wt_penalty_maxes_out**2\n            ),\n            gl.lbs_to_kgs(a_M * x + b_M * x**2),\n        )\n\n    # reset drag coefficient based on percent improvement\n    optvehicle.drag_coef = max(\n        0.01,  # this is an additional hard-coded bound on drag coefficient that should probably be removed (throw error or warning if drag_coef &lt; 0.01 instead of running and replacing with this default value)\n        self.opt_scenario.originaldrag_coef * (1 - CdA_perc_reduction),\n    )\n    # glider cost penalty due to CdA improvement\n    CdA_cost = get_cost_per_CdA_delta(CdA_perc_reduction)\n    self.opt_scenario.vehicle_glider_cost_dol = (\n        self.opt_scenario.vehicle_glider_cost_dol + CdA_cost\n    )\n    # mass adjustments. Add CdA mass FIRST, if applicable. Then limit cargo_kg if overweight from battery.\n    optvehicle.glider_kg = optvehicle.glider_kg + get_mass_per_CdA_delta(\n        CdA_perc_reduction\n    )\n    optvehicle.set_veh_mass()\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.compile_reporting_vars","title":"<code>compile_reporting_vars() -&gt; None</code>","text":"<p>This method creates an output dictionary containing optimization results</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def compile_reporting_vars(self) -&gt; None:\n    \"\"\"\n    This method creates an output dictionary containing optimization results\n    \"\"\"\n    d = {\n        \"objective_TCOs\": self.r_tcos,\n        \"objective_fc_khw_percent\": self.r_cd_fc_kwh_percent,\n        \"objective_fc_khw_used\": self.r_cd_fc_kwh_used,\n        \"objective_elec_khw_used\": self.r_cd_elec_kwh_used,\n        \"r_mph_ach_grade_6s\": self.r_grade_6s,\n        \"r_mph_ach_grade_1p25s\": self.r_grade_1p25s,\n        \"r_sec_to_ach_30mph_ldd\": self.r_accel_30l,\n        \"r_sec_to_ach_60mph_ldd\": self.r_accel_60l,\n        \"r_ach_ranges_mi\": self.r_ranges,\n        \"target_mph_grade_6s\": [\n            self.opt_scenario.min_speed_at_6pct_grade_in_5min_mph\n        ]\n        * len(self.r_grade_6s),\n        \"target_mph_grade_1p25s\": [\n            self.opt_scenario.min_speed_at_1p25pct_grade_in_5min_mph\n        ]\n        * len(self.r_grade_6s),\n        \"target_sec_to_30mph_ldd\": [self.opt_scenario.max_time_0_to_30mph_at_gvwr_s]\n        * len(self.r_grade_6s),\n        \"target_sec_to_60mph_ldd\": [self.opt_scenario.max_time_0_to_60mph_at_gvwr_s]\n        * len(self.r_grade_6s),\n        \"target_range_mi\": [self.opt_scenario.target_range_mi]\n        * len(self.r_grade_6s),\n        \"r_ach_fuel_efficiencies\": self.r_fuel_efficiencies,\n        \"accel_30_constraint_vals\": self.accel_30_constraint,\n        \"accel_60_constraint_vals\": self.accel_60_constraint,\n        \"grade_6_constraint_vals\": self.grade_6_constraint,\n        \"grade_1p25_constraint_vals\": self.grade_1p25_constraint,\n        \"range_constraint_vals\": self.range_constraint,\n        \"grade_accel_overshoot_tol_constraint_vals\": self.grade_accel_overshoot_tol_constraint,\n        \"trace_miss_dist_percent_constraint_vals\": self.trace_miss_distance_percent_constraint_record,\n        \"phev_min_fuel_use_pct_constraint_vals\": self.phev_min_fuel_use_prcnt_const_record,\n        \"r_wt_delta_perc_guess\": self.r_wt_delta_perc_guess,\n        \"r_CdA_reduction_perc\": self.r_CdA_reduction_perc,\n        \"r_fc_peak_eff_guess\": self.r_fc_peak_eff_guess,\n        \"r_fc_max_out_kw_guess\": self.r_fc_max_out_kw_guess,\n        \"r_fs_kwh_guess\": self.r_fs_kwh_guess,\n        \"r_max_ess_kwh_guess\": self.r_max_ess_kwh_guess,\n        \"r_max_motor_kw_guess\": self.r_max_motor_kw_guess,\n    }\n    self.reporting_vars = pd.DataFrame(data=d)\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.fc_peak_eff_knob","title":"<code>fc_peak_eff_knob(fc_peak_eff: float, optvehicle: fastsim.vehicle.Vehicle) -&gt; None</code>","text":"<p>This method sets the knob from the engine efficiency curve</p> <p>Parameters:</p> Name Type Description Default <code>fc_peak_eff</code> <code>float</code> <p>Fuel converter peak effiency override from engine efficiency improvement curve</p> required <code>optvehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for optimization vehicle</p> required Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def fc_peak_eff_knob(\n    self, fc_peak_eff: float, optvehicle: fastsim.vehicle.Vehicle\n) -&gt; None:\n    \"\"\"\n    This method sets the knob from the engine efficiency curve\n\n    Args:\n        fc_peak_eff (float): Fuel converter peak effiency override from engine efficiency improvement curve\n        optvehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object for optimization vehicle\n    \"\"\"\n    fc_eff_array = self.fc_eff_array\n    cost_coeff_array = self.fc_cost_coeff_array\n    d_eff_dol_per_kw = np.interp(fc_peak_eff, fc_eff_array, cost_coeff_array)\n    self.opt_scenario.fc_ice_cost_dol_per_kw = (\n        self.opt_scenario.originalIceDolPerKw + d_eff_dol_per_kw\n    )\n    self.adjust_fc_peak_eff(fc_peak_eff, self.opt_scenario, optvehicle)\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.get_objs","title":"<code>get_objs(x: dict, write_tsv: bool = False) -&gt; Tuple[np.array, np.array, dict]</code>","text":"<p>This method gets called when PyMoo calls _evaluate. It initializes objectives and constraints and runs vehicle_scenario_sweep</p> <p>x optimization knobs = [max motor kw, battery kwh, drag coeff % improvement] Function for running FE cycles and accel tests then returning fuel consumption and zero-to-sixty times.</p> <p>x is a set of genes (or parameters), so kwh size is a gene chromosome is a full gene, all values in x</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>dict</code> <p>Dictionary containing optimization knobs - {max motor kw, battery kwh, drag coeff % improvement}</p> required <code>write_tsv</code> <code>bool</code> <p>if True, save intermediate dataframes. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>obj_arr_F</code> <code>np.array</code> <p>Array of objectives - tot_cost and phev_cd_fuel_used_kwh</p> <code>constraint_results_G</code> <code>np.array</code> <p>Array of constraints</p> <code>rs_sweep</code> <code>dict</code> <p>Output dictionary from vehicle_scenario_sweep</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def get_objs(\n    self, x: dict, write_tsv: bool = False\n) -&gt; Tuple[np.array, np.array, dict]:\n    \"\"\"\n    This method gets called when PyMoo calls _evaluate. It initializes objectives and constraints and runs vehicle_scenario_sweep\n\n    x optimization knobs = [max motor kw, battery kwh, drag coeff % improvement]\n    Function for running FE cycles and accel tests then returning\n    fuel consumption and zero-to-sixty times.\n\n    x is a set of genes (or parameters), so kwh size is a gene\n    chromosome is a full gene, all values in x\n\n    Args:\n        x (dict): Dictionary containing optimization knobs - {max motor kw, battery kwh, drag coeff % improvement}\n        write_tsv (bool, optional): if True, save intermediate dataframes. Defaults to False.\n\n    Returns:\n        obj_arr_F (np.array): Array of objectives - tot_cost and phev_cd_fuel_used_kwh\n        constraint_results_G (np.array): Array of constraints\n        rs_sweep (dict): Output dictionary from vehicle_scenario_sweep\n    \"\"\"\n\n    # dict for providing mechanism for making sure all knobs get used\n    x_dict = {knob: x[self.knobs.index(knob)] for knob in self.knobs}\n\n    # if self.optimize_pt not in [gl.CONV, gl.BEV, gl.HEV]:\n    #     raise TypeError(f\"optimize_pt is not configured for {self.optimize_pt}\")\n    designcycle = self.designcycle\n    optvehicle = self.mooadvancedvehicle\n\n    # reset glider price and weight for light-weighting and/or CdA percent improvement\n    self.opt_scenario.vehicle_glider_cost_dol = (\n        self.opt_scenario.originalGliderPrice\n    )\n    optvehicle.glider_kg = self.opt_scenario.originalglider_kg\n\n    wt_delta_perc_guess = x_dict.pop(KNOB_WTDELTAPERC, None)\n    CdA_reduction_perc = x_dict.pop(KNOB_CDA, None)\n    fc_peak_eff_guess = x_dict.pop(KNOB_FCPEAKEFF, None)\n    fc_max_out_kw_guess = x_dict.pop(KNOB_FCMAXKW, None)\n    max_ess_kwh_guess = x_dict.pop(KNOB_ess_max_kwh, None)\n    max_motor_kw_guess = x_dict.pop(KNOB_mc_max_kw, None)\n    fs_kwh_guess = x_dict.pop(KNOB_fs_kwh, None)\n    # set knobs\n    if \"wt_delta_perc\" in self.knobs:\n        # confirmed with Alicia and Jason on 8/11/2021 that light-weighting should occur before CdA adjustment\n        self.weight_delta_percent_knob(wt_delta_perc_guess, optvehicle)\n    if \"CdA_perc_imp\" in self.knobs:\n        self.cda_percent_delta_knob(CdA_reduction_perc, optvehicle)\n    if \"fc_peak_eff\" in self.knobs:\n        self.fc_peak_eff_knob(fc_peak_eff_guess, optvehicle)\n    if \"fcMaxOutKw\" in self.knobs:\n        run_scenario.set_max_fuel_converter_kw(optvehicle, fc_max_out_kw_guess)\n    if KNOB_fs_kwh in self.knobs:\n        run_scenario.set_fuel_store_kwh(optvehicle, fs_kwh_guess)\n    if \"ess_max_kwh\" in self.knobs:\n        run_scenario.set_max_battery_kwh(optvehicle, max_ess_kwh_guess)\n    if \"mc_max_kw\" in self.knobs:\n        run_scenario.set_max_motor_kw(\n            optvehicle, self.opt_scenario, max_motor_kw_guess\n        )\n\n    # enforce 0 &lt;= cargo kg &lt;= initial cargo kg for BEV and HEV optimizations\n    if self.optimize_pt in [gl.BEV, gl.HEV]:\n        run_scenario.limit_cargo_kg_for_moo_hev_bev(self.opt_scenario, optvehicle)\n\n    # # TODO, this calculation and application of payload loss is still not finalized.\n    # this also needs to be used for FCEV, would be nice if there were an FCEV veh_pt_type!!!\n    # also it needs to have a Scenario File on/off activation\n\n    assert len(x_dict) == 0, f\"Unapplied knobs: {list(x_dict.keys())}\"\n\n    # calculate objectives\n    get_accel_loaded = False\n    get_grade = False\n    obj_arr_F = []\n    g6_acvhd, g125_acvhd, z60l_acvhd, z30l_acvhd, tco_acvhd, mpgge, range_achvd = [\n        None\n    ] * 7\n    if GRADE6 in self.constr_list or GRADE125 in self.constr_list:\n        get_grade = True\n    if ACCEL30 in self.constr_list or ACCEL60 in self.constr_list:\n        get_accel_loaded = True\n\n    rs_sweep = run_scenario.vehicle_scenario_sweep(\n        optvehicle,\n        self.opt_scenario,\n        designcycle,\n        verbose=self.verbose,\n        get_accel=False,  # don't want non-loaded accel values, for now\n        get_accel_loaded=get_accel_loaded,\n        get_gradeability=get_grade,\n        write_tsv=write_tsv,\n    )\n\n    mpgge = rs_sweep[\"mpgge\"]\n    g6_acvhd, g125_acvhd = (\n        rs_sweep[\"grade_6_mph_ach\"],\n        rs_sweep[\"grade_1_25_mph_ach\"],\n    )\n    z60l_acvhd, z30l_acvhd = (\n        rs_sweep[\"zero_to_60_loaded\"],\n        rs_sweep[\"zero_to_30_loaded\"],\n    )\n    tco_acvhd = rs_sweep[\"tot_cost\"]\n    if optvehicle.veh_pt_type in [gl.BEV, gl.CONV, gl.HEV]:\n        range_achvd = rs_sweep[\"primary_fuel_range_mi\"]\n    elif optvehicle.veh_pt_type == gl.PHEV:\n        # need range from PHEV that is used to compare to target_range_mi\n        range_achvd = rs_sweep[\"cd_aer_phev_range_mi\"]\n\n    if self.verbose:\n        print(\n            f\"grade_6_mph_ach {g6_acvhd} grade_1_25_mph_ach {g125_acvhd} zero_to_60_loaded {z60l_acvhd} \"\n            f\"zero_to_30_loaded {z30l_acvhd} tco {tco_acvhd} mpgge {mpgge} range {range_achvd}\"\n        )\n\n    # PHEV fuel usage stats\n    pct_fc_kwh = None\n    phev_cd_fuel_used_kwh = None\n    phev_cd_battery_used_kwh = None\n    if (\n        PHEV_MINIMIZE_FUEL_USE_OBJECTIVE in self.obj_list\n        or PHEV_MINIMIZE_FUEL_USE_CONSTRAINT in self.constr_list\n    ):\n        phev_cd_fuel_used_kwh = rs_sweep[\"mpgge\"][\"cd_fuel_used_kwh_total\"]\n        phev_cd_battery_used_kwh = rs_sweep[\"mpgge\"][\"cd_battery_used_kwh\"]\n        pct_fc_kwh = round(\n            phev_cd_fuel_used_kwh\n            / (phev_cd_battery_used_kwh + phev_cd_fuel_used_kwh),\n            2,\n        )\n    #                                                           #\n    # ********************** objectives  ********************** #\n    #                                                           #\n    if TCO in self.obj_list:\n        obj_arr_F.append(tco_acvhd)\n    if PHEV_MINIMIZE_FUEL_USE_OBJECTIVE in self.obj_list:\n        obj_arr_F.append(phev_cd_fuel_used_kwh)\n    #                                                           #\n    # ******************** end objectives  ******************** #\n    #                                                           #\n\n    #                                                           #\n    # ********************** constraints ********************** #\n    #\n    #                                                           #\n\n    self.accel_30_constraint.append(None)\n    self.accel_60_constraint.append(None)\n    self.grade_6_constraint.append(None)\n    self.grade_1p25_constraint.append(None)\n    self.range_constraint.append(None)\n    self.grade_accel_overshoot_tol_constraint.append(None)\n    self.c_rate_constraint.append(None)\n    self.trace_miss_distance_percent_constraint_record.append(None)\n    self.phev_min_fuel_use_prcnt_const_record.append(None)\n\n    constraint_results_G = []\n    # calculate constraint violations\n    # speed at grade minus target should be negative when constraint is met\n    if GRADE6 in self.constr_list:\n        constraint_results_G.append(\n            self.opt_scenario.min_speed_at_6pct_grade_in_5min_mph - g6_acvhd\n        )\n    if GRADE125 in self.constr_list:\n        constraint_results_G.append(\n            self.opt_scenario.min_speed_at_1p25pct_grade_in_5min_mph - g125_acvhd\n        )\n    if ACCEL60 in self.constr_list:\n        # zero-to-speed time should minus max allowable (target value) should\n        # be negative when constraint is met\n        # 9 sec achvd - 10 sec target = -1\n        constraint_results_G.append(\n            z60l_acvhd - self.opt_scenario.max_time_0_to_60mph_at_gvwr_s\n        )\n    if ACCEL30 in self.constr_list:\n        constraint_results_G.append(\n            z30l_acvhd - self.opt_scenario.max_time_0_to_30mph_at_gvwr_s\n        )\n\n    # calculate limiting grade/accel requirement if all constraints met\n    if ACCEL_GRADE_OVERSHOOT in self.constr_list:\n        constr_perc = {}\n        if GRADE125 in self.constr_list:\n            # todo, -abs() for all of these?\n            g125c = (\n                -(\n                    g125_acvhd\n                    - self.opt_scenario.min_speed_at_1p25pct_grade_in_5min_mph\n                )\n                / self.opt_scenario.min_speed_at_1p25pct_grade_in_5min_mph\n            )\n            constr_perc[GRADE125] = g125c\n            self.grade_1p25_constraint[-1] = g125c\n        if GRADE6 in self.constr_list:\n            g6c = (\n                -(g6_acvhd - self.opt_scenario.min_speed_at_6pct_grade_in_5min_mph)\n                / self.opt_scenario.min_speed_at_6pct_grade_in_5min_mph\n            )\n            constr_perc[GRADE6] = g6c\n            self.grade_6_constraint[-1] = g6c\n        if ACCEL60 in self.constr_list:\n            z60c = (\n                z60l_acvhd - self.opt_scenario.max_time_0_to_60mph_at_gvwr_s\n            ) / self.opt_scenario.max_time_0_to_60mph_at_gvwr_s\n            constr_perc[ACCEL60] = z60c\n            self.accel_60_constraint[-1] = z60c\n        if ACCEL30 in self.constr_list:\n            z30c = (\n                z30l_acvhd - self.opt_scenario.max_time_0_to_30mph_at_gvwr_s\n            ) / self.opt_scenario.max_time_0_to_30mph_at_gvwr_s\n            constr_perc[ACCEL30] = z30c\n            self.accel_30_constraint[-1] = z30c\n\n        # if all constraints meet target, then find closest overshoot and ensure it's below tolerance\n        if (len(constr_perc) &gt; 0) &amp; (\n            np.array(list(constr_perc.values())) &lt; 0\n        ).all():\n            # say largest negative percent is -.1 (closest to target, 10% exceeding)\n            # tolerance is .05\n            # -(-.1) - 0.05 = 0.05, &gt;= 0, constraint is violated. Constraints are in bounds if they return &lt; 0\n            min_grade_accel_excess = (\n                -constr_perc[max(constr_perc, key=constr_perc.get)]\n                - self.grade_accel_overshoot_tol\n            )\n        else:\n            min_grade_accel_excess = -1  # no constraint to satisfy\n        constraint_results_G.append(min_grade_accel_excess)\n        self.grade_accel_overshoot_tol_constraint[-1] = min_grade_accel_excess\n\n    if RANGE in self.constr_list:\n        # if you fall short of range target\n        if self.range_overshoot_tol is None:\n            range_mi_cv = (\n                self.opt_scenario.target_range_mi - range_achvd\n            )  # pos return, failed\n        else:\n            if range_achvd &lt;= self.opt_scenario.target_range_mi:\n                range_mi_cv = (\n                    self.opt_scenario.target_range_mi - range_achvd\n                )  # pos return, failed\n            else:\n                range_mi_cv = range_achvd - (\n                    self.opt_scenario.target_range_mi\n                    * (1 + self.range_overshoot_tol)\n                )\n\n        constraint_results_G.append(range_mi_cv)\n        self.range_constraint[-1] = range_mi_cv\n\n    # c rate constraint\n    if C_RATE in self.constr_list:\n        self.c_rate_constraint[-1] = (\n            self.mooadvancedvehicle.ess_max_kw / self.mooadvancedvehicle.ess_max_kwh\n            - np.interp(\n                self.mooadvancedvehicle.ess_max_kwh,\n                # TODO, this 2D array needs to be an input\n                [1.0, 10.0, 188.0, 660.0],  # battery sizes kwh\n                [24.0, 12.0, 2.0, 0.7],  # c rates (kw/kwh)\n            )\n        )\n        constraint_results_G.append(self.c_rate_constraint[-1])\n\n    # # trace miss constraint\n    if TRACE_MISS_DIST_PERCENT in self.constr_list:\n        assert (\n            self.opt_scenario.trace_miss_dist_percent &gt; 0\n            and self.opt_scenario.trace_miss_dist_percent &lt; 1\n        ), \"scenario file input trace_miss_dist_percent must be decimal value greater than 0 and less than 1\"\n        cycle_records = rs_sweep[\"design_cycle_sim_drive_record\"]\n        max_dist_frac_result = max(\n            sdr.trace_miss_dist_frac for sdr in cycle_records\n        )\n        # .1 -&gt; 10%\n        max_dist_frac_miss = self.opt_scenario.trace_miss_dist_percent\n        constraint_results_G.append(max_dist_frac_result - max_dist_frac_miss)\n        self.trace_miss_distance_percent_constraint_record[-1] = (\n            max_dist_frac_result - max_dist_frac_miss\n        )\n\n    if PHEV_MINIMIZE_FUEL_USE_CONSTRAINT in self.constr_list:\n        assert (\n            self.opt_scenario.constraint_phev_minimize_fuel_use_percent &gt; 0\n        ), \"scenario.constraint_phev_minimize_fuel_use_percent must be value &gt; 0 and &lt; 1\"\n        assert (\n            self.opt_scenario.constraint_phev_minimize_fuel_use_percent &lt; 1\n        ), \"scenario.constraint_phev_minimize_fuel_use_percent must be value &gt; 0 and &lt; 1\"\n        constraint_results_G.append(\n            pct_fc_kwh - self.opt_scenario.constraint_phev_minimize_fuel_use_percent\n        )\n        self.phev_min_fuel_use_prcnt_const_record[-1] = (\n            pct_fc_kwh - self.opt_scenario.constraint_phev_minimize_fuel_use_percent\n        )\n\n    #                                                           #\n    # ******************** end constraints ******************** #\n    #                                                           #\n\n    # append reporting variables\n    # obj vars\n    self.r_tcos.append(tco_acvhd)\n    self.r_cd_fc_kwh_percent.append(pct_fc_kwh)\n    self.r_cd_fc_kwh_used.append(phev_cd_fuel_used_kwh)\n    self.r_cd_elec_kwh_used.append(phev_cd_battery_used_kwh)\n\n    self.r_grade_6s.append(g6_acvhd)\n    self.r_grade_1p25s.append(g125_acvhd)\n    self.r_accel_60l.append(z60l_acvhd)\n    self.r_accel_30l.append(z30l_acvhd)\n    self.r_fuel_efficiencies.append(mpgge)\n    self.r_ranges.append(range_achvd)\n    self.r_wt_delta_perc_guess.append(wt_delta_perc_guess)\n    self.r_CdA_reduction_perc.append(CdA_reduction_perc)\n    self.r_fc_peak_eff_guess.append(fc_peak_eff_guess)\n    self.r_fc_max_out_kw_guess.append(fc_max_out_kw_guess)\n    self.r_fs_kwh_guess.append(fs_kwh_guess)\n    self.r_max_ess_kwh_guess.append(max_ess_kwh_guess)\n    self.r_max_motor_kw_guess.append(max_motor_kw_guess)\n\n    return np.array(obj_arr_F), np.array(constraint_results_G), rs_sweep\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.get_tco_from_moo_advanced_result","title":"<code>get_tco_from_moo_advanced_result(x: dict) -&gt; dict</code>","text":"<p>This method is a utility function to get detailed TCO information from optimized MOO result</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>dict</code> <p>Dictionary containing optimization knobs - [max motor kw, battery kwh, drag coeff % improvement]</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>dict</code> <p>Dictionary containing TCO results for optimization runs</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def get_tco_from_moo_advanced_result(self, x: dict) -&gt; dict:\n    \"\"\"\n    This method is a utility function to get detailed TCO information from optimized MOO result\n\n    Args:\n        x (dict): Dictionary containing optimization knobs - [max motor kw, battery kwh, drag coeff % improvement]\n\n    Returns:\n        out (dict): Dictionary containing TCO results for optimization runs\n    \"\"\"\n    x_dict = {knob: x[self.knobs.index(knob)] for knob in self.knobs}\n    wt_delta_perc_guess = x_dict.pop(KNOB_WTDELTAPERC, None)\n    CdA_reduction_perc = x_dict.pop(KNOB_CDA, None)\n    fc_peak_eff_guess = x_dict.pop(KNOB_FCPEAKEFF, None)\n    fc_max_out_kw_guess = x_dict.pop(KNOB_FCMAXKW, None)\n    max_ess_kwh_guess = x_dict.pop(KNOB_ess_max_kwh, None)\n    max_motor_kw_guess = x_dict.pop(KNOB_mc_max_kw, None)\n    fs_kwh_guess = x_dict.pop(KNOB_fs_kwh, None)\n\n    print(\"MOO Final Solution:\")\n    if wt_delta_perc_guess is not None:\n        print(KNOB_WTDELTAPERC.rjust(20, \" \"), f\":{round(wt_delta_perc_guess, 4)}\")\n    if CdA_reduction_perc is not None:\n        print(KNOB_CDA.rjust(20, \" \"), f\":{round(CdA_reduction_perc, 4)}\")\n    if fc_peak_eff_guess is not None:\n        print(KNOB_FCPEAKEFF.rjust(20, \" \"), f\":{round(fc_peak_eff_guess, 4)}\")\n    if fc_max_out_kw_guess is not None:\n        print(KNOB_FCMAXKW.rjust(20, \" \"), f\":{round(fc_max_out_kw_guess, 4)}\")\n    if max_ess_kwh_guess is not None:\n        print(KNOB_ess_max_kwh.rjust(20, \" \"), f\":{round(max_ess_kwh_guess, 4)}\")\n    if max_motor_kw_guess is not None:\n        print(KNOB_mc_max_kw.rjust(20, \" \"), f\":{round(max_motor_kw_guess, 4)}\")\n    if fs_kwh_guess is not None:\n        print(KNOB_fs_kwh.rjust(20, \" \"), f\":{round(fs_kwh_guess, 4)}\")\n\n    _, _, out = self.get_objs(x, write_tsv=False)\n\n    return out\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.instantiate_moo_vehicles_and_scenario","title":"<code>instantiate_moo_vehicles_and_scenario(vnum: int, config: run_scenario.Config = None, do_input_validation: bool = False) -&gt; None</code>","text":"<p>This method instantiates the multi-objective optimization problem vehicles and scenarios, starting with the baseline Conventional vehicle.</p> <p>Parameters:</p> Name Type Description Default <code>vnum</code> <code>int</code> <p>vehicle selection number</p> required <code>config</code> <code>run_scenario.Config</code> <p>T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>Invalid optimize_pt selection</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def instantiate_moo_vehicles_and_scenario(\n    self,\n    vnum: int,\n    config: run_scenario.Config = None,\n    do_input_validation: bool = False,\n) -&gt; None:\n    \"\"\"\n    This method instantiates the multi-objective optimization problem vehicles and scenarios, starting with the baseline Conventional vehicle.\n\n    Args:\n        vnum (int): vehicle selection number\n        config (run_scenario.Config, optional): T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.\n\n    Raises:\n        TypeError: Invalid optimize_pt selection\n    \"\"\"\n    self.moobasevehicle = run_scenario.get_vehicle(\n        vnum,\n        veh_input_path=config.vehicle_file,\n    )\n\n    self.opt_scenario, self.designcycle = run_scenario.get_scenario_and_cycle(\n        vnum,\n        config.scenario_file,\n        config=config,\n        do_input_validation=do_input_validation,\n    )\n\n    if (\n        self.opt_scenario.fuel_type == \"diesel and electricity\"\n        and self.moobasevehicle.veh_pt_type == gl.HEV\n    ):\n        self.opt_scenario.fuel_type = \"diesel\"\n\n    # save baseline values for optimization diffs\n    self.opt_scenario.originalGliderPrice = (\n        self.opt_scenario.vehicle_glider_cost_dol\n    )\n    self.opt_scenario.originalglider_kg = self.moobasevehicle.glider_kg\n    self.opt_scenario.originalIceDolPerKw = self.opt_scenario.fc_ice_cost_dol_per_kw\n    self.opt_scenario.origfc_eff_map = self.moobasevehicle.fc_eff_map.copy()\n    self.opt_scenario.originalcargo_kg = self.moobasevehicle.cargo_kg\n    self.opt_scenario.originaldrag_coef = self.moobasevehicle.drag_coef\n\n    self.mooadvancedvehicle = copy.copy(self.moobasevehicle)\n\n    if self.optimize_pt == gl.BEV:\n        self.mooadvancedvehicle.veh_pt_type = gl.BEV\n        run_scenario.set_max_fuel_converter_kw(self.mooadvancedvehicle, 0)\n        # change to 0, based on Excel version direction when trying to run as EV\n        self.mooadvancedvehicle.fc_max_out_kw = 0\n        run_scenario.set_fuel_store_kwh(self.mooadvancedvehicle, 0)\n    elif self.optimize_pt == gl.CONV:\n        self.mooadvancedvehicle.veh_pt_type = gl.CONV\n        run_scenario.set_max_motor_kw(\n            self.mooadvancedvehicle, scenario=None, max_motor_kw=0\n        )\n        run_scenario.set_max_battery_kwh(self.mooadvancedvehicle, max_ess_kwh=0)\n    elif self.optimize_pt == gl.HEV:\n        self.mooadvancedvehicle.veh_pt_type = gl.HEV\n        # nothing to zero out for HEV/FCEV\n    elif self.optimize_pt == gl.PHEV:\n        self.mooadvancedvehicle.veh_pt_type = gl.PHEV\n    else:\n        raise TypeError(f\"invalid optimize_pt selection {self.optimize_pt}\")\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.setup_opt_records","title":"<code>setup_opt_records()</code>","text":"<p>This method sets up the empty optimization record arrays</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def setup_opt_records(self):\n    \"\"\"\n    This method sets up the empty optimization record arrays\n    \"\"\"\n    #\n\n    # objectives\n    self.r_tcos = []\n    self.r_cd_fc_kwh_percent = []\n    self.r_cd_fc_kwh_used = []\n    self.r_cd_elec_kwh_used = []\n\n    self.reporting_vars = None\n    self.r_grade_6s = []\n    self.r_grade_1p25s = []\n    self.r_accel_30l = []\n    self.r_accel_60l = []\n    self.r_ranges = []\n    self.r_fuel_efficiencies = []\n    self.r_wt_delta_perc_guess = []\n    self.r_CdA_reduction_perc = []\n    self.r_fc_peak_eff_guess = []\n    self.r_fc_max_out_kw_guess = []\n    self.r_fs_kwh_guess = []\n    self.r_max_ess_kwh_guess = []\n    self.r_max_motor_kw_guess = []\n    # constraint records\n    self.accel_30_constraint = []\n    self.accel_60_constraint = []\n    self.grade_6_constraint = []\n    self.grade_1p25_constraint = []\n    self.range_constraint = []\n    self.grade_accel_overshoot_tol_constraint = []\n    self.c_rate_constraint = []\n    self.trace_miss_distance_percent_constraint_record = []\n    self.phev_min_fuel_use_prcnt_const_record = []\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.sweep_knob","title":"<code>sweep_knob(knob: list, definition: int = 100, plot: bool = False, optres: float = None, **kwargs) -&gt; list</code>","text":"<p>This method sweeps the optimization knob of vehicle from lbound to ubound, return TCO             plot optres to see if there's agreement from opt solution and your sweep</p> <p>Parameters:</p> Name Type Description Default <code>knob</code> <code>list</code> <p>list of knobs names for optimization</p> required <code>definition</code> <code>int</code> <p>Number of points. Defaults to 100.</p> <code>100</code> <code>plot</code> <code>bool</code> <p>if True, saves plot of bounds and TCOs. Defaults to False.</p> <code>False</code> <code>optres</code> <code>float</code> <p>Optimization resolution. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tcos</code> <code>list</code> <p>List of TCOs of length=definition</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def sweep_knob(\n    self,\n    knob: list,\n    definition: int = 100,\n    plot: bool = False,\n    optres: float = None,\n    **kwargs,\n) -&gt; list:\n    \"\"\"\n    This method sweeps the optimization knob of vehicle from lbound to ubound, return TCO \\\n        plot optres to see if there's agreement from opt solution and your sweep\n\n    Args:\n        knob (list): list of knobs names for optimization\n        definition (int, optional): Number of points. Defaults to 100.\n        plot (bool, optional): if True, saves plot of bounds and TCOs. Defaults to False.\n        optres (float, optional): Optimization resolution. Defaults to None.\n\n    Returns:\n        tcos (list): List of TCOs of length=definition\n    \"\"\"\n    label = kwargs.get(\"label\", \"\")\n    sweep_knob_accel_test = kwargs.get(\"sweep_knob_accel_test\", False)\n    # save knobs and obj list\n    temp_obj_list = self.obj_list\n    self.knobs = [knob]\n    self.obj_list = [TCO]\n    lbound, ubound = self.knobs_bounds[knob]\n    tcos = [self.get_objs([x])[0] for x in np.linspace(lbound, ubound, definition)]\n\n    if sweep_knob_accel_test:\n        opt_res_kw = np.inf\n        if optres is not None:\n            opt_res_kw = optres\n        assert knob in [KNOB_mc_max_kw, KNOB_FCMAXKW]\n        self.obj_list = [ACCEL30, ACCEL60]\n        # objs.extend([z60l, z30l]) {(60, 30),...(60, 30)}\n        thirty_mph_times = []\n        sixty_mph_times = []\n        largest_infeasible_30s_size = None\n        failed_30_s_time = None\n        largest_infeasible_60s_size = None\n        failed_60_s_time = None\n        for x in np.linspace(lbound, ubound, definition):\n            z60l, z30l = self.get_objs([x])\n            thirty_mph_times.append([z30l, x])\n            sixty_mph_times.append([z60l, x])\n        for res in sixty_mph_times:\n            z60l, x = res\n            if (\n                z60l &gt; self.opt_scenario.max_time_0_to_60mph_at_gvwr_s\n                and x &lt; opt_res_kw\n            ):\n                largest_infeasible_60s_size = x\n                failed_60_s_time = z60l\n        for res in sixty_mph_times:\n            z30l, x = res\n            if (\n                z30l &gt; self.opt_scenario.max_time_0_to_30mph_at_gvwr_s\n                and x &lt; opt_res_kw\n            ):\n                largest_infeasible_30s_size = x\n                failed_30_s_time = z30l\n\n    # todo, figure out how to get mpgge in the other y axis\n    if plot:\n        resdir = gl.MOO_KNOB_SWEEP_PLOTS_DIR\n        if not resdir.exists():\n            resdir.mkdir()\n        ts = strftime(\"%Y-%m-%d_%H-%M-%S\", gmtime())\n        plt.figure(figsize=(7, 4))\n        plt.ylabel(\"$TCO\")\n        plt.title(f\"{label}_{ts}_{knob}\")\n        plt.xlabel(f\"knob value for {definition} pts\")\n        plt.plot(\n            np.linspace(lbound, ubound, definition),\n            tcos,\n            label=f\"TCO from global optimum, sweeping {knob}\",\n        )\n        if optres is not None:\n            plt.vlines(\n                optres,\n                min(tcos),\n                max(tcos),\n                color=\"red\",\n                label=f\"MOO {knob} solution: {optres}\",\n            )\n        if sweep_knob_accel_test:\n            if largest_infeasible_30s_size is not None:\n                plt.vlines(\n                    largest_infeasible_30s_size,\n                    min(tcos),\n                    max(tcos),\n                    color=\"orange\",\n                    label=f\"failed accel test 0 to 30 res: {failed_30_s_time} target: {self.opt_scenario.max_time_0_to_30mph_at_gvwr_s} {knob} size: {largest_infeasible_30s_size}\",\n                )\n            if largest_infeasible_60s_size is not None:\n                plt.vlines(\n                    largest_infeasible_60s_size,\n                    min(tcos),\n                    max(tcos),\n                    color=\"yellow\",\n                    label=f\"failed accel test 0 to 60 res: {failed_60_s_time} target: {self.opt_scenario.max_time_0_to_60mph_at_gvwr_s} {knob} size: {largest_infeasible_30s_size}\",\n                )\n        plt.legend()\n        plt.savefig(resdir / f\"{knob}_{label}_{ts}.png\")\n        print(f\"saving {knob} results to \", resdir)\n        plt.show()\n    self.knobs = self.knobs_bounds.keys()\n    self.obj_list = temp_obj_list\n    return tcos\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.T3COProblem.weight_delta_percent_knob","title":"<code>weight_delta_percent_knob(wt_perc_reduction: float, optvehicle: fastsim.vehicle.Vehicle) -&gt; None</code>","text":"<p>This method sets the knob from the lightweighting curve</p> <p>Parameters:</p> Name Type Description Default <code>wt_perc_reduction</code> <code>float</code> <p>Weight reduction percentage value from lightweighting curve</p> required <code>optvehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of the optimization vehicle</p> required Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def weight_delta_percent_knob(\n    self, wt_perc_reduction: float, optvehicle: fastsim.vehicle.Vehicle\n) -&gt; None:\n    \"\"\"\n    This method sets the knob from the lightweighting curve\n\n    Args:\n        wt_perc_reduction (float): Weight reduction percentage value from lightweighting curve\n        optvehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of the optimization vehicle\n    \"\"\"\n    wt_delta_cost_per_kg = np.interp(\n        x=wt_perc_reduction, xp=self.ltwt_delta_percs, fp=self.ltwt_dol_per_kg_costs\n    )\n    wt_delta_kg = optvehicle.glider_kg * wt_perc_reduction\n    # Calculate lightweight cost from curve as an integral\n    x_new = (\n        self.ltwt_delta_percs[self.ltwt_delta_percs &lt;= wt_perc_reduction]\n        * optvehicle.glider_kg\n    )\n    y_new = self.ltwt_dol_per_kg_costs[self.ltwt_delta_percs &lt;= wt_perc_reduction]\n    if wt_delta_kg not in x_new:\n        x_new = np.append(x_new, wt_delta_kg)\n        y_new = np.append(y_new, wt_delta_cost_per_kg)\n    self.opt_scenario.vehicle_glider_cost_dol = (\n        self.opt_scenario.vehicle_glider_cost_dol + np.trapz(y_new, x_new)\n    )\n    optvehicle.glider_kg = optvehicle.glider_kg - wt_delta_kg\n    optvehicle.set_veh_mass()\n</code></pre>"},{"location":"moo/#t3co.moopack.moo.run_optimization","title":"<code>run_optimization(pop_size: int, n_max_gen: int, knobs_bounds: dict, vnum: int, x_tol: float, f_tol: float, nth_gen: int, n_last: int, algo: str, obj_list: list = None, config: run_scenario.Config = None, do_input_validation=True, **kwargs) -&gt; Tuple[pymoo.core.result.Result, T3COProblem, bool]</code>","text":"<p>This method creates and runs T3COProblem minimization</p> <p>Parameters:</p> Name Type Description Default <code>pop_size</code> <code>int</code> <p>Population size for optimization</p> required <code>n_max_gen</code> <code>int</code> <p>maximum number of generations for optimization</p> required <code>knobs_bounds</code> <code>dict</code> <p>Dictionary containing knobs and bounds</p> required <code>vnum</code> <code>int</code> <p>vehicle selection number</p> required <code>x_tol</code> <code>float</code> <p>tolerance in parameter space</p> required <code>f_tol</code> <code>float</code> <p>tolerance in objective space</p> required <code>nth_gen</code> <code>int</code> <p>number of generations to evaluate if convergence occurs</p> required <code>n_last</code> <code>int</code> <p>number of generations to look back for termination</p> required <code>algo</code> <code>str</code> <p>algorithm name</p> required <code>obj_list</code> <code>list</code> <p>list of objectives - TCO or PHEV_MINIMIZE_FUEL_USE_OBJECTIVE. Defaults to None.</p> <code>None</code> <code>config</code> <code>run_scenario.Config</code> <p>T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>res</code> <code>pymoo.core.result.Result</code> <p>Pymoo optimization result object</p> <code>problem</code> <code>moo.T3COProblem</code> <p>T3COProblem ElementwiseProblem object</p> <code>OPTIMIZATION_SUCCEEDED</code> <code>bool</code> <p>if True, pymoo.minimize succeeded</p> Source code in <code>t3co/moopack/moo.py</code> Python<pre><code>def run_optimization(\n    pop_size: int,\n    n_max_gen: int,\n    knobs_bounds: dict,\n    vnum: int,\n    x_tol: float,\n    f_tol: float,\n    nth_gen: int,\n    n_last: int,\n    algo: str,\n    obj_list: list = None,\n    config: run_scenario.Config = None,\n    do_input_validation=True,\n    **kwargs,\n) -&gt; Tuple[pymoo.core.result.Result, T3COProblem, bool]:\n    \"\"\"\n    This method creates and runs T3COProblem minimization\n\n    Args:\n        pop_size (int): Population size for optimization\n        n_max_gen (int): maximum number of generations for optimization\n        knobs_bounds (dict): Dictionary containing knobs and bounds\n        vnum (int): vehicle selection number\n        x_tol (float): tolerance in parameter space\n        f_tol (float): tolerance in objective space\n        nth_gen (int): number of generations to evaluate if convergence occurs\n        n_last (int): number of generations to look back for termination\n        algo (str): algorithm name\n        obj_list (list, optional): list of objectives - TCO or PHEV_MINIMIZE_FUEL_USE_OBJECTIVE. Defaults to None.\n        config (run_scenario.Config, optional): T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.\n\n    Returns:\n        res (pymoo.core.result.Result): Pymoo optimization result object\n        problem (moo.T3COProblem): T3COProblem ElementwiseProblem object\n        OPTIMIZATION_SUCCEEDED (bool): if True, pymoo.minimize succeeded\n    \"\"\"\n\n    verbose = kwargs.pop(\"verbose\", False)\n    optimize_pt = kwargs.pop(\"optimize_pt\")\n    return_least_infeasible = kwargs.pop(\"optimize_pt\", False)\n    skip_optimization = kwargs.pop(\"skip_optimization\", False)\n\n    if verbose:\n        print(\"Running optimization.\")\n\n    if verbose:\n        print(knobs_bounds)\n\n    problem = T3COProblem(\n        parallelization=(\"threads\", 1),\n        knobs_bounds=knobs_bounds,\n        vnum=vnum,\n        obj_list=obj_list,\n        optimize_pt=optimize_pt,\n        verbose=verbose,\n        config=config,\n        do_input_validation=do_input_validation,\n        **kwargs,\n    )\n\n    if skip_optimization:\n        return None, problem, None, None\n\n    print(\n        f\"moo.run_optimization algo {algo}, x_tol {x_tol}, f_tol {f_tol}, nth_gen {nth_gen}, n_last {n_last}, n_max_gen {n_max_gen}, pop_size {pop_size}\"\n    )\n\n    assert (\n        algo in ALGORITHMS\n    ), f\"{algo} not in T3CO list of optimization algorithms {str(ALGORITHMS)}\"\n\n    if algo == ALGO_NSGA2:\n        algorithm = NSGA2(\n            pop_size=pop_size,\n            eliminate_duplicates=True,\n            # sampling=get_sampling(kwargs.pop('sampling', 'real_lhs'))\n            sampling=kwargs.pop(\"sampling\", LHS()),\n        )\n    elif algo == ALGO_NelderMead:\n        print(\"moo.run_optimization Nelder Mead\")\n        algorithm = NelderMead()\n    elif algo == ALGO_PatternSearch:\n        print(\"moo.run_optimization PatternSearch\")\n        algorithm = PatternSearch()\n    elif algo == ALGO_PSO:\n        print(\"moo.run_optimization Particle Swarm\")\n        algorithm = PSO()\n    # elif algo == 'LocalSearch':\n    #     print('moo.run_optimization LocalSearch')\n    #     algorithm = LocalSearch()\n    t0 = time.time()\n\n    termination = MODT(\n        xtol=x_tol,\n        ftol=f_tol,\n        # n_last=n_last, these are expected in MODT... which is weird bc the docs seem to say it is\n        # nth_gen=nth_gen,\n        n_max_gen=n_max_gen,\n        n_max_evals=None,\n    )\n\n    # this check no longer works now that kwargs are pass to T3COProblem and dict types are immutable\n    # assert len(kwargs) == 0, f'Invalid kwargs: {list(kwargs.keys())}'\n    try:\n        res = minimize(\n            problem,\n            algorithm,\n            termination=termination,\n            seed=1,\n            verbose=True,\n            save_history=True,\n            return_least_infeasible=return_least_infeasible,\n            #    display=T3CODisplay()\n        )\n    except Exception:\n        logging.exception(\n            f\"moo.run_optimization: Optimization errored out for algorithm {algo}\"\n        )\n        res, problem = None, None\n        return res, problem, EXCEPTION_THROWN\n\n    t1 = time.time()\n    print(f\"\\nElapsed time for optimization: {t1 - t0} s\")\n    if verbose:\n        print(\"\\nParameter pareto sets:\")\n    if res.X is None:\n        print(\"moo.run_optimization: moo failed to converge\")\n        return res, problem, OPTIMIZATION_FAILED_TO_CONVERGE\n\n    # res.X holds results of optimization\n    # successful optimization could be 1D (one solution)\n    # [1.0, 2.0, 3.0, 4.0, 5.0]\n    # or nD, multiple solutions on a pareto front\n    # [[1.0, 2.0, 3.0, 4.0, 5.0],\n    # [ 6.0, 7.0, 8.0, 9.0, 10.0],\n    # [ 11.0,12.0,13.0,14.0,15.0]]\n    return res, problem, OPTIMIZATION_SUCCEEDED\n</code></pre>"},{"location":"opportunity_cost/","title":"Opportunity Costs Sub-Module","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost","title":"<code>t3co.tco.opportunity_cost</code>","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.oc","title":"<code>oc = main()</code>  <code>module-attribute</code>","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost","title":"<code>OpportunityCost</code>","text":"<p>This class is used to calculate the different opportunity costs for a scenario and vehicle - Payload Capacity Cost Multiplier - Fueling Downtime Cost - Maintenance and Repair Downtime Cost</p> Source code in <code>t3co/tco/opportunity_cost.py</code> Python<pre><code>class OpportunityCost:\n    \"\"\"\n    This class is used to calculate the different opportunity costs for a scenario and vehicle\n    - Payload Capacity Cost Multiplier\n    - Fueling Downtime Cost\n    - Maintenance and Repair Downtime Cost\n    \"\"\"\n\n    def __init__(\n        self, scenario: run_scenario.Scenario, range_dict: dict = None, **kwargs\n    ) -&gt; None:\n        \"\"\"\n        Initializes OpportunityCost object using Scenario object, range_dict (from fueleconomy module), and other arguments\n\n        Args:\n            scenario (run_scenario.Scenario): Scenario object\n            range_dict (dict, optional): dictionary containing primary_fuel_range_mi from fueleconomy.get_range_mi function. Defaults to None.\n        \"\"\"\n\n        self.payload_cap_cost_multiplier = None\n\n        if range_dict:\n            self.total_range_mi = range_dict[\"primary_fuel_range_mi\"]\n        else:\n            self.total_range_mi = scenario.target_range_mi\n\n        if scenario.activate_tco_fueling_dwell_time_cost:\n            self.frac_of_fullcharge_bounds = list(\n                np.float_(scenario.fdt_frac_full_charge_bounds.strip(\" ][\").split(\",\"))\n            )\n            if (\n                \"0\" in str(scenario.shifts_per_year)\n                or np.isnan(scenario.shifts_per_year)\n            ) and scenario.constant_trip_distance_mi:\n                self.shifts_per_year = [\n                    round(scenario.vmt[i] / scenario.constant_trip_distance_mi)\n                    for i in range(scenario.vehicle_life_yr)\n                ]\n            else:\n                self.shifts_per_year = ast.literal_eval(scenario.shifts_per_year)\n\n        self.payload_cap_cost_multiplier = 0\n\n        if len(kwargs) &gt; 0:\n            warnings.warn(f\"Invalid kwargs: {list(kwargs.keys())}\")\n\n        # weight distribution file to load\n        self.wt_dist_file = kwargs.pop(\n            \"wt_dist_file\",\n            Path(os.path.abspath(__file__)).parents[1]\n            / \"resources\"\n            / \"auxiliary\"\n            / \"tractorweightvars.csv\",\n        )\n        self.df_veh_wt = pd.read_csv(self.wt_dist_file, index_col=0)\n\n    def set_kdes(\n        self,\n        scenario: run_scenario.Scenario,\n        bw_method: float = 0.15,\n        verbose: bool = False,\n    ) -&gt; None:\n        \"\"\"\n        This method sets tje kde kernel. This is time-consuming, only call this once, if possible.\n\n        Args:\n            scenario (run_scenario.Scenario): Scenario object\n            bw_method (float, optional):  kernel bandwidth method used by guassian_kde. Defaults to .15.\n            verbose (bool, optional): if True, prints process sets. Defaults to False.\n        \"\"\"\n\n        if verbose:\n            print(\"Initializing kernels.\")\n\n        self.df_veh_wt = self.df_veh_wt[~self.df_veh_wt[\"WEIGHTAVG\"].isnull()]\n        self.df_veh_wt = self.df_veh_wt[~self.df_veh_wt[\"WEIGHTEMPTY\"].isnull()]\n        self.df_veh_wt = self.df_veh_wt[self.df_veh_wt[\"WEIGHTAVG\"] &lt; 120000]\n\n        weights = self.df_veh_wt[\"TAB_MILES\"] / np.nansum(self.df_veh_wt[\"TAB_MILES\"])\n        kernel = gaussian_kde(\n            self.df_veh_wt[\"WEIGHTAVG\"], weights=weights, bw_method=bw_method\n        )\n        self.vehicle_weights_bins_lb = np.linspace(\n            self.df_veh_wt[\"WEIGHTAVG\"].min(), self.df_veh_wt[\"WEIGHTAVG\"].max(), 1000\n        )\n        self.vehicle_weights_bins_kg = gl.lbs_to_kgs(self.vehicle_weights_bins_lb)\n\n        # get probability of each vehicle weight\n        self.p_of_weights = kernel(self.vehicle_weights_bins_lb)\n\n        probability_payload = pd.DataFrame(\n            [self.vehicle_weights_bins_kg, self.p_of_weights],\n            index=[\"vehicle_weights_bins_kg\", \"p_of_weights\"],\n        ).T\n        probability_payload.to_csv(\n            Path(self.wt_dist_file).parents[0] / \"payload_pdf.csv\"\n        )\n        normalization_factor = probability_payload[\n            probability_payload[\"vehicle_weights_bins_kg\"].between(\n                scenario.plf_ref_veh_empty_mass_kg, scenario.gvwr_kg\n            )\n        ][\"p_of_weights\"].sum()\n        self.p_of_weights_normalized = self.p_of_weights / normalization_factor\n\n    def set_payload_loss_factor(\n        self,\n        a_vehicle: fastsim.vehicle.Vehicle,\n        scenario: run_scenario.Scenario,\n        plots: bool = False,\n        plots_dir: str = None,\n    ) -&gt; None:\n        \"\"\"\n        This method runs teh kernel density estimation function set_kdes and calculates the payload capacity loss factor (payload_cap_cost_multiplier) \\\n            of the new vehicle compared to a conventional vehicle's reference empty weight.\n\n        Args:\n            a_vehicle (fastsim.vehicle): FASTSim vehicle object of the analysis vehicle\n            scenario (run_scenario.Scenario): Scenario object of current selection\n            plots (bool, optional): if True, creates histogram of KDE weight bins. Defaults to False.\n            plots_dir (str, optional): output diretory for saving plot figure. Defaults to None.\n        \"\"\"\n        self.set_kdes(scenario, verbose=False)\n\n        new_empty_weight_kg = a_vehicle.veh_kg - a_vehicle.cargo_kg\n        empty_increase_kg = new_empty_weight_kg - scenario.plf_ref_veh_empty_mass_kg\n        new_cargo_cieling_kg = (\n            scenario.gvwr_kg - empty_increase_kg + scenario.gvwr_credit_kg\n        )\n\n        # determine indices where lost cargo capacity is bounded in vehicle_weights\n        # and get the corresponding indices for p_of_weights\n        # based on current vehicle's new_cargo_cieling_lb and base_vehicle_gvwr_lb\n\n        if empty_increase_kg &gt;= scenario.gvwr_credit_kg:\n            a = self.vehicle_weights_bins_kg - new_cargo_cieling_kg\n            # print(a)\n            minidx = (\n                np.where(\n                    self.vehicle_weights_bins_kg == a[a &gt; 0][0] + new_cargo_cieling_kg\n                )\n            )[0][0]\n            a = self.vehicle_weights_bins_kg - scenario.gvwr_kg\n            maxidx = (\n                np.where(self.vehicle_weights_bins_kg == a[a &gt; 0][0] + scenario.gvwr_kg)\n            )[0][0]\n\n            estimated_lost_payload_per_bin_kg = self.p_of_weights_normalized[\n                minidx:maxidx\n            ] * (self.vehicle_weights_bins_kg[minidx:maxidx] - new_cargo_cieling_kg)\n            estimated_lost_payload_kg = np.trapz(estimated_lost_payload_per_bin_kg)\n\n            # payload cost multiplier\n            self.payload_cap_cost_multiplier = 1 + estimated_lost_payload_kg / (\n                scenario.gvwr_kg - new_empty_weight_kg + scenario.gvwr_credit_kg\n            )\n\n            scenario.estimated_lost_payload_kg = estimated_lost_payload_kg\n        else:\n            self.payload_cap_cost_multiplier = 1\n        # recording final report data on vehicle empty weights and cargo capcities\n        scenario.plf_scenario_vehicle_empty_kg = new_empty_weight_kg\n        scenario.plf_reference_vehicle_cargo_capacity_kg = (\n            scenario.gvwr_kg - scenario.plf_ref_veh_empty_mass_kg\n        )\n        scenario.plf_scenario_vehicle_cargo_capacity_kg = (\n            scenario.gvwr_kg + scenario.gvwr_credit_kg - new_empty_weight_kg\n        )\n\n        def make_plots(save_dir: str = None) -&gt; None:\n            \"\"\"\n            This function generates a histogram of the payload KDE weight distribution\n\n            Args:\n                save_dir (str, optional): Output directory path to save plot figure. Defaults to None.\n            \"\"\"\n            if save_dir and not Path(save_dir).exists():\n                save_dir.mkdir()\n\n            fig, ax = plt.subplots(figsize=(9, 6))\n            ax.hist(\n                gl.lbs_to_kgs(self.df_veh_wt[\"WEIGHTAVG\"]),\n                bins=50,\n                label=\"WEIGHTAVG: operating weight [kg]\",\n            )\n            ax2 = ax.twinx()\n            ax2.plot(\n                self.vehicle_weights_bins_kg,\n                self.p_of_weights,\n                color=\"red\",\n                linewidth=3,\n                label=\"KDE\",\n            )\n            ax2.fill_between(\n                x=self.vehicle_weights_bins_kg[minidx:maxidx],\n                y1=self.p_of_weights[minidx:maxidx],\n                y2=[0] * len(self.p_of_weights[minidx:maxidx]),\n                color=\"red\",\n                alpha=0.3,\n                label=f\"estimated cargo lost [kg]: {round(estimated_lost_payload_kg)}\",\n            )\n            ax2.axvline(\n                scenario.gvwr_kg,\n                label=f\"GVWR [kg] {round(scenario.gvwr_kg)}\",\n                color=\"orange\",\n            )\n            ax2.axvline(\n                new_cargo_cieling_kg,\n                label=f\"GVWR + credit - empty weight increase [kg] : {round(scenario.gvwr_kg)} + {round(scenario.gvwr_credit_kg)}  - {round(empty_increase_kg)} = {round(new_cargo_cieling_kg)}\",\n                color=\"purple\",\n            )\n            fig.suptitle(\n                f\"payload cost multiplier: {round(self.payload_cap_cost_multiplier,2)}\"\n            )\n            fig.legend()\n            plt.show()\n\n        if plots:\n            make_plots(plots_dir)\n\n    def set_fueling_dwell_time_cost(\n        self, a_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n    ) -&gt; None:\n        \"\"\"\n        This function calculates the fueling dwell time cost for a vehicle based on fuel fill rate/charging power and shifts_per_year\n\n        Args:\n            a_vehicle (fastsim.vehicle): FASTSim vehicle object of analysis vehicle\n            scenario (run_scenario.Scenario): Scenario object for current selection\n        \"\"\"\n        self.total_fueling_dwell_time_hr = 0\n        self.net_fueling_dwell_time_hr_per_yr = []\n        self.fueling_downtime_oppy_cost_dol_per_yr = []\n        self.fueling_dwell_labor_cost_dol_per_yr = []\n        dwellparams = np.array(\n            [\n                scenario.fdt_dwpt_fraction_power_pct,\n                scenario.fdt_frac_full_charge_bounds,\n                scenario.fdt_avg_overhead_hr_per_dwell_hr,\n                scenario.downtime_oppy_cost_dol_per_hr,\n            ]\n        )\n        assert any(\n            dwellparams\n        ), f\"Missing parameters in {str(dwellparams)}: {np.isnan(dwellparams)}\"\n\n        if a_vehicle.veh_pt_type in [\"BEV\"]:\n            self.full_dwell_hr = (1 - scenario.fdt_dwpt_fraction_power_pct) * (\n                a_vehicle.ess_max_kwh / scenario.ess_max_charging_power_kw\n            )\n        elif a_vehicle.veh_pt_type in [\"Conv\"]:\n            if scenario.fuel_type in [\"gasoline\"]:\n                self.full_dwell_hr = (\n                    a_vehicle.fs_kwh\n                    / (gl.kwh_per_gge)\n                    / scenario.fs_fueling_rate_gasoline_gpm\n                ) / 60\n            else:\n                self.full_dwell_hr = (\n                    a_vehicle.fs_kwh\n                    / (gl.kwh_per_gge / gl.DieselGalPerGasGal)\n                    / scenario.fs_fueling_rate_diesel_gpm\n                ) / 60\n        else:\n            self.full_dwell_hr = (\n                (1 - scenario.fdt_dwpt_fraction_power_pct)\n                * (\n                    a_vehicle.fs_kwh\n                    / (gl.kwh_per_gge / gl.kgH2_per_gge)\n                    / scenario.fs_fueling_rate_kg_per_min\n                )\n                / 60\n            )\n\n        for i in range(scenario.vehicle_life_yr):\n            self.d_trip_mi = scenario.vmt[i] / self.shifts_per_year[i]\n            self.num_of_dwells = max(\n                0,\n                (\n                    (self.d_trip_mi)\n                    * (1 - scenario.fdt_dwpt_fraction_power_pct)\n                    / self.total_range_mi\n                    - scenario.fdt_num_free_dwell_trips\n                ),\n            )\n\n            if self.num_of_dwells != 0:\n                self.remaining_dwells = self.num_of_dwells % 1\n                if self.remaining_dwells &lt; self.frac_of_fullcharge_bounds[0]:\n                    self.num_of_dwells += (\n                        self.frac_of_fullcharge_bounds[0] - self.remaining_dwells\n                    )\n                elif (\n                    self.frac_of_fullcharge_bounds[0]\n                    &lt; self.remaining_dwells\n                    &lt; self.frac_of_fullcharge_bounds[1]\n                ):\n                    self.num_of_dwells += 0\n                else:\n                    self.num_of_dwells += 1 - self.remaining_dwells\n\n            if (self.num_of_dwells &lt; 1 and not scenario.fdt_num_free_dwell_trips) or (\n                scenario.fuel_type\n            ):\n                self.net_fueling_dwell_time_hr_per_yr.append(\n                    scenario.vmt[i]\n                    * (1 - scenario.fdt_dwpt_fraction_power_pct)\n                    / self.total_range_mi\n                    * (self.full_dwell_hr + scenario.fdt_avg_overhead_hr_per_dwell_hr)\n                )\n            else:\n                self.dwell_time_hr = (\n                    self.num_of_dwells * self.full_dwell_hr\n                    + ceil(self.num_of_dwells)\n                    * scenario.fdt_avg_overhead_hr_per_dwell_hr\n                )\n                self.net_fueling_dwell_time_hr_per_yr.append(\n                    self.shifts_per_year[i]\n                    * max(\n                        0,\n                        (\n                            self.dwell_time_hr\n                            - max(0, scenario.fdt_available_freetime_hr)\n                        ),\n                    )\n                )\n\n            self.fueling_dwell_labor_cost_dol_per_yr.append(\n                self.net_fueling_dwell_time_hr_per_yr[i]\n                * scenario.labor_rate_dol_per_hr\n            )\n            self.fueling_downtime_oppy_cost_dol_per_yr.append(\n                self.net_fueling_dwell_time_hr_per_yr[i]\n                * scenario.downtime_oppy_cost_dol_per_hr\n            )\n\n            self.total_fueling_dwell_time_hr += self.net_fueling_dwell_time_hr_per_yr[i]\n\n    def set_M_R_downtime_cost(\n        self, a_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n    ) -&gt; None:\n        \"\"\"\n        This function calculates the Maintenance and Repair (M&amp;R) downtime cost based on planned, unplanned, and tire replacement downtime inputs\n\n        Args:\n            a_vehicle (fastsim.vehicle): FASTSim object of the analysis vehicle\n            scenario (run_scenario.Scenario): Scenario object for the current selection\n        \"\"\"\n        self.planned_downtime_hr = [\n            scenario.mr_planned_downtime_hr_per_yr\n            for _ in range(scenario.vehicle_life_yr)\n        ]  # regular maintenance and inspections\n        self.unplanned_downtime_hr = [\n            scenario.mr_unplanned_downtime_hr_per_mi[i] * scenario.vmt[i]\n            for i in range(scenario.vehicle_life_yr)\n        ]  # increases with age\n        self.tire_replacement_downtime_hr = [\n            (scenario.vmt[i])\n            / scenario.mr_avg_tire_life_mi\n            * scenario.mr_tire_replace_downtime_hr_per_event\n            for i in range(scenario.vehicle_life_yr)\n        ]\n        self.net_net_mr_downtime_hr_per_yr_per_yr = np.array(\n            [\n                self.planned_downtime_hr[i]\n                + self.unplanned_downtime_hr[i]\n                + self.tire_replacement_downtime_hr[i]\n                for i in range(scenario.vehicle_life_yr)\n            ]\n        )\n        self.mr_downtime_oppy_cost_dol_per_yr = (\n            self.net_net_mr_downtime_hr_per_yr_per_yr\n            * scenario.downtime_oppy_cost_dol_per_hr\n        )\n</code></pre>"},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.df_veh_wt","title":"<code>df_veh_wt = pd.read_csv(self.wt_dist_file, index_col=0)</code>  <code>instance-attribute</code>","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.frac_of_fullcharge_bounds","title":"<code>frac_of_fullcharge_bounds = list(np.float_(scenario.fdt_frac_full_charge_bounds.strip(' ][').split(',')))</code>  <code>instance-attribute</code>","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.payload_cap_cost_multiplier","title":"<code>payload_cap_cost_multiplier = 0</code>  <code>instance-attribute</code>","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.shifts_per_year","title":"<code>shifts_per_year = [round(scenario.vmt[i] / scenario.constant_trip_distance_mi) for i in range(scenario.vehicle_life_yr)]</code>  <code>instance-attribute</code>","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.total_range_mi","title":"<code>total_range_mi = range_dict['primary_fuel_range_mi']</code>  <code>instance-attribute</code>","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.wt_dist_file","title":"<code>wt_dist_file = kwargs.pop('wt_dist_file', Path(os.path.abspath(__file__)).parents[1] / 'resources' / 'auxiliary' / 'tractorweightvars.csv')</code>  <code>instance-attribute</code>","text":""},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.__init__","title":"<code>__init__(scenario: run_scenario.Scenario, range_dict: dict = None, **kwargs) -&gt; None</code>","text":"<p>Initializes OpportunityCost object using Scenario object, range_dict (from fueleconomy module), and other arguments</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object</p> required <code>range_dict</code> <code>dict</code> <p>dictionary containing primary_fuel_range_mi from fueleconomy.get_range_mi function. Defaults to None.</p> <code>None</code> Source code in <code>t3co/tco/opportunity_cost.py</code> Python<pre><code>def __init__(\n    self, scenario: run_scenario.Scenario, range_dict: dict = None, **kwargs\n) -&gt; None:\n    \"\"\"\n    Initializes OpportunityCost object using Scenario object, range_dict (from fueleconomy module), and other arguments\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object\n        range_dict (dict, optional): dictionary containing primary_fuel_range_mi from fueleconomy.get_range_mi function. Defaults to None.\n    \"\"\"\n\n    self.payload_cap_cost_multiplier = None\n\n    if range_dict:\n        self.total_range_mi = range_dict[\"primary_fuel_range_mi\"]\n    else:\n        self.total_range_mi = scenario.target_range_mi\n\n    if scenario.activate_tco_fueling_dwell_time_cost:\n        self.frac_of_fullcharge_bounds = list(\n            np.float_(scenario.fdt_frac_full_charge_bounds.strip(\" ][\").split(\",\"))\n        )\n        if (\n            \"0\" in str(scenario.shifts_per_year)\n            or np.isnan(scenario.shifts_per_year)\n        ) and scenario.constant_trip_distance_mi:\n            self.shifts_per_year = [\n                round(scenario.vmt[i] / scenario.constant_trip_distance_mi)\n                for i in range(scenario.vehicle_life_yr)\n            ]\n        else:\n            self.shifts_per_year = ast.literal_eval(scenario.shifts_per_year)\n\n    self.payload_cap_cost_multiplier = 0\n\n    if len(kwargs) &gt; 0:\n        warnings.warn(f\"Invalid kwargs: {list(kwargs.keys())}\")\n\n    # weight distribution file to load\n    self.wt_dist_file = kwargs.pop(\n        \"wt_dist_file\",\n        Path(os.path.abspath(__file__)).parents[1]\n        / \"resources\"\n        / \"auxiliary\"\n        / \"tractorweightvars.csv\",\n    )\n    self.df_veh_wt = pd.read_csv(self.wt_dist_file, index_col=0)\n</code></pre>"},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.set_M_R_downtime_cost","title":"<code>set_M_R_downtime_cost(a_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario) -&gt; None</code>","text":"<p>This function calculates the Maintenance and Repair (M&amp;R) downtime cost based on planned, unplanned, and tire replacement downtime inputs</p> <p>Parameters:</p> Name Type Description Default <code>a_vehicle</code> <code>fastsim.vehicle</code> <p>FASTSim object of the analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for the current selection</p> required Source code in <code>t3co/tco/opportunity_cost.py</code> Python<pre><code>def set_M_R_downtime_cost(\n    self, a_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n) -&gt; None:\n    \"\"\"\n    This function calculates the Maintenance and Repair (M&amp;R) downtime cost based on planned, unplanned, and tire replacement downtime inputs\n\n    Args:\n        a_vehicle (fastsim.vehicle): FASTSim object of the analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object for the current selection\n    \"\"\"\n    self.planned_downtime_hr = [\n        scenario.mr_planned_downtime_hr_per_yr\n        for _ in range(scenario.vehicle_life_yr)\n    ]  # regular maintenance and inspections\n    self.unplanned_downtime_hr = [\n        scenario.mr_unplanned_downtime_hr_per_mi[i] * scenario.vmt[i]\n        for i in range(scenario.vehicle_life_yr)\n    ]  # increases with age\n    self.tire_replacement_downtime_hr = [\n        (scenario.vmt[i])\n        / scenario.mr_avg_tire_life_mi\n        * scenario.mr_tire_replace_downtime_hr_per_event\n        for i in range(scenario.vehicle_life_yr)\n    ]\n    self.net_net_mr_downtime_hr_per_yr_per_yr = np.array(\n        [\n            self.planned_downtime_hr[i]\n            + self.unplanned_downtime_hr[i]\n            + self.tire_replacement_downtime_hr[i]\n            for i in range(scenario.vehicle_life_yr)\n        ]\n    )\n    self.mr_downtime_oppy_cost_dol_per_yr = (\n        self.net_net_mr_downtime_hr_per_yr_per_yr\n        * scenario.downtime_oppy_cost_dol_per_hr\n    )\n</code></pre>"},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.set_fueling_dwell_time_cost","title":"<code>set_fueling_dwell_time_cost(a_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario) -&gt; None</code>","text":"<p>This function calculates the fueling dwell time cost for a vehicle based on fuel fill rate/charging power and shifts_per_year</p> <p>Parameters:</p> Name Type Description Default <code>a_vehicle</code> <code>fastsim.vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for current selection</p> required Source code in <code>t3co/tco/opportunity_cost.py</code> Python<pre><code>def set_fueling_dwell_time_cost(\n    self, a_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n) -&gt; None:\n    \"\"\"\n    This function calculates the fueling dwell time cost for a vehicle based on fuel fill rate/charging power and shifts_per_year\n\n    Args:\n        a_vehicle (fastsim.vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object for current selection\n    \"\"\"\n    self.total_fueling_dwell_time_hr = 0\n    self.net_fueling_dwell_time_hr_per_yr = []\n    self.fueling_downtime_oppy_cost_dol_per_yr = []\n    self.fueling_dwell_labor_cost_dol_per_yr = []\n    dwellparams = np.array(\n        [\n            scenario.fdt_dwpt_fraction_power_pct,\n            scenario.fdt_frac_full_charge_bounds,\n            scenario.fdt_avg_overhead_hr_per_dwell_hr,\n            scenario.downtime_oppy_cost_dol_per_hr,\n        ]\n    )\n    assert any(\n        dwellparams\n    ), f\"Missing parameters in {str(dwellparams)}: {np.isnan(dwellparams)}\"\n\n    if a_vehicle.veh_pt_type in [\"BEV\"]:\n        self.full_dwell_hr = (1 - scenario.fdt_dwpt_fraction_power_pct) * (\n            a_vehicle.ess_max_kwh / scenario.ess_max_charging_power_kw\n        )\n    elif a_vehicle.veh_pt_type in [\"Conv\"]:\n        if scenario.fuel_type in [\"gasoline\"]:\n            self.full_dwell_hr = (\n                a_vehicle.fs_kwh\n                / (gl.kwh_per_gge)\n                / scenario.fs_fueling_rate_gasoline_gpm\n            ) / 60\n        else:\n            self.full_dwell_hr = (\n                a_vehicle.fs_kwh\n                / (gl.kwh_per_gge / gl.DieselGalPerGasGal)\n                / scenario.fs_fueling_rate_diesel_gpm\n            ) / 60\n    else:\n        self.full_dwell_hr = (\n            (1 - scenario.fdt_dwpt_fraction_power_pct)\n            * (\n                a_vehicle.fs_kwh\n                / (gl.kwh_per_gge / gl.kgH2_per_gge)\n                / scenario.fs_fueling_rate_kg_per_min\n            )\n            / 60\n        )\n\n    for i in range(scenario.vehicle_life_yr):\n        self.d_trip_mi = scenario.vmt[i] / self.shifts_per_year[i]\n        self.num_of_dwells = max(\n            0,\n            (\n                (self.d_trip_mi)\n                * (1 - scenario.fdt_dwpt_fraction_power_pct)\n                / self.total_range_mi\n                - scenario.fdt_num_free_dwell_trips\n            ),\n        )\n\n        if self.num_of_dwells != 0:\n            self.remaining_dwells = self.num_of_dwells % 1\n            if self.remaining_dwells &lt; self.frac_of_fullcharge_bounds[0]:\n                self.num_of_dwells += (\n                    self.frac_of_fullcharge_bounds[0] - self.remaining_dwells\n                )\n            elif (\n                self.frac_of_fullcharge_bounds[0]\n                &lt; self.remaining_dwells\n                &lt; self.frac_of_fullcharge_bounds[1]\n            ):\n                self.num_of_dwells += 0\n            else:\n                self.num_of_dwells += 1 - self.remaining_dwells\n\n        if (self.num_of_dwells &lt; 1 and not scenario.fdt_num_free_dwell_trips) or (\n            scenario.fuel_type\n        ):\n            self.net_fueling_dwell_time_hr_per_yr.append(\n                scenario.vmt[i]\n                * (1 - scenario.fdt_dwpt_fraction_power_pct)\n                / self.total_range_mi\n                * (self.full_dwell_hr + scenario.fdt_avg_overhead_hr_per_dwell_hr)\n            )\n        else:\n            self.dwell_time_hr = (\n                self.num_of_dwells * self.full_dwell_hr\n                + ceil(self.num_of_dwells)\n                * scenario.fdt_avg_overhead_hr_per_dwell_hr\n            )\n            self.net_fueling_dwell_time_hr_per_yr.append(\n                self.shifts_per_year[i]\n                * max(\n                    0,\n                    (\n                        self.dwell_time_hr\n                        - max(0, scenario.fdt_available_freetime_hr)\n                    ),\n                )\n            )\n\n        self.fueling_dwell_labor_cost_dol_per_yr.append(\n            self.net_fueling_dwell_time_hr_per_yr[i]\n            * scenario.labor_rate_dol_per_hr\n        )\n        self.fueling_downtime_oppy_cost_dol_per_yr.append(\n            self.net_fueling_dwell_time_hr_per_yr[i]\n            * scenario.downtime_oppy_cost_dol_per_hr\n        )\n\n        self.total_fueling_dwell_time_hr += self.net_fueling_dwell_time_hr_per_yr[i]\n</code></pre>"},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.set_kdes","title":"<code>set_kdes(scenario: run_scenario.Scenario, bw_method: float = 0.15, verbose: bool = False) -&gt; None</code>","text":"<p>This method sets tje kde kernel. This is time-consuming, only call this once, if possible.</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object</p> required <code>bw_method</code> <code>float</code> <p>kernel bandwidth method used by guassian_kde. Defaults to .15.</p> <code>0.15</code> <code>verbose</code> <code>bool</code> <p>if True, prints process sets. Defaults to False.</p> <code>False</code> Source code in <code>t3co/tco/opportunity_cost.py</code> Python<pre><code>def set_kdes(\n    self,\n    scenario: run_scenario.Scenario,\n    bw_method: float = 0.15,\n    verbose: bool = False,\n) -&gt; None:\n    \"\"\"\n    This method sets tje kde kernel. This is time-consuming, only call this once, if possible.\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object\n        bw_method (float, optional):  kernel bandwidth method used by guassian_kde. Defaults to .15.\n        verbose (bool, optional): if True, prints process sets. Defaults to False.\n    \"\"\"\n\n    if verbose:\n        print(\"Initializing kernels.\")\n\n    self.df_veh_wt = self.df_veh_wt[~self.df_veh_wt[\"WEIGHTAVG\"].isnull()]\n    self.df_veh_wt = self.df_veh_wt[~self.df_veh_wt[\"WEIGHTEMPTY\"].isnull()]\n    self.df_veh_wt = self.df_veh_wt[self.df_veh_wt[\"WEIGHTAVG\"] &lt; 120000]\n\n    weights = self.df_veh_wt[\"TAB_MILES\"] / np.nansum(self.df_veh_wt[\"TAB_MILES\"])\n    kernel = gaussian_kde(\n        self.df_veh_wt[\"WEIGHTAVG\"], weights=weights, bw_method=bw_method\n    )\n    self.vehicle_weights_bins_lb = np.linspace(\n        self.df_veh_wt[\"WEIGHTAVG\"].min(), self.df_veh_wt[\"WEIGHTAVG\"].max(), 1000\n    )\n    self.vehicle_weights_bins_kg = gl.lbs_to_kgs(self.vehicle_weights_bins_lb)\n\n    # get probability of each vehicle weight\n    self.p_of_weights = kernel(self.vehicle_weights_bins_lb)\n\n    probability_payload = pd.DataFrame(\n        [self.vehicle_weights_bins_kg, self.p_of_weights],\n        index=[\"vehicle_weights_bins_kg\", \"p_of_weights\"],\n    ).T\n    probability_payload.to_csv(\n        Path(self.wt_dist_file).parents[0] / \"payload_pdf.csv\"\n    )\n    normalization_factor = probability_payload[\n        probability_payload[\"vehicle_weights_bins_kg\"].between(\n            scenario.plf_ref_veh_empty_mass_kg, scenario.gvwr_kg\n        )\n    ][\"p_of_weights\"].sum()\n    self.p_of_weights_normalized = self.p_of_weights / normalization_factor\n</code></pre>"},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.OpportunityCost.set_payload_loss_factor","title":"<code>set_payload_loss_factor(a_vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario, plots: bool = False, plots_dir: str = None) -&gt; None</code>","text":"<p>This method runs teh kernel density estimation function set_kdes and calculates the payload capacity loss factor (payload_cap_cost_multiplier)             of the new vehicle compared to a conventional vehicle's reference empty weight.</p> <p>Parameters:</p> Name Type Description Default <code>a_vehicle</code> <code>fastsim.vehicle</code> <p>FASTSim vehicle object of the analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>plots</code> <code>bool</code> <p>if True, creates histogram of KDE weight bins. Defaults to False.</p> <code>False</code> <code>plots_dir</code> <code>str</code> <p>output diretory for saving plot figure. Defaults to None.</p> <code>None</code> Source code in <code>t3co/tco/opportunity_cost.py</code> Python<pre><code>def set_payload_loss_factor(\n    self,\n    a_vehicle: fastsim.vehicle.Vehicle,\n    scenario: run_scenario.Scenario,\n    plots: bool = False,\n    plots_dir: str = None,\n) -&gt; None:\n    \"\"\"\n    This method runs teh kernel density estimation function set_kdes and calculates the payload capacity loss factor (payload_cap_cost_multiplier) \\\n        of the new vehicle compared to a conventional vehicle's reference empty weight.\n\n    Args:\n        a_vehicle (fastsim.vehicle): FASTSim vehicle object of the analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        plots (bool, optional): if True, creates histogram of KDE weight bins. Defaults to False.\n        plots_dir (str, optional): output diretory for saving plot figure. Defaults to None.\n    \"\"\"\n    self.set_kdes(scenario, verbose=False)\n\n    new_empty_weight_kg = a_vehicle.veh_kg - a_vehicle.cargo_kg\n    empty_increase_kg = new_empty_weight_kg - scenario.plf_ref_veh_empty_mass_kg\n    new_cargo_cieling_kg = (\n        scenario.gvwr_kg - empty_increase_kg + scenario.gvwr_credit_kg\n    )\n\n    # determine indices where lost cargo capacity is bounded in vehicle_weights\n    # and get the corresponding indices for p_of_weights\n    # based on current vehicle's new_cargo_cieling_lb and base_vehicle_gvwr_lb\n\n    if empty_increase_kg &gt;= scenario.gvwr_credit_kg:\n        a = self.vehicle_weights_bins_kg - new_cargo_cieling_kg\n        # print(a)\n        minidx = (\n            np.where(\n                self.vehicle_weights_bins_kg == a[a &gt; 0][0] + new_cargo_cieling_kg\n            )\n        )[0][0]\n        a = self.vehicle_weights_bins_kg - scenario.gvwr_kg\n        maxidx = (\n            np.where(self.vehicle_weights_bins_kg == a[a &gt; 0][0] + scenario.gvwr_kg)\n        )[0][0]\n\n        estimated_lost_payload_per_bin_kg = self.p_of_weights_normalized[\n            minidx:maxidx\n        ] * (self.vehicle_weights_bins_kg[minidx:maxidx] - new_cargo_cieling_kg)\n        estimated_lost_payload_kg = np.trapz(estimated_lost_payload_per_bin_kg)\n\n        # payload cost multiplier\n        self.payload_cap_cost_multiplier = 1 + estimated_lost_payload_kg / (\n            scenario.gvwr_kg - new_empty_weight_kg + scenario.gvwr_credit_kg\n        )\n\n        scenario.estimated_lost_payload_kg = estimated_lost_payload_kg\n    else:\n        self.payload_cap_cost_multiplier = 1\n    # recording final report data on vehicle empty weights and cargo capcities\n    scenario.plf_scenario_vehicle_empty_kg = new_empty_weight_kg\n    scenario.plf_reference_vehicle_cargo_capacity_kg = (\n        scenario.gvwr_kg - scenario.plf_ref_veh_empty_mass_kg\n    )\n    scenario.plf_scenario_vehicle_cargo_capacity_kg = (\n        scenario.gvwr_kg + scenario.gvwr_credit_kg - new_empty_weight_kg\n    )\n\n    def make_plots(save_dir: str = None) -&gt; None:\n        \"\"\"\n        This function generates a histogram of the payload KDE weight distribution\n\n        Args:\n            save_dir (str, optional): Output directory path to save plot figure. Defaults to None.\n        \"\"\"\n        if save_dir and not Path(save_dir).exists():\n            save_dir.mkdir()\n\n        fig, ax = plt.subplots(figsize=(9, 6))\n        ax.hist(\n            gl.lbs_to_kgs(self.df_veh_wt[\"WEIGHTAVG\"]),\n            bins=50,\n            label=\"WEIGHTAVG: operating weight [kg]\",\n        )\n        ax2 = ax.twinx()\n        ax2.plot(\n            self.vehicle_weights_bins_kg,\n            self.p_of_weights,\n            color=\"red\",\n            linewidth=3,\n            label=\"KDE\",\n        )\n        ax2.fill_between(\n            x=self.vehicle_weights_bins_kg[minidx:maxidx],\n            y1=self.p_of_weights[minidx:maxidx],\n            y2=[0] * len(self.p_of_weights[minidx:maxidx]),\n            color=\"red\",\n            alpha=0.3,\n            label=f\"estimated cargo lost [kg]: {round(estimated_lost_payload_kg)}\",\n        )\n        ax2.axvline(\n            scenario.gvwr_kg,\n            label=f\"GVWR [kg] {round(scenario.gvwr_kg)}\",\n            color=\"orange\",\n        )\n        ax2.axvline(\n            new_cargo_cieling_kg,\n            label=f\"GVWR + credit - empty weight increase [kg] : {round(scenario.gvwr_kg)} + {round(scenario.gvwr_credit_kg)}  - {round(empty_increase_kg)} = {round(new_cargo_cieling_kg)}\",\n            color=\"purple\",\n        )\n        fig.suptitle(\n            f\"payload cost multiplier: {round(self.payload_cap_cost_multiplier,2)}\"\n        )\n        fig.legend()\n        plt.show()\n\n    if plots:\n        make_plots(plots_dir)\n</code></pre>"},{"location":"opportunity_cost/#t3co.tco.opportunity_cost.main","title":"<code>main()</code>","text":"<p>Runs the opportunity cost module as a standalone code based on input vehicles and scenarios</p> Source code in <code>t3co/tco/opportunity_cost.py</code> Python<pre><code>def main():\n    \"\"\"\n    Runs the opportunity cost module as a standalone code based on input vehicles and scenarios\n    \"\"\"\n    print(\"opportunity cost main()\")\n    vehicles_file = Path(\n        \"./resources/inputs/tda_example/TDA_FY22_vehicle_model_assumptions.csv\"\n    )\n    scenarios_file = Path(\n        \"./resources/inputs/tda_example/TDA_FY22_scenario_assumptions.csv\"\n    )\n    s, c = run_scenario.get_scenario_and_cycle(33, scenarios_file)\n    v = run_scenario.get_vehicle(33, vehicles_file)\n    oc = OpportunityCost(v, s)\n\n    print(\"GVWRlb\", gl.kg_to_lbs(s.gvwr_kg))\n    print(\"GvwrCreditlb\", gl.kg_to_lbs(s.gvwr_credit_kg))\n    print(\"veh_lb\", gl.kg_to_lbs(v.veh_kg))\n    print(\"ess_mass_lb\", gl.kg_to_lbs(v.ess_mass_kg))\n    print(\"original empty lb\", gl.kg_to_lbs(v.veh_kg - v.cargo_kg))\n    run_scenario.set_max_battery_kwh(v, v.ess_max_kwh * 2)\n    print(\"next ess_mass_lb\", gl.kg_to_lbs(v.ess_mass_kg))\n    print(\"next veh_lb\", gl.kg_to_lbs(v.veh_kg))\n\n    print(\"GVWRlb\", oc.GVWRlb)\n    print(\"gvwr_credit_lb\", oc.gvwr_credit_lb)\n    print(\"oc.base_vehicle_veh_lb\", gl.kg_to_lbs(oc.base_vehicle_veh_kg))\n    print(\"oc.base_vehicle_cargo_lb\", gl.kg_to_lbs(oc.base_vehicle_cargo_kg))\n    print(\"oc.original_empty_lb\", gl.kg_to_lbs(oc.reference_vehicle_empty_kg))\n\n    plf = oc.set_payload_loss_factor(v, plots=True)\n    print(plf)\n    oc.set_fueling_dwell_time_cost(v, s)\n    print(oc.dwell_time_cost_Dol)\n    print(oc.net_fueling_dwell_time_hr_per_yr)\n    print(oc.__dict__[\"payload_cap_cost_multiplier\"])\n    oc.set_M_R_downtime_cost(v, s)\n</code></pre>"},{"location":"quick_start/","title":"Quick Start Guide to T3CO","text":"<p>A total-cost analysis is only as good as its inputs. Generating T3CO results requires equal parts of investment in inputs gathering as it is in running the tool. To make things easier, we provide 500+ demo scenarios for the user to choose from to run T3CO.</p>"},{"location":"quick_start/#inputs","title":"Inputs","text":"<p>T3CO contains three main input files and several auxiliary files that are referenced in the main files for different purposes.</p>"},{"location":"quick_start/#vehicle-scenario-and-config","title":"Vehicle, Scenario, and Config","text":"<p>The main input files are the Vehicle, Scenario, and Config. T3CO provides users with demo input files to get started. One or more Vehicle-Scenario pair selections are necessary to run T3CO:</p> <ul> <li>Vehicle contains sets of FASTSim vehicle input parameters that define the powertrain and vehicle dynamics of the selected Vehicle-Scenario pair. Each entry in the Vehicle file is called a \"Vehicle Model\" and is referenced using <code>vehicle.selection</code> as a key. [Demo Vehicles]</li> <li>Scenario contains cost, infrastructure, and optimization related input parameters that define a certain scenario. Each entry in the Scenario file is called a \"Scenario Model\" and is referenced using <code>scenario.selection</code> as a key. [Demo Scenarios]</li> <li>Config contains easy ways to manage T3CO model settings and to save the inputs needed to run a set of selections of Vehicle-Scenario pairs. It also contains paths to various input files and some Scenario parameter overrides to be used globally on all selections. Users can also specify a path to the output directory in which T3CO results need to be saved. Each entry in the Config file refers to an \"Analysis\" and is accessed using <code>config.analysis_id</code> [Demo Analyses]</li> </ul> <p>Note that <code>scenario.selection</code> and <code>vehicle.selection</code> are expected by the tool to be the same for a chosen Vehicle-Scenario pair, i.e., a row on the Scenario file has a corresponding row on the Vehicle file with the same <code>selection</code> key. The <code>config.selections</code> attribute accepts a list of \"selection\" (that refers to both <code>scenario.selection</code> and <code>vehicle.selection</code>) and is used to fetch the desired set of inputs to run.</p>"},{"location":"quick_start/#auxiliary-inputs","title":"Auxiliary Inputs","text":"<p>The auxiliary input files in the <code>t3co/resources/auxiliary/</code> folder include <code>FuelPrices.csv</code>, <code>ResidualValues.csv</code>, <code>AeroDragImprovementCostCurve.csv</code>, <code>LightweightImprovementCostCurve.csv</code>, and <code>EngineEffImprovementCostCurve.csv</code>. These files contain important cost and model assumptions that are necessary to run different aspects of the T3CO cost models. Users can select the default auxiliary input files and choose the relevant set of assumptions. They can also add new entries to these files, or create their own auxiliary input files and mention the new paths in the Config file.</p>"},{"location":"quick_start/#running-t3co","title":"Running T3CO","text":"<p>After checking the inputs and creating/modifying an \"Analysis\" on the Config file, the next step is to execute the models. The <code>t3co/sweep.py</code> module is the main script that needs to be run to perform a TCO analysis. And the most effective way to run the sweep module is to call a specific \"Analysis\" from the Config file using the <code>config.analysis_id</code> key.</p>"},{"location":"quick_start/#running-the-sweep-module-from-a-pypi-installed-t3co","title":"Running the Sweep Module from a PyPI-installed T3CO","text":"<p>The easiest way to run the <code>t3co.sweep</code> module is to use a local copy of the demo input files. If the <code>install_t3co_demo_inputs</code> command is used to copy <code>demo_inputs</code> to your local directory after installing from PyPI, run the <code>t3co.sweep</code> module from any directory. </p> <p>Bash<pre><code>python -m t3co.sweep --analysis-id=0 --config=&lt;path/to/demo_inputs/T3COConfig.csv&gt;\n</code></pre> Point <code>--config</code> to the <code>T3COConfig.csv</code> file path and <code>--analysis-id</code> to the desired <code>config.analysis_id</code> (either an existing one or a newly added \"Analysis\" in the <code>demo_inputs/T3COConfig.csv</code> file. Default = <code>0</code>).</p>"},{"location":"quick_start/#running-sweep-module-from-a-cloned-github-repo","title":"Running Sweep Module from a Cloned Github repo","text":"<p>For running <code>config.analysis_id</code>=0 (or a user desired \"Analysis\") from the Demo Config file on a cloned GitHub repo, run these commands from the parent directory:</p> Bash<pre><code>python -m t3co.sweep --analysis-id=0\n</code></pre>"},{"location":"quick_start/#running-t3co-in-batch-mode-using-multiprocessing","title":"Running T3CO in Batch Mode (using multiprocessing)","text":"<p>The user can run T3CO in a \"Batch Mode\", which may be useful when running a large number of Vehicle-Scenario pairs or a large number of drivecycles or both. T3CO provides a demo analysis (<code>config.analysis_id</code>=3 in the sample T3COConfig.csv file) that runs the Batch Mode for a folder of multiple input drivecycles. </p> Bash<pre><code>python -m t3co.sweep --analysis-id=3 --run-multi\n</code></pre> <p>The Batch Mode allows T3CO to run parallel analyses utilizing multiple processors (or CPU cores) denoted by CLI argument <code>--n-processors</code>(defaults to 9). Adjust this number accordingly. To get the fastest run time, close other processor intensive programs running on your computer and assign <code>--n-processors</code> as one or two less than the max number of cores.</p> <p>When a folder path is provided in the T3COConfig.csv file (<code>config.drive_cycle</code>) containing \"n\" number of valid drivecycles, T3CO generates \"n\" scenarios for each Vehicle selections mentioned in <code>config.selections</code> with the <code>scenario.drive_cycle</code> populated with each of the \"n\" drivecycles. For Vehicle selection \"1\" in config.selections, the generated selection numbers are denoted by \"1_000\" for the first drivecycle, \"1_001\" for the second drivecycle, and so on.</p>"},{"location":"quick_start/#other-command-line-interface-arguments","title":"Other Command Line Interface arguments","text":"<p>Use the command below to get a list of all CLI arguments: Bash<pre><code>python -m t3co.sweep --help\n</code></pre></p> Text Only<pre><code>$ python -m t3co.sweep --help\nusage: SWEEP [-h] [--config CONFIG] [--analysis-id ANALYSIS_ID] [--vehicles VEHICLES] [--scenarios SCENARIOS] [--selections [SELECTIONS ...]] [--eng-curves ENG_CURVES] [--lw-curves LW_CURVES]\n             [--aero-curves AERO_CURVES] [--look-for LOOK_FOR] [--skip-all-opt] [--skip-input-validation] [--exclude [EXCLUDE ...]] [--algorithms [ALGORITHMS ...]] [--dst-dir DST_DIR]\n             [--dir-mark DIR_MARK] [--file-mark FILE_MARK] [--skip-save-veh] [--x-tol X_TOL] [--f-tol F_TOL] [--n-max-gen N_MAX_GEN] [--pop-size POP_SIZE] [--nth-gen NTH_GEN] [--n-last N_LAST]\n             [--range-overshoot-tol RANGE_OVERSHOOT_TOL] [---missed-trace-correction] [--max-time-dilation MAX_TIME_DILATION] [--min-time-dilation MIN_TIME_DILATION]\n             [--time-dilation-tol TIME_DILATION_TOL] [--write-tsv WRITE_TSV]\n\nThe sweep.py module is the main script to run T3CO\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --config CONFIG       Input Config file (default: ./resources/T3COConfig.csv)\n  --analysis-id ANALYSIS_ID\n                        Analysis key from input Config file - 'config.analysis_id' (default: 0)\n  --vehicles VEHICLES   Input file for Vehicle models (default: ./resources/inputs/demo/Demo_FY22_vehicle_model_assumptions.csv)\n  --scenarios SCENARIOS\n                        Input file for Scenario models (default: ./resources/inputs/demo/Demo_FY22_scenario_assumptions.csv)\n  --selections [SELECTIONS ...]\n                        Selections desired to run. Selections can be an int, or list of ints, or range expression. Ex: --selections 234 or --selections \"[234,236,238]\" or --selections \"range(234,\n                        150, 2)\" (default: None)\n  --eng-curves ENG_CURVES\n                        Input file for engine efficiency improvement cost curves (default: ./resources/auxiliary/EngineEffImprovementCostCurve.csv)\n  --lw-curves LW_CURVES\n                        Input file for lightweighting improvement cost curves (default: ./resources/auxiliary/LightweightImprovementCostCurve.csv)\n  --aero-curves AERO_CURVES\n                        Input file for aerodynamics improvement curves (default: ./resources/auxiliary/AeroDragImprovementCostCurve.csv)\n  --look-for LOOK_FOR   A string for string matching, example --look_for 'FCEV' or -look_for '[\"FCEV\", \"HEV\"]' (default: )\n  --skip-all-opt, --skopt\n                        If --skip_all_opt used, all runs skip optimization (default: False)\n  --skip-input-validation, --skiv\n                        If --skip_input_validation used, no pre-validation of inputs is run before sweep commences (default: True)\n  --exclude [EXCLUDE ...]\n                        Overrides -look_for. a string for string matching to exclude runs, example -exclude 'FCEV' or -look_for '[\"FCEV\", \"HEV\"]' (default: &gt;{-&lt;&gt;-}&lt;)\n  --algorithms [ALGORITHMS ...], --algos [ALGORITHMS ...], --algo [ALGORITHMS ...]\n                        Enter algorithm or list of algorithms, or \"ensemble\" to use all, to use for optimization: ['NSGA2', 'NelderMead', 'PatternSearch', 'PSO'] ex: -algos PatternSearch | -algos\n                        '[\"PatternSearch\", \"NSGA2\"]' | -algos \"ensemble\" (default: NSGA2)\n  --dst-dir DST_DIR     Directory to store T3CO results (default: ./results)\n  --dir-mark DIR_MARK   Name for results directory in addition to timestamp (default: )\n  --file-mark FILE_MARK\n                        Prefix to add to the result file names (default: )\n  --skip-save-veh       Toggle result vehicle model YAML file saving off (default: False)\n  --x-tol X_TOL         Parameter space tolerance for optimization (default: 0.001)\n  --f-tol F_TOL         Objective space tolerance for optimzation (default: 0.001)\n  --n-max-gen N_MAX_GEN\n                        Max number of optimizer iterations regardless of algorithm (default: 1000)\n  --pop-size POP_SIZE   population of each generation (default: 25)\n  --nth-gen NTH_GEN     Period of generations in which to evaluate if convergence happens during optimization (default: 1)\n  --n-last N_LAST       Number of generations to look back for establishing convergence during optimization (default: 5)\n  --range-overshoot-tol RANGE_OVERSHOOT_TOL\n                        Range overshoot tolerance, example '0.20' allows 20% range overshoot. Default of 'None' does not constrain overshoot. (default: None)\n  ---missed-trace-correction\n                        Activate FASTSim time-dilation to correct missed trace (default: False)\n  --max-time-dilation MAX_TIME_DILATION\n                        Maximum time dilation factor to 'catch up' with trace (default: 10)\n  --min-time-dilation MIN_TIME_DILATION\n                        Minimum time dilation to let trace 'catch up' (default: 0.1)\n  --time-dilation-tol TIME_DILATION_TOL\n                        Convergence criteria for time dilation (default: 0.001)\n  --write-tsv WRITE_TSV\n                        Boolean toggle to save intermediary .TSV cost results files (default: False)\n  --run-multi           Boolean switch to select multiprocessing version (default: False)\n  --n-processors N_PROCESSORS\n                        Number of processors to use for multiprocessing (default: 9)\n</code></pre>"},{"location":"quick_start/#t3co-results","title":"T3CO Results","text":"<p>After running the analysis, T3CO stores the results .CSV file in the directory specified by <code>config.dst_dir</code> (or the CLI argument <code>--dst-dir</code>). </p> <p>The results file includes a comprehensive list of Cost Outputs that were calculated by the various T3CO Modules. In addition to the T3CO outputs, all the Vehicle input parameters (denoted by a prefix: <code>input_vehicle_value_</code>),  Scenario input parameters(denoted by a prefix: <code>scenario_</code>), and Config parameters (denoted by a prefix: <code>config_</code>) are also present in the results file. When the optional optimization module is run, the optimized vehicle parameters are also listed ((denoted by a prefix: <code>optimized_vehicle_value_</code>)) instead of NaN values for non-optimization runs.</p>"},{"location":"quick_start/#t3co-visualization","title":"T3CO Visualization","text":"<p>The <code>t3co.visualization.charts</code> submodule is used to visualize the results CSV file that is generated after running T3CO. T3CO provides a demo file (<code>t3co.demos.visualization_demo</code>) to try out the visualization module for a sample analysis. The run_t3co function in the demo exports T3CO results as a pandas dataframe and generates the following visualization plots:</p> <ul> <li>TCO Breakdown Chart</li> </ul> <p></p> <ul> <li>Histogram Plot</li> </ul> <p></p> <ul> <li>Violin Plot</li> </ul> <p></p> <p>The user can provide other input parameters specific to each visualization method to further customize the plots.</p>"},{"location":"run_scenario/","title":"Run Scenario Sub-Module","text":""},{"location":"run_scenario/#t3co.run.run_scenario","title":"<code>t3co.run.run_scenario</code>","text":"<p>Module for loading vehicles, scenarios, running them and managing them</p>"},{"location":"run_scenario/#t3co.run.run_scenario.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>This class reads T3COConfig.csv file containing analysis attributes like vehicle and scenario paths, TCO_method, and scenario attribute overrides.</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>@dataclass\nclass Config:\n    \"\"\"\n    This class reads T3COConfig.csv file containing analysis attributes like vehicle and scenario paths, TCO_method, and scenario attribute overrides.\n\n    \"\"\"\n\n    analysis_id: int = 0\n    analysis_name: str = \"\"\n    vehicle_file: str = \"\"\n    scenario_file: str = \"\"\n    dst_dir: str = \"\"\n    resfile_suffix: str = None\n    write_tsv: bool = False\n    selections: str = \"\"\n    # selections: list = field(default_factory=list)\n    vehicle_life_yr: float = 0\n    drive_cycle: str = None\n    # Fueling\n    ess_max_charging_power_kw: float = 0\n    fs_fueling_rate_kg_per_min: float = 0\n    fs_fueling_rate_gasoline_gpm: float = 0\n    fs_fueling_rate_diesel_gpm: float = 0\n\n    TCO_method: str = \"DIRECT\"\n\n    # Optimization\n    algorithms: str = \"\"\n    lw_imp_curves: str = \"\"\n    eng_eff_imp_curves: str = \"\"\n    aero_drag_imp_curves: str = \"\"\n    lw_imp_curve_sel: str = \"\"\n    eng_eff_imp_curve_sel: str = \"\"\n    aero_drag_imp_curve_sel: str = \"\"\n    skip_all_opt: bool = True\n    constraint_range: bool = False\n    constraint_accel: bool = False\n    constraint_grade: bool = False\n    objective_tco: bool = False\n    constraint_c_rate: bool = False\n    constraint_trace_miss_dist_percent_on: bool = False\n    objective_phev_minimize_fuel_use: bool = False\n\n    # Opportunity Cost\n    activate_tco_payload_cap_cost_multiplier: bool = False\n    activate_tco_fueling_dwell_time_cost: bool = False\n    fdt_frac_full_charge_bounds: list = field(default_factory=list)\n    activate_mr_downtime_cost: bool = False\n\n    def from_file(self, filename: str, analysis_id: int) -&gt; Self:\n        \"\"\"\n        This method generates a Config dictionary from CSV file and calls Config.from_dict\n\n        Args:\n            filename (str): path of input T3CO Config file\n            analysis_id (int): analysis ID selections\n\n        Returns:\n            Self.from_dict: method that gets Config instance from config_dict\n        \"\"\"\n        filename = str(filename)\n\n        config_df = (\n            pd.read_csv(filename, index_col=\"analysis_id\")\n            .loc[analysis_id]\n            .replace({np.nan: None})\n        )\n        config_dict = config_df.to_dict()\n\n        return self.from_dict(config_dict=config_dict)\n\n    def from_dict(self, config_dict: dict) -&gt; Self:\n        \"\"\"\n        This method generates a Config instance from config_dict\n\n        Args:\n            config_dict (dict): dictionary containing fields from T3CO Config input CSV file\n\n        Returns:\n            Self: Config instance containining all values from T3CO Config CSV file\n        \"\"\"\n        try:\n            config_dict[\"selections\"] = ast.literal_eval(config_dict[\"selections\"])\n        except:  # noqa: E722\n            config_dict[\"selections\"] = int(config_dict[\"selections\"])\n        self.__dict__.update(config_dict)\n\n    def validate_analysis_id(self, filename: str, analysis_id: int = 0) -&gt; Self:\n        \"\"\"\n        This method validates that correct analysis id is input\n\n        Args:\n            filename (str): T3CO Config input CSV file path\n\n        Raises:\n            Exception: Error if analysis_id not found\n        \"\"\"\n        filename = str(filename)\n        config_df = pd.read_csv(filename)\n        print(f\"Try these analysis IDs instead: {list(config_df['analysis_id'])}\")\n        assert (\n            analysis_id in config_df[\"analysis_id\"]\n        ), \"Given analysis_id not in config input file\"\n        raise Exception\n\n    def check_drivecycles_and_create_selections(self, config_file: str | Path):\n        \"\"\"\n        This method checks if the config.drive_cycle input is a file or a folder. If a folder is provided, then it creates a list of all selections for each drivecycle in the folders as config.dc_files\n\n        Args:\n            config_file (str|Path): File path of config file\n        \"\"\"\n        self.dc_files = None\n        try:\n            if Path(self.drive_cycle).is_absolute():\n                dc_folder_path = Path(self.drive_cycle)\n            else:\n                dc_folder_path = Path(config_file).parent / self.drive_cycle\n            if not dc_folder_path.exists():\n                try:\n                    dc_folder_path = gl.OPTIMIZATION_DRIVE_CYCLES / self.drive_cycle\n                except:\n                    print(f\"Drivecycle folder does not exist: {dc_folder_path}\")\n\n            if Path(dc_folder_path).is_dir():\n                self.dc_files = [p.absolute() for p in dc_folder_path.rglob(\"*.csv\")]\n                selections_list = list(self.selections)\n                self.selections = []\n                for selection in selections_list:\n                    for i in range(len(self.dc_files)):\n                        self.selections.append(str(selection) + \"_\" + str(i).zfill(3))\n            else:\n                self.dc_files = None\n        except:\n            Exception\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.Config.TCO_method","title":"<code>TCO_method: str = 'DIRECT'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.activate_mr_downtime_cost","title":"<code>activate_mr_downtime_cost: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.activate_tco_fueling_dwell_time_cost","title":"<code>activate_tco_fueling_dwell_time_cost: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.activate_tco_payload_cap_cost_multiplier","title":"<code>activate_tco_payload_cap_cost_multiplier: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.aero_drag_imp_curve_sel","title":"<code>aero_drag_imp_curve_sel: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.aero_drag_imp_curves","title":"<code>aero_drag_imp_curves: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.algorithms","title":"<code>algorithms: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.analysis_id","title":"<code>analysis_id: int = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.analysis_name","title":"<code>analysis_name: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.constraint_accel","title":"<code>constraint_accel: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.constraint_c_rate","title":"<code>constraint_c_rate: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.constraint_grade","title":"<code>constraint_grade: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.constraint_range","title":"<code>constraint_range: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.constraint_trace_miss_dist_percent_on","title":"<code>constraint_trace_miss_dist_percent_on: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.drive_cycle","title":"<code>drive_cycle: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.dst_dir","title":"<code>dst_dir: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.eng_eff_imp_curve_sel","title":"<code>eng_eff_imp_curve_sel: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.eng_eff_imp_curves","title":"<code>eng_eff_imp_curves: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.ess_max_charging_power_kw","title":"<code>ess_max_charging_power_kw: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.fdt_frac_full_charge_bounds","title":"<code>fdt_frac_full_charge_bounds: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.fs_fueling_rate_diesel_gpm","title":"<code>fs_fueling_rate_diesel_gpm: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.fs_fueling_rate_gasoline_gpm","title":"<code>fs_fueling_rate_gasoline_gpm: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.fs_fueling_rate_kg_per_min","title":"<code>fs_fueling_rate_kg_per_min: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.lw_imp_curve_sel","title":"<code>lw_imp_curve_sel: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.lw_imp_curves","title":"<code>lw_imp_curves: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.objective_phev_minimize_fuel_use","title":"<code>objective_phev_minimize_fuel_use: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.objective_tco","title":"<code>objective_tco: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.resfile_suffix","title":"<code>resfile_suffix: str = None</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.scenario_file","title":"<code>scenario_file: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.selections","title":"<code>selections: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.skip_all_opt","title":"<code>skip_all_opt: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.vehicle_file","title":"<code>vehicle_file: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.vehicle_life_yr","title":"<code>vehicle_life_yr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.write_tsv","title":"<code>write_tsv: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.__init__","title":"<code>__init__(analysis_id: int = 0, analysis_name: str = '', vehicle_file: str = '', scenario_file: str = '', dst_dir: str = '', resfile_suffix: str = None, write_tsv: bool = False, selections: str = '', vehicle_life_yr: float = 0, drive_cycle: str = None, ess_max_charging_power_kw: float = 0, fs_fueling_rate_kg_per_min: float = 0, fs_fueling_rate_gasoline_gpm: float = 0, fs_fueling_rate_diesel_gpm: float = 0, TCO_method: str = 'DIRECT', algorithms: str = '', lw_imp_curves: str = '', eng_eff_imp_curves: str = '', aero_drag_imp_curves: str = '', lw_imp_curve_sel: str = '', eng_eff_imp_curve_sel: str = '', aero_drag_imp_curve_sel: str = '', skip_all_opt: bool = True, constraint_range: bool = False, constraint_accel: bool = False, constraint_grade: bool = False, objective_tco: bool = False, constraint_c_rate: bool = False, constraint_trace_miss_dist_percent_on: bool = False, objective_phev_minimize_fuel_use: bool = False, activate_tco_payload_cap_cost_multiplier: bool = False, activate_tco_fueling_dwell_time_cost: bool = False, fdt_frac_full_charge_bounds: list = list(), activate_mr_downtime_cost: bool = False) -&gt; None</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Config.check_drivecycles_and_create_selections","title":"<code>check_drivecycles_and_create_selections(config_file: str | Path)</code>","text":"<p>This method checks if the config.drive_cycle input is a file or a folder. If a folder is provided, then it creates a list of all selections for each drivecycle in the folders as config.dc_files</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str | Path</code> <p>File path of config file</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def check_drivecycles_and_create_selections(self, config_file: str | Path):\n    \"\"\"\n    This method checks if the config.drive_cycle input is a file or a folder. If a folder is provided, then it creates a list of all selections for each drivecycle in the folders as config.dc_files\n\n    Args:\n        config_file (str|Path): File path of config file\n    \"\"\"\n    self.dc_files = None\n    try:\n        if Path(self.drive_cycle).is_absolute():\n            dc_folder_path = Path(self.drive_cycle)\n        else:\n            dc_folder_path = Path(config_file).parent / self.drive_cycle\n        if not dc_folder_path.exists():\n            try:\n                dc_folder_path = gl.OPTIMIZATION_DRIVE_CYCLES / self.drive_cycle\n            except:\n                print(f\"Drivecycle folder does not exist: {dc_folder_path}\")\n\n        if Path(dc_folder_path).is_dir():\n            self.dc_files = [p.absolute() for p in dc_folder_path.rglob(\"*.csv\")]\n            selections_list = list(self.selections)\n            self.selections = []\n            for selection in selections_list:\n                for i in range(len(self.dc_files)):\n                    self.selections.append(str(selection) + \"_\" + str(i).zfill(3))\n        else:\n            self.dc_files = None\n    except:\n        Exception\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.Config.from_dict","title":"<code>from_dict(config_dict: dict) -&gt; Self</code>","text":"<p>This method generates a Config instance from config_dict</p> <p>Parameters:</p> Name Type Description Default <code>config_dict</code> <code>dict</code> <p>dictionary containing fields from T3CO Config input CSV file</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>Config instance containining all values from T3CO Config CSV file</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def from_dict(self, config_dict: dict) -&gt; Self:\n    \"\"\"\n    This method generates a Config instance from config_dict\n\n    Args:\n        config_dict (dict): dictionary containing fields from T3CO Config input CSV file\n\n    Returns:\n        Self: Config instance containining all values from T3CO Config CSV file\n    \"\"\"\n    try:\n        config_dict[\"selections\"] = ast.literal_eval(config_dict[\"selections\"])\n    except:  # noqa: E722\n        config_dict[\"selections\"] = int(config_dict[\"selections\"])\n    self.__dict__.update(config_dict)\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.Config.from_file","title":"<code>from_file(filename: str, analysis_id: int) -&gt; Self</code>","text":"<p>This method generates a Config dictionary from CSV file and calls Config.from_dict</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>path of input T3CO Config file</p> required <code>analysis_id</code> <code>int</code> <p>analysis ID selections</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Self.from_dict: method that gets Config instance from config_dict</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def from_file(self, filename: str, analysis_id: int) -&gt; Self:\n    \"\"\"\n    This method generates a Config dictionary from CSV file and calls Config.from_dict\n\n    Args:\n        filename (str): path of input T3CO Config file\n        analysis_id (int): analysis ID selections\n\n    Returns:\n        Self.from_dict: method that gets Config instance from config_dict\n    \"\"\"\n    filename = str(filename)\n\n    config_df = (\n        pd.read_csv(filename, index_col=\"analysis_id\")\n        .loc[analysis_id]\n        .replace({np.nan: None})\n    )\n    config_dict = config_df.to_dict()\n\n    return self.from_dict(config_dict=config_dict)\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.Config.validate_analysis_id","title":"<code>validate_analysis_id(filename: str, analysis_id: int = 0) -&gt; Self</code>","text":"<p>This method validates that correct analysis id is input</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>T3CO Config input CSV file path</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Error if analysis_id not found</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def validate_analysis_id(self, filename: str, analysis_id: int = 0) -&gt; Self:\n    \"\"\"\n    This method validates that correct analysis id is input\n\n    Args:\n        filename (str): T3CO Config input CSV file path\n\n    Raises:\n        Exception: Error if analysis_id not found\n    \"\"\"\n    filename = str(filename)\n    config_df = pd.read_csv(filename)\n    print(f\"Try these analysis IDs instead: {list(config_df['analysis_id'])}\")\n    assert (\n        analysis_id in config_df[\"analysis_id\"]\n    ), \"Given analysis_id not in config input file\"\n    raise Exception\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.Scenario","title":"<code>Scenario</code>  <code>dataclass</code>","text":"<p>Class object that contains all TCO parameters and performance target (range, grade, accel) information         for a vehicle such that performance and TCO can be computed during optimization</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>@dataclass\nclass Scenario:\n    \"\"\"\n    Class object that contains all TCO parameters and performance target (range, grade, accel) information \\\n        for a vehicle such that performance and TCO can be computed during optimization\n    \"\"\"\n\n    selection: float = 0\n    drive_cycle: str = \"\"\n    use_config: bool = True\n    vmt_reduct_per_yr: float = 0\n    vmt: list = field(default_factory=list)\n    constant_trip_distance_mi: float = 0\n    vehicle_life_yr: float = 0\n    desired_ess_replacements: float = 0\n    discount_rate_pct_per_yr: float = 0\n\n    ess_max_charging_power_kw: float = 0\n    ess_cost_dol_per_kw: float = 0\n    ess_cost_dol_per_kwh: float = 0\n    ess_base_cost_dol: float = 0\n    ess_cost_reduction_dol_per_yr: float = 0\n    ess_salvage_value_dol: float = 0\n    ess_charge_rate_kW: float = 0\n    pe_mc_cost_dol_per_kw: float = 0\n    pe_mc_base_cost_dol: float = 0\n    fc_ice_cost_dol_per_kw: float = 0\n    fc_ice_base_cost_dol: float = 0\n    fc_fuelcell_cost_dol_per_kw: float = 0\n    fs_cost_dol_per_kwh: float = 0\n    fs_h2_cost_dol_per_kwh: float = 0\n    plug_base_cost_dol: float = 0\n    markup_pct: float = 0\n    tax_rate_pct: float = 0\n    fc_cng_ice_cost_dol_per_kw: float = 0\n    fs_cng_cost_dol_per_kwh: float = 0\n    vehicle_glider_cost_dol: float = 0\n    segment_name: str = \"\"\n    gvwr_kg: float = 0\n    gvwr_credit_kg: float = 0\n    # a list of fuels, basecase fuel is singleton list\n    fuel_type: list = field(default_factory=list)\n    maint_oper_cost_dol_per_mi: list = field(default_factory=list)\n    vocation: str = \"\"\n    vehicle_class: str = \"\"\n    model_year: float = 0\n    region: str = \"\"\n    target_range_mi: float = 0\n    min_speed_at_6pct_grade_in_5min_mph: float = 0\n    min_speed_at_1p25pct_grade_in_5min_mph: float = 0\n    max_time_0_to_60mph_at_gvwr_s: float = 0\n    max_time_0_to_30mph_at_gvwr_s: float = 0\n    # TDA vars\n    lw_imp_curve_sel: str = \"\"\n    eng_eff_imp_curve_sel: str = \"\"\n    aero_drag_imp_curve_sel: str = \"\"\n    # computed vars\n    # scenario_gge_regional_temporal_fuel_price: str = \"\"\n    originalcargo_kg: float = (\n        -1.0\n    )  # if needed, should be assigned immediately after vehicle read in\n    # For adding mass from CdA during optimization. veh_kg = glider_kg + powertrainKg, where\n    # glider_kg is assigned the value of originalglider_kg + CdAKg\n    originalglider_kg: float = -1.0\n    # for adding incremental cost to glider from different CdA guesses in moo loop\n    originalGliderPrice: float = -1.0\n    # for adding percent improvemnt cost to engine efficiency when optimizing CONV\n    originalIceDolPerKw: float = -1.0\n    # for adjusting fuel converter efficiency based on new peak eff\n    origfc_eff_map: list = field(default_factory=list)\n    # for adjusting drag coefficient of vehicle\n    originaldrag_coef: float = -1\n\n    ess_init_soc_grade: float = -1.0\n    ess_init_soc_accel: float = -1.0\n\n    soc_norm_init_for_accel_pct: float = -1\n    soc_norm_init_for_grade_pct: float = -1\n\n    # fuel storage\n    fs_fueling_rate_gasoline_gpm: float = 0\n    fs_fueling_rate_diesel_gpm: float = 0\n    fs_fueling_rate_kg_per_min: float = 0\n\n    ### PHEV stuff\n    # UF for % of miles in charge depleting mode\n    phev_utility_factor_override: float = -1\n    phev_utility_factor_computed: float = -1\n    # percent (fractional) of motor power for setting kw_fc_demand_on during optimization\n    motor_power_override_kw_fc_demand_on_pct: float = -1\n\n    # This will be used to figure out the number of miles travelled before needing to charge\n    # must be greater than 0\n    shifts_per_year: list = field(default_factory=list)\n\n    missed_trace_correction: bool = False\n    max_time_dilation: float = -1\n    min_time_dilation: float = -1\n    time_dilation_tol: float = -1\n\n    #\n    ### Optimization Settings\n    #\n    skip_opt: bool = False\n    knob_min_ess_kwh: list = field(default_factory=list)\n    knob_max_ess_kwh: list = field(default_factory=list)\n    knob_min_motor_kw: list = field(default_factory=list)\n    knob_max_motor_kw: list = field(default_factory=list)\n    knob_min_fc_kw: list = field(default_factory=list)\n    knob_max_fc_kw: list = field(default_factory=list)\n    knob_min_fs_kwh: list = field(default_factory=list)\n    knob_max_fs_kwh: list = field(default_factory=list)\n    # placeholder for if max_c_rate need to be entered as parameters for each scenario\n    # c_rate_kwh_array: list = field(default_factory=list)\n    # c_rate_array: list = field(default_factory=list)\n    objective_phev_minimize_fuel_use: bool = False\n    constraint_c_rate: bool = False\n    constraint_range: bool = False\n    constraint_accel: bool = False\n    constraint_grade: bool = False\n    objective_tco: bool = False\n    constraint_trace_miss_dist_percent_on: bool = False\n    trace_miss_dist_percent: float = 0\n    constraint_phev_minimize_fuel_use_on: bool = False\n    constraint_phev_minimize_fuel_use_percent: float = 0\n\n    #\n    ### TCO Element Activations and vars\n    #\n    labor_rate_dol_per_hr: float = 0\n    downtime_oppy_cost_dol_per_hr: float = 0\n\n    # payload loss factor vars, PLF\n    activate_tco_payload_cap_cost_multiplier: bool = True\n    plf_ref_veh_empty_mass_kg: float = 0\n    plf_scenario_vehicle_empty_kg: float = 0\n    plf_reference_vehicle_cargo_capacity_kg: float = 0\n    plf_scenario_vehicle_cargo_capacity_kg: float = 0  # includes cargo credit kg\n    estimated_lost_payload_kg: float = 0\n\n    # Fueling Dwell time factors, FDT\n    activate_tco_fueling_dwell_time_cost: bool = False\n    dlf_min_charge_time_hr: float = 0\n    fdt_dwpt_fraction_power_pct: float = 0\n    fdt_avg_overhead_hr_per_dwell_hr: float = 0\n    fdt_frac_full_charge_bounds: float = 0\n    fdt_num_free_dwell_trips: float = 0\n    fdt_available_freetime_hr: float = 0\n    # Insurance factors\n    insurance_rates_pct_per_yr: list = field(default_factory=list)\n\n    # Residual Rate\n    residual_rate_pct: float = 0\n\n    # Maintenance and Repair Downtime factors MR\n    activate_mr_downtime_cost: bool = False\n    mr_planned_downtime_hr_per_yr: float = 0\n    mr_unplanned_downtime_hr_per_mi: list = field(default_factory=list)\n    mr_avg_tire_life_mi: float = 0\n    mr_tire_replace_downtime_hr_per_event: float = 0\n\n    def from_config(self, config: Config = None, verbose: bool = False) -&gt; None:\n        \"\"\"\n        This method overrides certain scenario fields if use_config is True and config object is not None\n\n        Args:\n            config (Config, optional): Config object. Defaults to None.\n\n        \"\"\"\n        fields_override = [\n            \"vehicle_life_yr\",\n            \"fs_fueling_rate_kg_per_min\",\n            \"fs_fueling_rate_gasoline_gpm\",\n            \"fs_fueling_rate_diesel_gpm\",\n            \"lw_imp_curve_sel\",\n            \"eng_eff_imp_curve_sel\",\n            \"aero_drag_imp_curve_sel\",\n            \"constraint_range\",\n            \"constraint_accel\",\n            \"constraint_grade\",\n            \"objective_tco\",\n            \"constraint_c_rate\",\n            \"constraint_trace_miss_dist_percent_on\",\n            \"objective_phev_minimize_fuel_use\",\n            \"activate_tco_payload_cap_cost_multiplier\",\n            \"activate_tco_fueling_dwell_time_cost\",\n            \"fdt_frac_full_charge_bounds\",\n            \"activate_mr_downtime_cost\",\n        ]\n        if config.dc_files == None:\n            fields_override.append(\"drive_cycle\")\n        self.fields_overriden = []\n        if self.use_config == True and config != None:\n            for field_select in fields_override:\n                if config.__dict__[field_select] != None:\n                    # and (\n                    # not self.__dict__[field_select])\n                    setattr(self, field_select, config.__getattribute__(field_select))\n                    # print(f'field: {field}, type: {type(self.__getattribute__(field))}, value: {self.__getattribute__(field)}')\n                    self.fields_overriden.append(field_select)\n            print(\n                f\"Scenario Fields overridden from config: {self.fields_overriden}\"\n            ) if verbose else None\n        else:\n            print(\n                f\"Config file not attached or scenario.use_config set to False: {config}\"\n            )\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.activate_mr_downtime_cost","title":"<code>activate_mr_downtime_cost: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.activate_tco_fueling_dwell_time_cost","title":"<code>activate_tco_fueling_dwell_time_cost: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.activate_tco_payload_cap_cost_multiplier","title":"<code>activate_tco_payload_cap_cost_multiplier: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.aero_drag_imp_curve_sel","title":"<code>aero_drag_imp_curve_sel: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.constant_trip_distance_mi","title":"<code>constant_trip_distance_mi: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.constraint_accel","title":"<code>constraint_accel: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.constraint_c_rate","title":"<code>constraint_c_rate: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.constraint_grade","title":"<code>constraint_grade: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.constraint_phev_minimize_fuel_use_on","title":"<code>constraint_phev_minimize_fuel_use_on: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.constraint_phev_minimize_fuel_use_percent","title":"<code>constraint_phev_minimize_fuel_use_percent: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.constraint_range","title":"<code>constraint_range: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.constraint_trace_miss_dist_percent_on","title":"<code>constraint_trace_miss_dist_percent_on: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.desired_ess_replacements","title":"<code>desired_ess_replacements: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.discount_rate_pct_per_yr","title":"<code>discount_rate_pct_per_yr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.dlf_min_charge_time_hr","title":"<code>dlf_min_charge_time_hr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.downtime_oppy_cost_dol_per_hr","title":"<code>downtime_oppy_cost_dol_per_hr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.drive_cycle","title":"<code>drive_cycle: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.eng_eff_imp_curve_sel","title":"<code>eng_eff_imp_curve_sel: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_base_cost_dol","title":"<code>ess_base_cost_dol: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_charge_rate_kW","title":"<code>ess_charge_rate_kW: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_cost_dol_per_kw","title":"<code>ess_cost_dol_per_kw: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_cost_dol_per_kwh","title":"<code>ess_cost_dol_per_kwh: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_cost_reduction_dol_per_yr","title":"<code>ess_cost_reduction_dol_per_yr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_init_soc_accel","title":"<code>ess_init_soc_accel: float = -1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_init_soc_grade","title":"<code>ess_init_soc_grade: float = -1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_max_charging_power_kw","title":"<code>ess_max_charging_power_kw: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.ess_salvage_value_dol","title":"<code>ess_salvage_value_dol: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.estimated_lost_payload_kg","title":"<code>estimated_lost_payload_kg: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fc_cng_ice_cost_dol_per_kw","title":"<code>fc_cng_ice_cost_dol_per_kw: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fc_fuelcell_cost_dol_per_kw","title":"<code>fc_fuelcell_cost_dol_per_kw: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fc_ice_base_cost_dol","title":"<code>fc_ice_base_cost_dol: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fc_ice_cost_dol_per_kw","title":"<code>fc_ice_cost_dol_per_kw: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fdt_available_freetime_hr","title":"<code>fdt_available_freetime_hr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fdt_avg_overhead_hr_per_dwell_hr","title":"<code>fdt_avg_overhead_hr_per_dwell_hr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fdt_dwpt_fraction_power_pct","title":"<code>fdt_dwpt_fraction_power_pct: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fdt_frac_full_charge_bounds","title":"<code>fdt_frac_full_charge_bounds: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fdt_num_free_dwell_trips","title":"<code>fdt_num_free_dwell_trips: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fs_cng_cost_dol_per_kwh","title":"<code>fs_cng_cost_dol_per_kwh: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fs_cost_dol_per_kwh","title":"<code>fs_cost_dol_per_kwh: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fs_fueling_rate_diesel_gpm","title":"<code>fs_fueling_rate_diesel_gpm: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fs_fueling_rate_gasoline_gpm","title":"<code>fs_fueling_rate_gasoline_gpm: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fs_fueling_rate_kg_per_min","title":"<code>fs_fueling_rate_kg_per_min: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fs_h2_cost_dol_per_kwh","title":"<code>fs_h2_cost_dol_per_kwh: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.fuel_type","title":"<code>fuel_type: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.gvwr_credit_kg","title":"<code>gvwr_credit_kg: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.gvwr_kg","title":"<code>gvwr_kg: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.insurance_rates_pct_per_yr","title":"<code>insurance_rates_pct_per_yr: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.knob_max_ess_kwh","title":"<code>knob_max_ess_kwh: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.knob_max_fc_kw","title":"<code>knob_max_fc_kw: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.knob_max_fs_kwh","title":"<code>knob_max_fs_kwh: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.knob_max_motor_kw","title":"<code>knob_max_motor_kw: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.knob_min_ess_kwh","title":"<code>knob_min_ess_kwh: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.knob_min_fc_kw","title":"<code>knob_min_fc_kw: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.knob_min_fs_kwh","title":"<code>knob_min_fs_kwh: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.knob_min_motor_kw","title":"<code>knob_min_motor_kw: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.labor_rate_dol_per_hr","title":"<code>labor_rate_dol_per_hr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.lw_imp_curve_sel","title":"<code>lw_imp_curve_sel: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.maint_oper_cost_dol_per_mi","title":"<code>maint_oper_cost_dol_per_mi: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.markup_pct","title":"<code>markup_pct: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.max_time_0_to_30mph_at_gvwr_s","title":"<code>max_time_0_to_30mph_at_gvwr_s: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.max_time_0_to_60mph_at_gvwr_s","title":"<code>max_time_0_to_60mph_at_gvwr_s: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.max_time_dilation","title":"<code>max_time_dilation: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.min_speed_at_1p25pct_grade_in_5min_mph","title":"<code>min_speed_at_1p25pct_grade_in_5min_mph: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.min_speed_at_6pct_grade_in_5min_mph","title":"<code>min_speed_at_6pct_grade_in_5min_mph: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.min_time_dilation","title":"<code>min_time_dilation: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.missed_trace_correction","title":"<code>missed_trace_correction: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.model_year","title":"<code>model_year: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.motor_power_override_kw_fc_demand_on_pct","title":"<code>motor_power_override_kw_fc_demand_on_pct: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.mr_avg_tire_life_mi","title":"<code>mr_avg_tire_life_mi: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.mr_planned_downtime_hr_per_yr","title":"<code>mr_planned_downtime_hr_per_yr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.mr_tire_replace_downtime_hr_per_event","title":"<code>mr_tire_replace_downtime_hr_per_event: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.mr_unplanned_downtime_hr_per_mi","title":"<code>mr_unplanned_downtime_hr_per_mi: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.objective_phev_minimize_fuel_use","title":"<code>objective_phev_minimize_fuel_use: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.objective_tco","title":"<code>objective_tco: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.origfc_eff_map","title":"<code>origfc_eff_map: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.originalGliderPrice","title":"<code>originalGliderPrice: float = -1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.originalIceDolPerKw","title":"<code>originalIceDolPerKw: float = -1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.originalcargo_kg","title":"<code>originalcargo_kg: float = -1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.originaldrag_coef","title":"<code>originaldrag_coef: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.originalglider_kg","title":"<code>originalglider_kg: float = -1.0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.pe_mc_base_cost_dol","title":"<code>pe_mc_base_cost_dol: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.pe_mc_cost_dol_per_kw","title":"<code>pe_mc_cost_dol_per_kw: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.phev_utility_factor_computed","title":"<code>phev_utility_factor_computed: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.phev_utility_factor_override","title":"<code>phev_utility_factor_override: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.plf_ref_veh_empty_mass_kg","title":"<code>plf_ref_veh_empty_mass_kg: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.plf_reference_vehicle_cargo_capacity_kg","title":"<code>plf_reference_vehicle_cargo_capacity_kg: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.plf_scenario_vehicle_cargo_capacity_kg","title":"<code>plf_scenario_vehicle_cargo_capacity_kg: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.plf_scenario_vehicle_empty_kg","title":"<code>plf_scenario_vehicle_empty_kg: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.plug_base_cost_dol","title":"<code>plug_base_cost_dol: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.region","title":"<code>region: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.residual_rate_pct","title":"<code>residual_rate_pct: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.segment_name","title":"<code>segment_name: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.selection","title":"<code>selection: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.shifts_per_year","title":"<code>shifts_per_year: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.skip_opt","title":"<code>skip_opt: bool = False</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.soc_norm_init_for_accel_pct","title":"<code>soc_norm_init_for_accel_pct: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.soc_norm_init_for_grade_pct","title":"<code>soc_norm_init_for_grade_pct: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.target_range_mi","title":"<code>target_range_mi: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.tax_rate_pct","title":"<code>tax_rate_pct: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.time_dilation_tol","title":"<code>time_dilation_tol: float = -1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.trace_miss_dist_percent","title":"<code>trace_miss_dist_percent: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.use_config","title":"<code>use_config: bool = True</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.vehicle_class","title":"<code>vehicle_class: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.vehicle_glider_cost_dol","title":"<code>vehicle_glider_cost_dol: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.vehicle_life_yr","title":"<code>vehicle_life_yr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.vmt","title":"<code>vmt: list = field(default_factory=list)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.vmt_reduct_per_yr","title":"<code>vmt_reduct_per_yr: float = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.vocation","title":"<code>vocation: str = ''</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.__init__","title":"<code>__init__(selection: float = 0, drive_cycle: str = '', use_config: bool = True, vmt_reduct_per_yr: float = 0, vmt: list = list(), constant_trip_distance_mi: float = 0, vehicle_life_yr: float = 0, desired_ess_replacements: float = 0, discount_rate_pct_per_yr: float = 0, ess_max_charging_power_kw: float = 0, ess_cost_dol_per_kw: float = 0, ess_cost_dol_per_kwh: float = 0, ess_base_cost_dol: float = 0, ess_cost_reduction_dol_per_yr: float = 0, ess_salvage_value_dol: float = 0, ess_charge_rate_kW: float = 0, pe_mc_cost_dol_per_kw: float = 0, pe_mc_base_cost_dol: float = 0, fc_ice_cost_dol_per_kw: float = 0, fc_ice_base_cost_dol: float = 0, fc_fuelcell_cost_dol_per_kw: float = 0, fs_cost_dol_per_kwh: float = 0, fs_h2_cost_dol_per_kwh: float = 0, plug_base_cost_dol: float = 0, markup_pct: float = 0, tax_rate_pct: float = 0, fc_cng_ice_cost_dol_per_kw: float = 0, fs_cng_cost_dol_per_kwh: float = 0, vehicle_glider_cost_dol: float = 0, segment_name: str = '', gvwr_kg: float = 0, gvwr_credit_kg: float = 0, fuel_type: list = list(), maint_oper_cost_dol_per_mi: list = list(), vocation: str = '', vehicle_class: str = '', model_year: float = 0, region: str = '', target_range_mi: float = 0, min_speed_at_6pct_grade_in_5min_mph: float = 0, min_speed_at_1p25pct_grade_in_5min_mph: float = 0, max_time_0_to_60mph_at_gvwr_s: float = 0, max_time_0_to_30mph_at_gvwr_s: float = 0, lw_imp_curve_sel: str = '', eng_eff_imp_curve_sel: str = '', aero_drag_imp_curve_sel: str = '', originalcargo_kg: float = -1.0, originalglider_kg: float = -1.0, originalGliderPrice: float = -1.0, originalIceDolPerKw: float = -1.0, origfc_eff_map: list = list(), originaldrag_coef: float = -1, ess_init_soc_grade: float = -1.0, ess_init_soc_accel: float = -1.0, soc_norm_init_for_accel_pct: float = -1, soc_norm_init_for_grade_pct: float = -1, fs_fueling_rate_gasoline_gpm: float = 0, fs_fueling_rate_diesel_gpm: float = 0, fs_fueling_rate_kg_per_min: float = 0, phev_utility_factor_override: float = -1, phev_utility_factor_computed: float = -1, motor_power_override_kw_fc_demand_on_pct: float = -1, shifts_per_year: list = list(), missed_trace_correction: bool = False, max_time_dilation: float = -1, min_time_dilation: float = -1, time_dilation_tol: float = -1, skip_opt: bool = False, knob_min_ess_kwh: list = list(), knob_max_ess_kwh: list = list(), knob_min_motor_kw: list = list(), knob_max_motor_kw: list = list(), knob_min_fc_kw: list = list(), knob_max_fc_kw: list = list(), knob_min_fs_kwh: list = list(), knob_max_fs_kwh: list = list(), objective_phev_minimize_fuel_use: bool = False, constraint_c_rate: bool = False, constraint_range: bool = False, constraint_accel: bool = False, constraint_grade: bool = False, objective_tco: bool = False, constraint_trace_miss_dist_percent_on: bool = False, trace_miss_dist_percent: float = 0, constraint_phev_minimize_fuel_use_on: bool = False, constraint_phev_minimize_fuel_use_percent: float = 0, labor_rate_dol_per_hr: float = 0, downtime_oppy_cost_dol_per_hr: float = 0, activate_tco_payload_cap_cost_multiplier: bool = True, plf_ref_veh_empty_mass_kg: float = 0, plf_scenario_vehicle_empty_kg: float = 0, plf_reference_vehicle_cargo_capacity_kg: float = 0, plf_scenario_vehicle_cargo_capacity_kg: float = 0, estimated_lost_payload_kg: float = 0, activate_tco_fueling_dwell_time_cost: bool = False, dlf_min_charge_time_hr: float = 0, fdt_dwpt_fraction_power_pct: float = 0, fdt_avg_overhead_hr_per_dwell_hr: float = 0, fdt_frac_full_charge_bounds: float = 0, fdt_num_free_dwell_trips: float = 0, fdt_available_freetime_hr: float = 0, insurance_rates_pct_per_yr: list = list(), residual_rate_pct: float = 0, activate_mr_downtime_cost: bool = False, mr_planned_downtime_hr_per_yr: float = 0, mr_unplanned_downtime_hr_per_mi: list = list(), mr_avg_tire_life_mi: float = 0, mr_tire_replace_downtime_hr_per_event: float = 0) -&gt; None</code>","text":""},{"location":"run_scenario/#t3co.run.run_scenario.Scenario.from_config","title":"<code>from_config(config: Config = None, verbose: bool = False) -&gt; None</code>","text":"<p>This method overrides certain scenario fields if use_config is True and config object is not None</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Config object. Defaults to None.</p> <code>None</code> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def from_config(self, config: Config = None, verbose: bool = False) -&gt; None:\n    \"\"\"\n    This method overrides certain scenario fields if use_config is True and config object is not None\n\n    Args:\n        config (Config, optional): Config object. Defaults to None.\n\n    \"\"\"\n    fields_override = [\n        \"vehicle_life_yr\",\n        \"fs_fueling_rate_kg_per_min\",\n        \"fs_fueling_rate_gasoline_gpm\",\n        \"fs_fueling_rate_diesel_gpm\",\n        \"lw_imp_curve_sel\",\n        \"eng_eff_imp_curve_sel\",\n        \"aero_drag_imp_curve_sel\",\n        \"constraint_range\",\n        \"constraint_accel\",\n        \"constraint_grade\",\n        \"objective_tco\",\n        \"constraint_c_rate\",\n        \"constraint_trace_miss_dist_percent_on\",\n        \"objective_phev_minimize_fuel_use\",\n        \"activate_tco_payload_cap_cost_multiplier\",\n        \"activate_tco_fueling_dwell_time_cost\",\n        \"fdt_frac_full_charge_bounds\",\n        \"activate_mr_downtime_cost\",\n    ]\n    if config.dc_files == None:\n        fields_override.append(\"drive_cycle\")\n    self.fields_overriden = []\n    if self.use_config == True and config != None:\n        for field_select in fields_override:\n            if config.__dict__[field_select] != None:\n                # and (\n                # not self.__dict__[field_select])\n                setattr(self, field_select, config.__getattribute__(field_select))\n                # print(f'field: {field}, type: {type(self.__getattribute__(field))}, value: {self.__getattribute__(field)}')\n                self.fields_overriden.append(field_select)\n        print(\n            f\"Scenario Fields overridden from config: {self.fields_overriden}\"\n        ) if verbose else None\n    else:\n        print(\n            f\"Config file not attached or scenario.use_config set to False: {config}\"\n        )\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.check_phev_init_socs","title":"<code>check_phev_init_socs(a_vehicle: vehicle.Vehicle, scenario: Scenario) -&gt; None</code>","text":"<p>This function checks that soc_norm_init_for_grade_pct and soc_norm_init_for_accel_pct are present only for PHEVs</p> <p>Parameters:</p> Name Type Description Default <code>a_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>scenario</code> <code>Scenario</code> <p>T3CO scenario object</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def check_phev_init_socs(a_vehicle: vehicle.Vehicle, scenario: Scenario) -&gt; None:\n    \"\"\"\n    This function checks that soc_norm_init_for_grade_pct and soc_norm_init_for_accel_pct are present only for PHEVs\n\n    Args:\n        a_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        scenario (Scenario): T3CO scenario object\n    \"\"\"\n    # these override ess_init_soc_grade and ess_init_soc_accel\n    # these should ONLY be used for PHEV, for now, until discussed for use for HEV, BEV\n    # init_soc = min_soc + (soc_norm_init_for_accel_pct * (max_soc - min_soc))\n    if (\n        np.isnan(scenario.soc_norm_init_for_grade_pct) == False\n        and scenario.soc_norm_init_for_grade_pct != -1\n    ):\n        assert (\n            a_vehicle.veh_pt_type == gl.PHEV\n        ), \"soc_norm_init_for_grade_pct only available for PHEVs\"\n        assert (\n            scenario.ess_init_soc_grade == -1\n        ), f\"INPUT ERROR, user specifed ess_init_soc_grade {scenario.ess_init_soc_grade}, &amp; soc_norm_init_for_grade_pct {scenario.soc_norm_init_for_grade_pct} for PHEV; the question of which one to use is ambiguous\"\n    if (\n        np.isnan(scenario.soc_norm_init_for_accel_pct) == False\n        and scenario.soc_norm_init_for_accel_pct != -1\n    ):\n        assert (\n            a_vehicle.veh_pt_type == gl.PHEV\n        ), \"soc_norm_init_for_accel_pct only available for PHEVs\"\n        assert (\n            scenario.ess_init_soc_accel == -1\n        ), f\"INPUT ERROR, user specifed ess_init_soc_accel {scenario.ess_init_soc_accel}, &amp; soc_norm_init_for_accel_pct {scenario.soc_norm_init_for_accel_pct} for PHEV; the question of which one to use is ambiguous\"\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.create_fastsim_vehicle","title":"<code>create_fastsim_vehicle(veh_dict: dict = None) -&gt; fastsim.vehicle.Vehicle</code>","text":"<p>This function creates and returns an empty FASTSim vehicle object with no attributes or</p> <p>Parameters:</p> Name Type Description Default <code>veh_dict</code> <code>dict</code> <p>Vehicle attributes dict. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>v</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def create_fastsim_vehicle(veh_dict: dict = None) -&gt; fastsim.vehicle.Vehicle:\n    \"\"\"\n    This function creates and returns an empty FASTSim vehicle object with no attributes or\n\n    Args:\n        veh_dict (dict, optional): Vehicle attributes dict. Defaults to None.\n\n    Returns:\n        v (fastsim.vehicle.Vehicle): FASTSim vehicle object\n    \"\"\"\n\n    if not veh_dict:\n        veh_dict = {\"DELETEME\": 0}\n    v = vehicle.Vehicle(veh_dict=veh_dict)\n    try:\n        if not veh_dict:\n            del v.DELETEME\n    except AttributeError:\n        pass\n    return v\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.get_objective_simdrive","title":"<code>get_objective_simdrive(analysis_vehicle: vehicle.Vehicle, cycle: fastsim.cycle.Cycle) -&gt; fastsim.simdrive.SimDrive</code>","text":"<p>This function obtains the SimDrive for accel and grade test</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>cycle</code> <code>fastsim.cycle.Cycle</code> <p>FASTSim Cycle object</p> required <p>Returns:</p> Name Type Description <code>sd</code> <code>fastsim.simdrive.SimDrive</code> <p>FASTSim SimDrive object containing vehicle inputs and simulation output attributes</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def get_objective_simdrive(\n    analysis_vehicle: vehicle.Vehicle, cycle: fastsim.cycle.Cycle\n) -&gt; fastsim.simdrive.SimDrive:\n    \"\"\"\n    This function obtains the SimDrive for accel and grade test\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        cycle (fastsim.cycle.Cycle): FASTSim Cycle object\n\n    Returns:\n        sd (fastsim.simdrive.SimDrive): FASTSim SimDrive object containing vehicle inputs and simulation output attributes\n    \"\"\"\n    sd = simdrive.SimDrive(cycle, analysis_vehicle)\n    sd = sd.to_rust()\n    sim_params = sd.sim_params\n    sim_params.reset_orphaned()\n    sim_params.missed_trace_correction = False\n    # accel and grade traces are not achievable for our vehicles in the way we've constructed the tests, so suppress this warning with large tolerance\n    sim_params.trace_miss_speed_mps_tol = np.inf\n    sim_params.energy_audit_error_tol = np.inf\n    sim_params.trace_miss_dist_tol = np.inf\n    sd.sim_params = sim_params\n\n    return sd\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.get_phev_util_factor","title":"<code>get_phev_util_factor(scenario: Scenario, v: fastsim.vehicle.Vehicle, mpgge: dict) -&gt; float</code>","text":"<p>This function gets the PHEV utility factor derived from the computed range of the vehicle and the operational day range computed from shifts per year and the first vmt year</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>Scenario</code> <p>T3CO scenario object</p> required <code>v</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>mpgge</code> <code>dict</code> <p>Miles per Gallon Gasoline Equivalent dictionary</p> required <p>Returns:</p> Name Type Description <code>uf</code> <code>float</code> <p>PHEV computed utility factor</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def get_phev_util_factor(\n    scenario: Scenario, v: fastsim.vehicle.Vehicle, mpgge: dict\n) -&gt; float:\n    \"\"\"\n    This function gets the PHEV utility factor derived from the computed range of the\n    vehicle and the operational day range computed from shifts per year and the first vmt year\n\n    Args:\n        scenario (Scenario): T3CO scenario object\n        v (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        mpgge (dict): Miles per Gallon Gasoline Equivalent dictionary\n\n    Returns:\n        uf (float): PHEV computed utility factor\n    \"\"\"\n    scenario.shifts_per_year = ast.literal_eval(scenario.shifts_per_year)\n\n    uf = scenario.phev_utility_factor_override\n    assert type(scenario.phev_utility_factor_override) in [\n        int,\n        float,\n    ], \"should be -1 or some float\"\n    cd_range_mi = fueleconomy.get_range_mi(mpgge, v, scenario)[\"cd_aer_phev_range_mi\"]\n\n    if uf == -1:\n        shift_range_mi = scenario.vmt[0] / scenario.shifts_per_year[0]\n        scenario.phev_utility_factor_computed = round(\n            min(shift_range_mi, cd_range_mi) / shift_range_mi, 3\n        )\n        uf = scenario.phev_utility_factor_computed\n    return uf\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.get_scenario_and_cycle","title":"<code>get_scenario_and_cycle(veh_no: int, scenario_inputs_path: str, a_vehicle: fastsim.vehicle.Vehicle = None, config: Config = None, do_input_validation: bool = False) -&gt; Tuple[Scenario, fastsim.cycle.Cycle]</code>","text":"<p>This function uses helper methods load_scenario and load_design_cycle_from_scenario         to get scenario object and cycle object corresponding to selected vehicle (by veh_no)</p> <p>Parameters:</p> Name Type Description Default <code>veh_no</code> <code>int</code> <p>vehicle selection number</p> required <code>scenario_inputs_path</code> <code>str</code> <p>input file path for scenario assumptions CSV</p> required <code>a_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for given selection. Defaults to None.</p> <code>None</code> <code>config</code> <code>Config</code> <p>Config object for current analysis. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>scenario</code> <code>Scenario</code> <p>T3CO scenario object selected</p> <code>cyc</code> <code>fastsim.cycle.Cycle</code> <p>FASTSim cycle object selected</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def get_scenario_and_cycle(\n    veh_no: int,\n    scenario_inputs_path: str,\n    a_vehicle: fastsim.vehicle.Vehicle = None,\n    config: Config = None,\n    do_input_validation: bool = False,\n) -&gt; Tuple[Scenario, fastsim.cycle.Cycle]:\n    \"\"\"\n    This function uses helper methods load_scenario and load_design_cycle_from_scenario \\\n        to get scenario object and cycle object corresponding to selected vehicle (by veh_no)\n\n    Args:\n        veh_no (int): vehicle selection number\n        scenario_inputs_path (str): input file path for scenario assumptions CSV\n        a_vehicle (fastsim.vehicle.Vehicle, optional): FASTSim vehicle object for given selection. Defaults to None.\n        config (Config, optional): Config object for current analysis. Defaults to None.\n\n    Returns:\n        scenario (Scenario): T3CO scenario object selected\n        cyc (fastsim.cycle.Cycle): FASTSim cycle object selected\n    \"\"\"\n    scenario = load_scenario(veh_no, scenario_inputs_path, a_vehicle, config)\n    cyc = load_design_cycle_from_scenario(\n        scenario,\n        config,\n        gl.OPTIMIZATION_DRIVE_CYCLES,\n        do_input_validation=do_input_validation,\n    )\n\n    if isinstance(cyc, list):\n        scenario.constant_trip_distance_mi = sum(\n            [\n                sum(cyc[i][0].mph * np.diff(np.array(cyc[i][0].time_s), append=0))\n                * cyc[i][1]\n                / 3600\n                for i in range(len(cyc))\n            ]\n        )\n    else:\n        scenario.constant_trip_distance_mi = (\n            sum(cyc.mph * np.diff(np.array(cyc.time_s), append=0)) / 3600\n        )\n\n    return scenario, cyc\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.get_vehicle","title":"<code>get_vehicle(veh_no: int, veh_input_path: str) -&gt; fastsim.vehicle.Vehicle</code>","text":"<p>This function loads vehicle object from vehicle number and input csv filepath</p> <p>Parameters:</p> Name Type Description Default <code>veh_no</code> <code>int</code> <p>vehicle selection number</p> required <code>veh_input_path</code> <code>str</code> <p>vehicle model assumptions input CSV file path</p> required <p>Returns:</p> Name Type Description <code>veh</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def get_vehicle(veh_no: int, veh_input_path: str) -&gt; fastsim.vehicle.Vehicle:\n    \"\"\"\n    This function loads vehicle object from vehicle number and input csv filepath\n\n    Args:\n        veh_no (int): vehicle selection number\n        veh_input_path (str): vehicle model assumptions input CSV file path\n\n    Returns:\n        veh (fastsim.vehicle.Vehicle): FASTSim vehicle object\n    \"\"\"\n\n    scenario_sel = int(float(str(veh_no).split(\"_\")[0]))\n    veh = vehicle.Vehicle.from_vehdb(scenario_sel, veh_input_path, to_rust=True)\n    veh.set_derived()\n    veh.set_veh_mass()\n\n    return veh\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.limit_cargo_kg_for_moo_hev_bev","title":"<code>limit_cargo_kg_for_moo_hev_bev(opt_scenario: Scenario, mooadvancedvehicle: fastsim.vehicle.Vehicle) -&gt; None</code>","text":"<p>This helper method is used within T3COProblem to assign limited cargo capacity based on GVWR + GVWRCredit and optimization vehicle mass for advanced vehicles</p> <p>Parameters:</p> Name Type Description Default <code>opt_scenario</code> <code>t3co.run_scenario.Scenario</code> <p>T3CO scenario object</p> required <code>mooadvancedvehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>pymoo optimization vehicle</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def limit_cargo_kg_for_moo_hev_bev(\n    opt_scenario: Scenario, mooadvancedvehicle: fastsim.vehicle.Vehicle\n) -&gt; None:\n    \"\"\"\n    This helper method is used within T3COProblem to assign limited cargo capacity based on GVWR + GVWRCredit and optimization vehicle mass for advanced vehicles\n\n    Args:\n        opt_scenario (t3co.run_scenario.Scenario): T3CO scenario object\n        mooadvancedvehicle (fastsim.vehicle.Vehicle): pymoo optimization vehicle\n    \"\"\"\n    # limit cargo to a value &lt;= its original mass, decrease it if vehicle is overweight\n    max_allowable_weight_kg = opt_scenario.gvwr_kg + opt_scenario.gvwr_credit_kg\n    cargo_limited = max_allowable_weight_kg - (\n        mooadvancedvehicle.veh_kg - mooadvancedvehicle.cargo_kg\n    )\n    cargo_limited = max(cargo_limited, 0)\n    # TODO socialize the fact that this next line makes it impossible to add cargo capacity relative to baseline\n    # lightweighting and such can improve energy efficiency but not increase cargo\n    mooadvancedvehicle.cargo_kg = min(cargo_limited, opt_scenario.originalcargo_kg)\n    mooadvancedvehicle.set_veh_mass()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.load_design_cycle_from_path","title":"<code>load_design_cycle_from_path(cyc_file_path: str) -&gt; fastsim.cycle.Cycle</code>","text":"<p>This helper method loads the Cycle object from the drivecycle filepath</p> <p>Parameters:</p> Name Type Description Default <code>cyc_file_path</code> <code>str</code> <p>drivecycle input file path</p> required <p>Returns:</p> Name Type Description <code>range_cyc</code> <code>fastsim.cycle.Cycle</code> <p>FASTSim cycle object for current Scenario object</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def load_design_cycle_from_path(cyc_file_path: str) -&gt; fastsim.cycle.Cycle:\n    \"\"\"\n    This helper method loads the Cycle object from the drivecycle filepath\n\n    Args:\n        cyc_file_path (str): drivecycle input file path\n\n    Returns:\n        range_cyc (fastsim.cycle.Cycle): FASTSim cycle object for current Scenario object\n    \"\"\"\n    if Path(cyc_file_path).exists() == False:\n        print(\n            f\"Drive cycle not found in {cyc_file_path}, trying {gl.OPTIMIZATION_DRIVE_CYCLES}\"\n        )\n        finalized_path = Path(gl.OPTIMIZATION_DRIVE_CYCLES) / cyc_file_path\n\n    else:\n        finalized_path = cyc_file_path\n    range_cyc = cycle.Cycle.from_file(finalized_path)\n    range_cyc = range_cyc.to_rust()\n    return range_cyc\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.load_design_cycle_from_scenario","title":"<code>load_design_cycle_from_scenario(scenario: Scenario, config: Config = None, cyc_file_path: str = gl.OPTIMIZATION_DRIVE_CYCLES, do_input_validation: bool = False) -&gt; fastsim.cycle.Cycle</code>","text":"<p>This helper method loads the design cycle used for mpgge and range determination. It can also be used standalone to get cycles not in standard gl.OPTIMIZATION_DRIVE_CYCLES location, but still needs cycle name from scenario object, carried in scenario.drive_cycle. If the drive cycles are a list of tuples, handle accordingly with eval.</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>Scenario</code> <p>Scenario object for current selection</p> required <code>cyc_file_path</code> <code>str</code> <p>drivecycle input file path. Defaults to gl.OPTIMIZATION_DRIVE_CYCLES.</p> <code>gl.OPTIMIZATION_DRIVE_CYCLES</code> <p>Returns:</p> Name Type Description <code>range_cyc</code> <code>fastsim.cycle.Cycle</code> <p>FASTSim cycle object for current Scenario object</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def load_design_cycle_from_scenario(\n    scenario: Scenario,\n    config: Config = None,\n    cyc_file_path: str = gl.OPTIMIZATION_DRIVE_CYCLES,\n    do_input_validation: bool = False,\n) -&gt; fastsim.cycle.Cycle:\n    \"\"\"\n    This helper method loads the design cycle used for mpgge and range determination.\n    It can also be used standalone to get cycles not in standard gl.OPTIMIZATION_DRIVE_CYCLES location,\n    but still needs cycle name from scenario object, carried in scenario.drive_cycle.\n    If the drive cycles are a list of tuples, handle accordingly with eval.\n\n    Args:\n        scenario (Scenario): Scenario object for current selection\n        cyc_file_path (str, optional): drivecycle input file path. Defaults to gl.OPTIMIZATION_DRIVE_CYCLES.\n\n    Returns:\n        range_cyc (fastsim.cycle.Cycle): FASTSim cycle object for current Scenario object\n    \"\"\"\n\n    if config.dc_files != None and not do_input_validation:\n        dc_id = int(float(str(scenario.selection).split(\"_\")[1]))\n        sdc = str(config.dc_files[dc_id])\n    else:\n        sdc = str(scenario.drive_cycle)\n    print(f\"Drivecycle: {sdc}\")\n    if \"[\" in sdc and \"]\" in sdc and \"(\" in sdc and \")\" in sdc:\n        scenario.drive_cycle = ast.literal_eval(sdc)\n        range_cyc = []\n        for dc_weight in scenario.drive_cycle:\n            cycle_file_name = Path(dc_weight[0]).name\n            dc = load_design_cycle_from_path(\n                cyc_file_path=Path(cyc_file_path) / dc_weight[0]\n            )\n            dc.name = cycle_file_name\n            weight = dc_weight[1]\n            range_cyc.append((dc, weight))\n    else:\n        cycle_file_name = Path(sdc).name\n        range_cyc = load_design_cycle_from_path(cyc_file_path=sdc)\n        range_cyc.name = cycle_file_name\n\n    return range_cyc\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.load_scenario","title":"<code>load_scenario(veh_no: int, scenario_inputs_path: str, a_vehicle: fastsim.vehicle.Vehicle = None, config: Config = None) -&gt; Scenario</code>","text":"<p>This function gets the Scenario object from scenario input CSV filepath, initializes some fields,          and overrides some fields based on Config object</p> <p>Parameters:</p> Name Type Description Default <code>veh_no</code> <code>int</code> <p>vehicle selection number</p> required <code>scenario_inputs_path</code> <code>str</code> <p>input file path for scenario assumptions CSV</p> required <code>a_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for given selection. Defaults to None.</p> <code>None</code> <code>config</code> <code>Config</code> <p>Config object for current analysis. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>scenario</code> <code>Scenario</code> <p>Scenario object for given selection</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def load_scenario(\n    veh_no: int,\n    scenario_inputs_path: str,\n    a_vehicle: fastsim.vehicle.Vehicle = None,\n    config: Config = None,\n) -&gt; Scenario:\n    \"\"\"\n    This function gets the Scenario object from scenario input CSV filepath, initializes some fields,\\\n          and overrides some fields based on Config object\n\n    Args:\n        veh_no (int): vehicle selection number\n        scenario_inputs_path (str): input file path for scenario assumptions CSV\n        a_vehicle (fastsim.vehicle.Vehicle, optional): FASTSim vehicle object for given selection. Defaults to None.\n        config (Config, optional): Config object for current analysis. Defaults to None.\n\n    Returns:\n        scenario (Scenario): Scenario object for given selection\n    \"\"\"\n    scenarios = pd.read_csv(scenario_inputs_path)\n    veh_no_split = str(veh_no).split(\"_\")[0]\n    assert (\n        len(scenarios[scenarios[\"selection\"] == int(float(str(veh_no).split(\"_\")[0]))])\n        == 1\n    ), f\"conflict in {__file__}get_scenario(_): Scenario numbers in {scenario_inputs_path} are not unique \"\n    scenario_dict = scenarios[\n        scenarios[\"selection\"] == int(float(str(veh_no).split(\"_\")[0]))\n    ].to_dict(\"list\")\n    scenario_dict = {k: v[0] for k, v in scenario_dict.items()}\n    scenario_dict[\"vehicle_class\"] = \" \"\n    scenario_dict[\"vehicle_class\"] = (\n        scenario_dict[\"vehicle_class\"]\n        .join(scenario_dict[\"scenario_name\"].split()[:3])\n        .lower()\n    )\n\n    if \"scenario_name\" in scenario_dict:\n        del scenario_dict[\"scenario_name\"]\n\n    if len(str(veh_no).split(\"_\")) &gt; 1 and config.dc_files:\n        dc_id = int(str(veh_no).split(\"_\")[1])\n        scenario_dict[\"drive_cycle\"] = config.dc_files[dc_id]\n        scenario_dict[\"selection\"] = veh_no\n        # print('load_scenario Path error')\n\n    # handle PHEV fuels list and UF list, convert to lists\n    fuels = scenario_dict[\"fuel_type\"]\n    if \"[\" in fuels and \"]\" in fuels:\n        fuels = ast.literal_eval(\n            fuels\n        )  # PHEV [\"CD electricity\", \"CD diesel\", \"CS diesel\"]\n    else:\n        fuels = [fuels]\n    scenario_dict[\"fuel_type\"] = fuels\n\n    # handle VMT, turn into list\n    scenario_dict[\"vmt\"] = ast.literal_eval(scenario_dict[\"vmt\"])\n    scenario_dict[\"mr_unplanned_downtime_hr_per_mi\"] = ast.literal_eval(\n        scenario_dict[\"mr_unplanned_downtime_hr_per_mi\"]\n    )\n    # if config: scenario_dict['config'] = config\n    scenario = Scenario(**scenario_dict)\n    scenario.from_config(config, verbose=False)\n\n    # convert insurance rates string into float list\n    scenario.insurance_rates_pct_per_yr = list(\n        np.float_(scenario.insurance_rates_pct_per_yr.strip(\" ][\").split(\",\"))\n    )\n\n    # validate some inputs, assign as -1 if not provided by user in input file\n    if np.isnan(scenario.ess_init_soc_grade):\n        scenario.ess_init_soc_grade = -1\n    if np.isnan(scenario.ess_init_soc_accel):\n        scenario.ess_init_soc_accel = -1\n    if np.isnan(scenario.soc_norm_init_for_accel_pct):\n        scenario.soc_norm_init_for_accel_pct = -1\n    if np.isnan(scenario.soc_norm_init_for_grade_pct):\n        scenario.soc_norm_init_for_grade_pct = -1\n\n    # PHEV settings and checks\n    if (\n        np.isnan(scenario.phev_utility_factor_override)\n        or scenario.phev_utility_factor_override is None\n    ):\n        scenario.phev_utility_factor_override = -1\n        # we need non-None VMT and shifts_per_year since there is no phev_utility_factor_override provided\n        assert (\n            scenario.shifts_per_year not in [False, None, np.nan]\n        ), f\"invalid shifts_per_year value {scenario.shifts_per_year}, need a valid shifts_per_year (positive integer) value to compute utility factor since there is no phev_utility_factor_override provided\"\n        assert (\n            scenario.vmt[0] is not None\n        ), \"we need non-None VMT since there is no phev_utility_factor_override provided\"\n    if (\n        np.isnan(scenario.motor_power_override_kw_fc_demand_on_pct)\n        or scenario.motor_power_override_kw_fc_demand_on_pct is None\n    ):\n        scenario.motor_power_override_kw_fc_demand_on_pct = -1\n    elif scenario.motor_power_override_kw_fc_demand_on_pct != -1:\n        assert (\n            scenario.motor_power_override_kw_fc_demand_on_pct &lt; 1\n            and scenario.motor_power_override_kw_fc_demand_on_pct &gt; 0\n        ), f\"motor_power_override_kw_fc_demand_on_pct {scenario.motor_power_override_kw_fc_demand_on_pct}\"\n    if a_vehicle is not None and a_vehicle.veh_pt_type == gl.PHEV:\n        if scenario.motor_power_override_kw_fc_demand_on_pct != 1:\n            assert (\n                a_vehicle.kw_demand_fc_on != None\n                and np.isnan(a_vehicle.kw_demand_fc_on) != True\n            )\n    assert (\n        scenario.phev_utility_factor_computed == -1\n    ), \"this should never be populated in input files, only computed if user does not populate phev_utility_factor_override\"\n\n    return scenario\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.rerun","title":"<code>rerun(vehicle: fastsim.vehicle.Vehicle, vocation: str, scenario: Scenario, config: Config)</code>","text":"<p>This function runs vehicle_scenario_sweep when given the vehicle and scenario objects</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>vocation</code> <code>str</code> <p>vocation description</p> required <code>scenario</code> <code>Scenario</code> <p>Scenario object</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>dict</code> <p>output dictionary containing TCO outputs</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def rerun(\n    vehicle: fastsim.vehicle.Vehicle, vocation: str, scenario: Scenario, config: Config\n):\n    \"\"\"\n    This function runs vehicle_scenario_sweep when given the vehicle and scenario objects\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        vocation (str): vocation description\n        scenario (Scenario): Scenario object\n\n    Returns:\n        out (dict): output dictionary containing TCO outputs\n    \"\"\"\n    # set up tco results directories for the vocation-scenario\n    gl.vocation_scenario = vocation\n    gl.set_tco_intermediates()\n    gl.set_tco_results()\n\n    range_cyc = load_design_cycle_from_scenario(scenario, config)\n\n    out = vehicle_scenario_sweep(vehicle, scenario, range_cyc)\n\n    return out\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.reset_vehicle_weight","title":"<code>reset_vehicle_weight(vehicle: fastsim.vehicle.Vehicle) -&gt; None</code>","text":"<p>This function resets vehicle mass after loaded weight tests are done for accel and grade</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def reset_vehicle_weight(vehicle: fastsim.vehicle.Vehicle) -&gt; None:\n    \"\"\"\n    This function resets vehicle mass after loaded weight tests are done for accel and grade\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n    \"\"\"\n    vehicle.veh_override_kg = 0\n    vehicle.set_veh_mass()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.run","title":"<code>run(veh_no: int, vocation: str = 'blank', vehicle_input_path: str = gl.FASTSIM_INPUTS, scenario_inputs_path: str = gl.OTHER_INPUTS)</code>","text":"<p>This function runs vehicle_scenario_sweep based on vehicle and scenario objects read from input file paths</p> <p>Parameters:</p> Name Type Description Default <code>veh_no</code> <code>int</code> <p>vehicle selection number</p> required <code>vocation</code> <code>str</code> <p>vocation description of selected vehicle. Defaults to \"blank\".</p> <code>'blank'</code> <code>vehicle_input_path</code> <code>str</code> <p>input file path for vehicle assumptions CSV. Defaults to gl.FASTSIM_INPUTS.</p> <code>gl.FASTSIM_INPUTS</code> <code>scenario_inputs_path</code> <code>str</code> <p>input file path for scenario assumptions CSV. Defaults to gl.OTHER_INPUTS.</p> <code>gl.OTHER_INPUTS</code> <p>Returns:</p> Name Type Description <code>out</code> <code>dict</code> <p>output dictionary containing TCO results</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def run(\n    veh_no: int,\n    vocation: str = \"blank\",\n    vehicle_input_path: str = gl.FASTSIM_INPUTS,\n    scenario_inputs_path: str = gl.OTHER_INPUTS,\n):\n    \"\"\"\n    This function runs vehicle_scenario_sweep based on vehicle and scenario objects read from input file paths\n\n    Args:\n        veh_no (int): vehicle selection number\n        vocation (str, optional): vocation description of selected vehicle. Defaults to \"blank\".\n        vehicle_input_path (str, optional): input file path for vehicle assumptions CSV. Defaults to gl.FASTSIM_INPUTS.\n        scenario_inputs_path (str, optional): input file path for scenario assumptions CSV. Defaults to gl.OTHER_INPUTS.\n\n    Returns:\n        out (dict): output dictionary containing TCO results\n    \"\"\"\n\n    # set up tco results directories for the vocation-scenario\n    gl.vocation_scenario = vocation\n    gl.set_tco_intermediates()\n    gl.set_tco_results()\n\n    # load the generated file of vehicles, drive cycles, and tech targets\n    vehicle = get_vehicle(veh_no, vehicle_input_path)\n    scenario, range_cyc = get_scenario_and_cycle(veh_no, scenario_inputs_path)\n\n    out = vehicle_scenario_sweep(vehicle, scenario, range_cyc)\n\n    return out\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.run_grade_or_accel","title":"<code>run_grade_or_accel(test: str, analysis_vehicle: fastsim.vehicle.Vehicle, sim_drive: fastsim.simdrive.SimDrive, ess_init_soc: float) -&gt; None</code>","text":"<p>This function handles initial SOC considerations for grade and accel tests</p> <p>If ess_init_soc override is passed, use that Else if the vehicle is an HEV, use the standard HEV init SOC values for accel and grade Else, let FASTSim determine init SOC in sim_drive()     BEVs use max_soc     PHEVs use max_soc     Conv init_soc doesn't matter     HEVs attempt SOC balancing but that is overrident by HEV test init SOC</p> <p>Parameters:</p> Name Type Description Default <code>test</code> <code>str</code> <p>'accel' or 'grade' test</p> required <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>sim_drive</code> <code>fastsim.simdrive.SimDrive</code> <p>FASTSim SimDrive object</p> required <code>ess_init_soc</code> <code>float</code> <p>ESS initial state of charge (SOC)</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>if test not in ['accel', 'grade']</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def run_grade_or_accel(\n    test: str,\n    analysis_vehicle: fastsim.vehicle.Vehicle,\n    sim_drive: fastsim.simdrive.SimDrive,\n    ess_init_soc: float,\n) -&gt; None:\n    \"\"\"\n    This function handles initial SOC considerations for grade and accel tests\n\n    If ess_init_soc override is passed, use that\n    Else if the vehicle is an HEV, use the standard HEV init SOC values for accel and grade\n    Else, let FASTSim determine init SOC in sim_drive()\n        BEVs use max_soc\n        PHEVs use max_soc\n        Conv init_soc doesn't matter\n        HEVs attempt SOC balancing but that is overrident by HEV test init SOC\n\n    Args:\n        test (str): 'accel' or 'grade' test\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        sim_drive (fastsim.simdrive.SimDrive): FASTSim SimDrive object\n        ess_init_soc (float): ESS initial state of charge (SOC)\n\n    Raises:\n        Exception: if test not in ['accel', 'grade']\n    \"\"\"\n\n    if test == \"accel\":\n        # this is what SimAccelTest object was doing in previous version (non-Rust JIT)\n        hev_init_soc = (analysis_vehicle.max_soc + analysis_vehicle.min_soc) / 2.0\n    elif test == \"grade\":\n        hev_init_soc = analysis_vehicle.min_soc\n    else:\n        raise Exception(\"this should not have happened\")\n\n    if ess_init_soc is not None:\n        sim_drive.sim_drive_walk(ess_init_soc)\n    elif analysis_vehicle.veh_pt_type == gl.HEV:\n        sim_drive.sim_drive_walk(hev_init_soc)\n    else:\n        sim_drive.sim_drive()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.set_cargo_kg","title":"<code>set_cargo_kg(analysis_vehicle: fastsim.vehicle.Vehicle, cargo_kg)</code>","text":"<p>This helper method is used within T3COProblem to set cargo_kg to optimization vehicle</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>cargo_kg</code> <code>float</code> <p>vehicle cargo capacity /kg</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def set_cargo_kg(analysis_vehicle: fastsim.vehicle.Vehicle, cargo_kg):\n    \"\"\"\n    This helper method is used within T3COProblem to set cargo_kg to optimization vehicle\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        cargo_kg (float): vehicle cargo capacity /kg\n    \"\"\"\n    analysis_vehicle.cargo_kg = cargo_kg\n    analysis_vehicle.set_veh_mass()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.set_fuel_store_kwh","title":"<code>set_fuel_store_kwh(analysis_vehicle: fastsim.vehicle.Vehicle, fs_kwh: float) -&gt; None</code>","text":"<p>This helper method is used within T3COProblem to set fs_kwh to optimization vehicle</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>fs_kwh</code> <code>float</code> <p>fuel storage energy capacity /kWh</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def set_fuel_store_kwh(\n    analysis_vehicle: fastsim.vehicle.Vehicle, fs_kwh: float\n) -&gt; None:\n    \"\"\"\n    This helper method is used within T3COProblem to set fs_kwh to optimization vehicle\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        fs_kwh (float): fuel storage energy capacity /kWh\n    \"\"\"\n    analysis_vehicle.fs_kwh = fs_kwh\n    analysis_vehicle.set_derived()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.set_max_battery_kwh","title":"<code>set_max_battery_kwh(analysis_vehicle: fastsim.vehicle.Vehicle, max_ess_kwh: float) -&gt; None</code>","text":"<p>This helper method is used within T3COProblem to set max_ess_kwh to optimization vehicle</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>max_ess_kwh</code> <code>float</code> <p>max energy storage system energy capacity /kWh</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def set_max_battery_kwh(\n    analysis_vehicle: fastsim.vehicle.Vehicle, max_ess_kwh: float\n) -&gt; None:\n    \"\"\"\n    This helper method is used within T3COProblem to set max_ess_kwh to optimization vehicle\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        max_ess_kwh (float): max energy storage system energy capacity /kWh\n    \"\"\"\n    analysis_vehicle.ess_max_kwh = max_ess_kwh\n    analysis_vehicle.set_derived()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.set_max_battery_power_kw","title":"<code>set_max_battery_power_kw(analysis_vehicle: fastsim.vehicle.Vehicle, max_ess_kw: float) -&gt; None</code>","text":"<p>This helper method is used within T3COProblem to set max_ess_kwx to optimization vehicle</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>max_ess_kw</code> <code>float</code> <p>max energy storage system power /kW</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def set_max_battery_power_kw(\n    analysis_vehicle: fastsim.vehicle.Vehicle, max_ess_kw: float\n) -&gt; None:\n    \"\"\"\n    This helper method is used within T3COProblem to set max_ess_kwx to optimization vehicle\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        max_ess_kw (float): max energy storage system power /kW\n    \"\"\"\n    analysis_vehicle.ess_max_kw = max_ess_kw\n    analysis_vehicle.set_derived()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.set_max_fuel_converter_kw","title":"<code>set_max_fuel_converter_kw(analysis_vehicle: fastsim.vehicle.Vehicle, fc_max_out_kw: float) -&gt; None</code>","text":"<p>This helper method is used within T3COProblem to set fc_max_out_kw to optimization vehicle</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>fc_max_out_kw</code> <code>float</code> <p>max fuel converter power /kW</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def set_max_fuel_converter_kw(\n    analysis_vehicle: fastsim.vehicle.Vehicle, fc_max_out_kw: float\n) -&gt; None:\n    \"\"\"\n    This helper method is used within T3COProblem to set fc_max_out_kw to optimization vehicle\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        fc_max_out_kw (float): max fuel converter power /kW\n    \"\"\"\n    analysis_vehicle.fc_max_kw = fc_max_out_kw\n    analysis_vehicle.set_derived()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.set_max_motor_kw","title":"<code>set_max_motor_kw(analysis_vehicle: fastsim.vehicle.Vehicle, scenario: Scenario, max_motor_kw: float) -&gt; None</code>","text":"<p>This helper method is used within T3COProblem to set max_motor_kw to optimization vehicle and set kw_demand_fc_on if PHEV</p> <p>Parameters:</p> Name Type Description Default <code>analysis_vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>T3CO Scenarion object</p> required <code>max_motor_kw</code> <code>float</code> <p>max motor power /kW</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def set_max_motor_kw(\n    analysis_vehicle: fastsim.vehicle.Vehicle, scenario: Scenario, max_motor_kw: float\n) -&gt; None:\n    \"\"\"\n    This helper method is used within T3COProblem to set max_motor_kw to optimization vehicle and set kw_demand_fc_on if PHEV\n\n    Args:\n        analysis_vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        scenario (run_scenario.Scenario): T3CO Scenarion object\n        max_motor_kw (float): max motor power /kW\n    \"\"\"\n    # old comments that may be needed again:\n    # Scaling motor and ESS power with ESS capacity results in more reasonable\n    # zero-to-sixty response to battery capacity and is generally consistent\n    # with how things are done.  We need to firm up the functional form of this,\n    # which came from Aaron Brooker for light duty.\n    # veh.mc_max_kw = 24.46 * (veh.ess_max_kwh ** (-.475) * veh.ess_max_kwh)\n    analysis_vehicle.mc_max_kw = max_motor_kw\n    # TODO: for HEV (at least), battery power could be significantly lower than motor power,\n    # and the following variable assignment will be pretty far off\n\n    analysis_vehicle.ess_max_kw = (\n        analysis_vehicle.mc_max_kw / analysis_vehicle.get_mcPeakEff()\n    )\n\n    # PHEV adjustment\n    if analysis_vehicle.veh_pt_type == gl.PHEV:\n        if scenario.motor_power_override_kw_fc_demand_on_pct != -1:\n            analysis_vehicle.kw_demand_fc_on = (\n                max_motor_kw * scenario.motor_power_override_kw_fc_demand_on_pct\n            )\n\n    analysis_vehicle.set_derived()\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.set_test_weight","title":"<code>set_test_weight(vehicle: fastsim.vehicle.Vehicle, scenario: Scenario) -&gt; None</code>","text":"<p>assign standardized vehicle mass for accel and grade test using GVWR and GVWR Credit</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object</p> required <code>scenario</code> <code>t3co.run_scenario.Scenario</code> <p>T3CO scenario object</p> required Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def set_test_weight(vehicle: fastsim.vehicle.Vehicle, scenario: Scenario) -&gt; None:\n    \"\"\"\n    assign standardized vehicle mass for accel and grade test using GVWR and GVWR Credit\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object\n        scenario (t3co.run_scenario.Scenario): T3CO scenario object\n    \"\"\"\n    # June 15,16 confirming that the test weight of vehicle should be GVWRKg + gvwr_credit_kg\n    vehicle.veh_override_kg = scenario.gvwr_kg + scenario.gvwr_credit_kg\n    vehicle.set_veh_mass()\n    assert (\n        vehicle.veh_kg &gt; 0\n    ), \"vehicle weight [kg] cannot be zero, check Scenario values for gvwr_kg and gvwr_credit_kg\"\n</code></pre>"},{"location":"run_scenario/#t3co.run.run_scenario.vehicle_scenario_sweep","title":"<code>vehicle_scenario_sweep(vehicle: fastsim.vehicle.Vehicle, scenario: Scenario, range_cyc, verbose=False, **kwargs)</code>","text":"<p>This function contains helper methods such as get_tco_of_vehicle, check_phev_init_socs, get_accel, and get_gradeability    and returns a dictionary of all TCO related outputs</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object for current selection</p> required <code>scenario</code> <code>Scenario</code> <p>Scenario object for current selection</p> required <code>range_cyc</code> <code>fastsim.cycle.Cycle</code> <p>FASTSim cycle object for current scenario</p> required <code>verbose</code> <code>bool</code> <p>if selected, prints out the TCO calculation process. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>out</code> <code>dict</code> <p>output dictionary containing TCO elements</p> Source code in <code>t3co/run/run_scenario.py</code> Python<pre><code>def vehicle_scenario_sweep(\n    vehicle: fastsim.vehicle.Vehicle,\n    scenario: Scenario,\n    range_cyc,\n    verbose=False,\n    **kwargs,\n):\n    \"\"\"\n    This function contains helper methods such as get_tco_of_vehicle, check_phev_init_socs, get_accel, and get_gradeability\\\n    and returns a dictionary of all TCO related outputs\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object for current selection\n        scenario (Scenario): Scenario object for current selection\n        range_cyc (fastsim.cycle.Cycle): FASTSim cycle object for current scenario\n        verbose (bool, optional): if selected, prints out the TCO calculation process. Defaults to False.\n\n    Returns:\n        out (dict): output dictionary containing TCO elements\n    \"\"\"\n    get_accel = kwargs.get(\"get_accel\", True)\n    get_accel_loaded = kwargs.get(\"get_accel_loaded\", True)\n    get_gradability = kwargs.get(\"get_gradability\", True)\n    write_tsv = kwargs.get(\"write_tsv\", False)\n\n    # run the vehicle through TCO calculations\n    if verbose:\n        print(\"Running `tco_analysis.get_tco_of_vehicle`\")\n    (\n        tot_cost_dol,\n        discounted_tco_dol,\n        oppy_cost_set,\n        ownership_costs_df,\n        discounted_costs_df,\n        mpgge,\n        veh_cost_set,\n        design_cycle_sdr,\n        veh_oper_cost_set,\n        veh_opp_cost_set,\n        tco_files,\n    ) = tco_analysis.get_tco_of_vehicle(\n        vehicle, range_cyc, scenario, write_tsv=write_tsv\n    )\n\n    # tco_analysis.get_operating_costs(scenario, ownership_costs_df, veh_opp_cost_set)\n\n    vehicle_mass = {\n        \"glider_kg\": vehicle.glider_kg,\n        \"cargo_kg\": vehicle.cargo_kg,\n        \"transKg\": vehicle.trans_kg * vehicle.comp_mass_multiplier,\n        \"ess_mass_kg\": vehicle.ess_mass_kg,\n        \"mc_mass_kg\": vehicle.mc_mass_kg,\n        \"fc_mass_kg\": vehicle.fc_mass_kg,\n        \"fs_mass_kg\": vehicle.fs_mass_kg,\n        \"veh_kg\": vehicle.veh_kg,\n        \"gliderLb\": gl.kg_to_lbs(vehicle.glider_kg),\n        \"cargoLb\": gl.kg_to_lbs(vehicle.cargo_kg),\n        \"transLb\": gl.kg_to_lbs(vehicle.trans_kg * vehicle.comp_mass_multiplier),\n        \"essMasLb\": gl.kg_to_lbs(vehicle.ess_mass_kg),\n        \"mcMassLb\": gl.kg_to_lbs(vehicle.mc_mass_kg),\n        \"fcMassLb\": gl.kg_to_lbs(vehicle.fc_mass_kg),\n        \"fsMassLb\": gl.kg_to_lbs(vehicle.fs_mass_kg),\n        \"vehLb\": gl.kg_to_lbs(vehicle.veh_kg),\n    }\n    grade_sdr_6 = None\n    grade_sdr_125 = None\n    accel_sdr = None\n    accel_loaded_sdr = None\n    zero_to_60 = None\n    zero_to_30 = None\n    zero_to_60_loaded = None\n    zero_to_30_loaded = None\n    grade_6_mph_ach = None\n    grade_1_25_mph_ach = None\n    ess_init_soc_accel = None\n    ess_init_soc_grade = None\n\n    # init SOC overrides for grade and accel, for any vehicle that is not a PHEV\n    if scenario.ess_init_soc_grade != -1:\n        ess_init_soc_grade = scenario.ess_init_soc_grade\n    if scenario.ess_init_soc_accel != -1:\n        ess_init_soc_accel = scenario.ess_init_soc_accel\n\n    check_phev_init_socs(vehicle, scenario)\n\n    if scenario.soc_norm_init_for_grade_pct != -1:\n        ess_init_soc_grade = vehicle.min_soc + (\n            scenario.soc_norm_init_for_grade_pct * (vehicle.max_soc - vehicle.min_soc)\n        )\n    if scenario.soc_norm_init_for_accel_pct != -1:\n        ess_init_soc_accel = vehicle.min_soc + (\n            scenario.soc_norm_init_for_accel_pct * (vehicle.max_soc - vehicle.min_soc)\n        )\n\n    if get_accel:\n        if verbose:\n            print(f\"{gl.SWEEP_PATH.name}:: Running accel.get_accel\")\n        zero_to_60, zero_to_30, accel_sdr = accel.get_accel(\n            vehicle,\n            scenario,\n            set_weight_to_max_kg=False,\n            ess_init_soc=ess_init_soc_accel,\n            verbose=verbose,\n        )\n    if get_accel_loaded:\n        if verbose:\n            print(f\"{gl.SWEEP_PATH.name}:: Running accel.get_accel loaded\")\n        zero_to_60_loaded, zero_to_30_loaded, accel_loaded_sdr = accel.get_accel(\n            vehicle,\n            scenario,\n            set_weight_to_max_kg=True,\n            ess_init_soc=ess_init_soc_accel,\n            verbose=verbose,\n        )\n    if get_gradability:\n        if verbose:\n            print(f\"{gl.SWEEP_PATH.name}:: Running gradeability.get_gradeability\")\n        (\n            grade_6_mph_ach,\n            grade_1_25_mph_ach,\n            grade_sdr_6,\n            grade_sdr_125,\n        ) = gradeability.get_gradeability(\n            vehicle,\n            scenario,\n            ess_init_soc=ess_init_soc_grade,\n            set_weight_to_max_kg=True,\n        )\n\n    range_dict = fueleconomy.get_range_mi(mpgge, vehicle, scenario)\n\n    out = {\n        \"discounted_costs_df\": discounted_costs_df,\n        \"veh_oper_cost_set\": veh_oper_cost_set,\n        \"veh_opp_cost_set\": veh_opp_cost_set,\n        \"mpgge\": mpgge,\n        \"veh_msrp_set\": veh_cost_set,\n        \"vehicle\": vehicle,\n        \"vehicle_mass\": vehicle_mass,\n        \"zero_to_60\": zero_to_60,\n        \"zero_to_30\": zero_to_30,\n        \"zero_to_60_loaded\": zero_to_60_loaded,\n        \"zero_to_30_loaded\": zero_to_30_loaded,\n        \"grade_6_mph_ach\": grade_6_mph_ach,\n        \"grade_1_25_mph_ach\": grade_1_25_mph_ach,\n        \"scenario\": scenario,\n        \"design_cycle_sim_drive_record\": design_cycle_sdr,\n        \"accel_sim_drive_record\": accel_sdr,\n        \"accel_loaded_sim_drive_record\": accel_loaded_sdr,\n        \"grade_6_sim_drive_record\": grade_sdr_6,\n        \"grade_1p25_sim_drive_record\": grade_sdr_125,\n        \"disc_cost\": discounted_tco_dol,\n        \"opportunity_cost_set\": oppy_cost_set,\n        \"tot_cost\": tot_cost_dol,\n        \"tco_files\": tco_files,\n    }\n    out.update(range_dict)\n    return out\n</code></pre>"},{"location":"scenario_inputs_descriptions/","title":"Scenario Input Parameters Descriptions","text":"Scenario Input Parameter Description Data Type(s) Accepted selection Selection number that is used to match with the corresponding vehicles on the Demo_FY22_vehicle_assumptions.csv file int scenario_name Name of the vehicle and scenario - Includes names string veh_year Current year int drive_cycle Relative filepath of drivecycle input file(s)  from /t3co/resources/cycles/ folder - accepts single drivecyle path, composite cycles (for example: '[(\"EPA_Ph2_rural_interstate_65mph.csv\", .86), (\"EPA_Ph2_urban_highway_55mph.csv\", .09), (\"EPA_Ph2_transient.csv\", .05)]'), or path to folder containing multiple drivecycles (results in corresponding number of scenarios) string vmt_reduct_per_yr not used vmt Vehicle Miles Traveled as an array/list with length&gt;=vehicle_life_yr list[int] constant_trip_distance_mi not used vehicle_life_yr Number of years to calculate TCO for - generally the expected life of the vehicle in years int desired_ess_replacements not used discount_rate_pct_per_yr Discount rate per year as a fraction/year to account for time value of money and alternative investment opportunities. This is applied as a constant rate for TCO cost components float ess_max_charging_power_kw Maximum charging power available in kW (infrastructure dependent) for ESS (Energy Storage Systems like Li-ion battery packs) in xEVs float ess_cost_dol_per_kw not used ess_cost_dol_per_kwh Cost of ESS in dollars per kWh of capacity float ess_base_cost_dol Cost of ESSs packaging in dollars that is added to vehicle.ess_max_kwh * scenario.ess_cost_dol_per_kwh to estimate total ESS cost float ess_cost_reduction_dol_per_yr Reduction of ESS cost per year - not used float ess_salvage_value_dol Salvage Value of ESS at end of vehicle_life_yr - not used float pe_mc_cost_dol_per_kw Cost of Power Electronics and Motor Controllers in dollars per kW float pe_mc_base_cost_dol Cost of Power Electronics and Motor Controllers baseline that is added to vehicle.mc_max_kw * scenario.pe_mc_cost_dol_per_kw to estimate total PE&amp;MC cost float fc_ice_cost_dol_per_kw Cost of Internal Combustion Engine per kW of power for Conventional vehicles float fc_ice_base_cost_dol Cost of Fuel Convertor baseline that is added to vehicle.fc_max_kw * scenario.fc_ice_cost_dol_per_kw to estimate total FC cost baseline that is added to vehicle.fc_max_kw * scenario.fc_ice_cost_dol_per_kw to estimate total FC cost\" float fc_fuelcell_cost_dol_per_kw Cost of Hydrogen fuel cells per kW of power for FCEVs float fs_cost_dol_per_kwh Cost of liquid fuel storage tanks per kWh of capacity for liquid fuel like diesel/gasoline float fs_h2_cost_dol_per_kwh Cost of gas fuel storage tanks per kWh of capacity for gaseous fuel like hydrogen float fs_fueling_rate_kg_per_min Fill rate in kg per min (KPM) for gaseous fuels like hydrogen, propane - infrastructure dependent float fs_fueling_rate_gasoline_gpm Fill rate in gallons per min (GPM) for gasoline - infrastructure dependent float fs_fueling_rate_diesel_gpm Fill rate in gallons per min (GPM) for diesel - infrastructure dependent float plug_base_cost_dol Cost of plugin connections on  certain xEVs float markup_pct Markup on price of vehicle as percentage of MSRP (eg., 1.20 means 20% markup_pct on MSRP) float tax_rate_pct Registration and other taxes during time of purchase as percent on the MSRP (eg., 0.125 means 12.5% of MSRP) float fc_cng_ice_cost_dol_per_kw Cost of CNG engine per kW of max power float fs_cng_cost_dol_per_kwh Cost of CNG fuel storage per kWh of max fuel tank capacity float vehicle_glider_cost_dol Cost of glider (vehicle without powertrain) in dollars float segment_name Name of the vehicle type or fleet name string gvwr_kg Gross Vehicle Weight Rating upper limit  in kg for the vehicle's weight class float gvwr_credit_kg Additional allowable weight in kg for advanced vehicles (eg. 2000lb credit for Class 8 BEVs) float fuel_type Fuel name - should be one of : ['diesel', 'gasoline', 'hydrogen', 'electricity', 'cng']. For hybrids, use the primary fuel string maint_oper_cost_dol_per_mi Vehicle maintenance operating cost in dollars per mile traveled as vector of length equal to number of TCO years list[float] vocation Vocation of the vehicle - only for user reference string model_year Vehicle model year int region Region name is used as a key to find the right fuel prices for the analysis. Refer to /t3co/resources/FuelPrices.csv for region name string target_range_mi Target range in miles to be achieved by the optimized vehicle float min_speed_at_6pct_grade_in_5min_mph Minimum speed in miles/hour for the optimized vehicle to attain from 0 mph in 5 mins for a 6 percent gradeability test float min_speed_at_1p25pct_grade_in_5min_mph Minimum speed in miles/hour for the optimized vehicle to attain from 0 mph in 5 mins for a 1.25 percent gradeability test float max_time_0_to_60mph_at_gvwr_s Maximum time taken by optimized vehicle (at GVWR weight limit) to accelerate from 0 to 60 mph - acceleration test float max_time_0_to_30mph_at_gvwr_s Maximum time taken by optimized vehicle (at GVWR weight limit) to accelerate from 0 to 30 mph - acceleration test float lw_imp_curve_sel Complete file path to light weighting improvement curve - cost vs weight reduced string eng_eff_imp_curve_sel Complete file path to engine efficiency improvement curve - cost vs efficiency string aero_drag_imp_curve_sel Complete file path to aero drag improvement curve - cost vs drag coefficient string skip_opt Boolean switch for skipping the optimization module bool knob_min_ess_kwh Optimization bounds - minimum ESS capacity in kWh float knob_max_ess_kwh Optimization bounds - maximum ESS capacity in kWh float knob_min_motor_kw Optimization bounds - minimum motor peak power in kW float knob_max_motor_kw Optimization bounds - maximum motor peak power in kW float knob_min_fc_kw Optimization bounds - minimum fuel convertor peak power in kW float knob_max_fc_kw Optimization bounds - maximum fuel convertor peak power in kW float knob_min_fs_kwh Optimization bounds - minimum fuel storage capacity in kWh float knob_max_fs_kwh Optimization bounds - maximum fuel storage capacity in kWh float constraint_range Optimization constraint - Range constraint_accel Optimization constraint - Acceleration 0-30mph, Acceleration 0-60mph bool constraint_grade Optimization constraint - Gradeability 1.25% grade and 6% grade bool objective_tco Boolean switch for minimizing TCO as optimization objective bool constraint_c_rate Optimization constraint - Charge Rate bool shifts_per_year Number of shift / drive cycle instances the vehicle travels per year as a vector of length equal to number of TCO years. If not specified, then it's calculated from vmt and drive cycle distance. NOTE: if the drive cycle includes the full duration of a shift, best practice is to leave this blank or 0 or [0]; otherwise , i.e. if it is a compressed or regulatory cycle, shifts per year should be specified. list[int] motor_power_override_kw_fc_demand_on_pct For PHEV, percentage motor power override as fraction float soc_norm_init_for_accel_pct Initial normalized SOC for acceleration test (only PHEV) float soc_norm_init_for_grade_pct Initial normalized SOC for gradeability test (only PHEV) float labor_rate_dol_per_hr Labor Rate for dollars per hour of vehicle operation float activate_tco_payload_cap_cost_multiplier Boolean switch to activate lost payload capacity opportunity cost calculation bool plf_ref_veh_empty_mass_kg Reference vehicle empty weight in kg for lost payload capacity opportunity cost calculation float activate_tco_fueling_dwell_time_cost Boolean switch to activate fueling dwell time opportunity cost calculation bool downtime_oppy_cost_dol_per_hr Opportunity cost of dwell time for fueling vehicle as dollar per hour float fdt_num_free_dwell_trips Number of free trips or overnight charging opportunities that do not incur an opportunity cost penalty float fdt_dwpt_fraction_power_pct Fraction of vehicle power consumption through dynamic wireless power transfer float fdt_available_freetime_hr Number of hours of dwell time that do not incur opportunity cost penalty (eg., charging vehicle during scheduled lunch stops) float fdt_avg_overhead_hr_per_dwell_hr Number of hours of overhead time during fueling/charging (eg., detour to gas station, time taken for plugging in charger, etc.) float fdt_frac_full_charge_bounds Lower and Upper bounds for fractional charge as a list [, ].  is lowest fraction of charge/tank for a fractional charge at a fueling stop.  is the highest fraction of charge/tank capacity above which it is preferred to rather fill up the batter/tank list[float] activate_mr_downtime_cost Boolean switch to activate maintenance and repair (M&amp;R) downtime opportunity cost calculation bool mr_planned_downtime_hr_per_yr Regular/planned maintenance time in hours per year float mr_unplanned_downtime_hr_per_mi Unplanned maintenance time per mile traveled as a vector with length equal to number of TCO years list[float] mr_tire_replace_downtime_hr_per_event Downtime hours per tire replacement event float mr_avg_tire_life_mi Average life of tire in miles after which a tire replacement event takes place float insurance_rates_pct_per_yr Insurance rates as a percent of MSRP per year as vector with length equal to number of TCO years list[float]"},{"location":"sweep/","title":"Sweep module","text":""},{"location":"sweep/#t3co.sweep","title":"<code>t3co.sweep</code>","text":""},{"location":"sweep/#t3co.sweep.REPORT_COLS","title":"<code>REPORT_COLS = {'selection': '', 'scenario_name': '', 'veh_year': '', 'veh_pt_type': '', 'pareto_front_number': '', 'run_time_[s]': '', 'algorithm': '', 'n_gen': '', 'fvals_over_gens': '', 'design_cyc_trace_miss_dist_frac': '', 'design_cyc_trace_miss_time_frac': '', 'design_cyc_trace_miss_speed_mps': '', 'design_cycle_EA_err': '', 'accel_EA_err': '', 'accel_loaded_EA_err': '', 'grade_6_EA_err': '', 'grade_125_EA_err': '', 'final_cda_pct': '', 'final_eng_eff_pct': '', 'final_ltwt_pct': '', 'final_max_motor_kw': '', 'final_battery_kwh': '', 'final_max_fc_kw': '', 'final_fs_kwh': '', 'minSpeed6PercentGradeIn5minAch': '', 'target_minSpeed6PercentGradeIn5min': '', 'delta_6PercentGrade': '', 'minSpeed1point25PercentGradeIn5minAch': '', 'target_minSpeed1point25PercentGradeIn5min': '', 'delta_1point25PercentGrade': '', 'max0to60secAtGVWRAch': '', 'target_max0to60secAtGVWR': '', 'delta_0to60sec': '', 'max0to30secAtGVWRAch': '', 'target_max0to30secAtGVWR': '', 'delta_0to30sec': ''}</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.RES_FILE","title":"<code>RES_FILE = report_kwargs['RES_FILE']</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.algorithms","title":"<code>algorithms = moo.ALGORITHMS</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.args","title":"<code>args = parser.parse_args()</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.config","title":"<code>config = rs.Config()</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.end","title":"<code>end = time.time()</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.exclude","title":"<code>exclude = args.exclude</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.k","title":"<code>k = len(reports)</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.kwargs","title":"<code>kwargs = {'selections': selections, 'look_for': look_for, 'exclude': exclude, 'algo': algorithms, 'dir_mark': args.dir_mark, 'dst_dir': args.dst_dir, 'file_mark': args.file_mark.replace('.csv', ''), 'skip_save_veh': args.skip_save_veh, 'x_tol': float(args.x_tol), 'f_tol': float(args.f_tol), 'n_max_gen': int(args.n_max_gen), 'pop_size': int(args.pop_size), 'nth_gen': int(args.nth_gen), 'n_last': int(args.n_last), 'skip_all_opt': args.skip_all_opt if args.config is None else config.skip_all_opt, 'do_input_validation': args.skip_input_validation, 'range_overshoot_tol': float(args.range_overshoot_tol) if args.range_overshoot_tol is not None else None, 'write_tsv': write_tsv}</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.look_for","title":"<code>look_for = args.look_for</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.parser","title":"<code>parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, prog='SWEEP', description='The sweep.py module is the main script to run T3CO')</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.report_i","title":"<code>report_i = run_optimize_analysis(sel, vdf=vdf, sdf=sdf, skip_all_opt=skip_all_opt, config=config, report_kwargs=report_kwargs, REPORT_COLS=REPORT_COLS)</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.reports","title":"<code>reports = []</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.reports_df","title":"<code>reports_df = pd.DataFrame(reports)</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.resdir","title":"<code>resdir = Path(report_kwargs['resdir'])</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.scen_df","title":"<code>scen_df = dict(sdf.loc[sel, :])</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.sel_list","title":"<code>sel_list = [scenario_selection for scenario_selection in config.selections if str(scenario_selection).split('_')[0] == str(sel)]</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.selections","title":"<code>selections = -1</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.selections_list","title":"<code>selections_list = []</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.skip_opt","title":"<code>skip_opt = scen_df.get('skip_opt', False)</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.start","title":"<code>start = time.time()</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.write_tsv","title":"<code>write_tsv = args.write_tsv</code>  <code>module-attribute</code>","text":""},{"location":"sweep/#t3co.sweep.check_input_files","title":"<code>check_input_files(df: pd.DataFrame, filetype: str, filepath: str) -&gt; None</code>","text":"<p>This function contains assert statements that make sure input vehicle and scenario dataframes do not contain numm rows</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>vehicle or scenario dataframe</p> required <code>filetype</code> <code>str</code> <p>'vehicle' or 'scenario'</p> required <code>filepath</code> <code>str</code> <p>filepath of the vehicle or scenario input files</p> required Source code in <code>t3co/sweep.py</code> Python<pre><code>def check_input_files(df: pd.DataFrame, filetype: str, filepath: str) -&gt; None:\n    \"\"\"\n    This function contains assert statements that make sure input vehicle and scenario dataframes do not contain numm rows\n\n    Args:\n        df (DataFrame): vehicle or scenario dataframe\n        filetype (str): 'vehicle' or 'scenario'\n        filepath (str): filepath of the vehicle or scenario input files\n    \"\"\"\n    blank_lines = [i for i in df.index.isnull().cumsum() if i != 0]\n    assert (\n        df.index.isnull().any() == False\n    ), f\"\\n\\n{filetype} file selection column cannot have blank values\\nlines: {blank_lines}\\npath: {filepath}\\n\\n\\n\\n\"  # noqa: E712\n    assert (\n        df[\"scenario_name\"].isnull().any() == False\n    ), f\"\\n\\n{filetype} file scenario_name column cannot have blank values\\nlines: {blank_lines}\\npath: {filepath}\\n\\n\\n\\n\"  # noqa: E712\n</code></pre>"},{"location":"sweep/#t3co.sweep.deug_traces","title":"<code>deug_traces(vehicle: fastsim.vehicle.Vehicle, cycles: List[fastsim.cycle.Cycle], scenario: run_scenario.Scenario) -&gt; None</code>","text":"<p>This function gets a diagnostic trace of get_mpgge</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim Vehicle object</p> required <code>cycles</code> <code>List[fastsim.cycle.Cycle]</code> <p>List of FASTSim drivecycle objects</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object</p> required Source code in <code>t3co/sweep.py</code> Python<pre><code>def deug_traces(\n    vehicle: fastsim.vehicle.Vehicle,\n    cycles: List[fastsim.cycle.Cycle],\n    scenario: run_scenario.Scenario,\n) -&gt; None:\n    \"\"\"\n    This function gets a diagnostic trace of get_mpgge\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim Vehicle object\n        cycles (List[fastsim.cycle.Cycle]): List of FASTSim drivecycle objects\n        scenario (run_scenario.Scenario): Scenario object\n    \"\"\"\n    mpgge_comp, sim_drives, mpgges = fe.get_mpgge(\n        cycles, vehicle, scenario, diganostic=True\n    )\n</code></pre>"},{"location":"sweep/#t3co.sweep.get_knobs_bounds_curves","title":"<code>get_knobs_bounds_curves(selection: int, vpttype: str, sdf: pd.DataFrame, lw_imp_curves: pd.DataFrame, aero_drag_imp_curves: pd.DataFrame, eng_eff_curves: pd.DataFrame) -&gt; Tuple[dict, dict]</code>","text":"<p>This function fetches the knobs and constraints for running the optimization for a given selection</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>int</code> <p>selection number</p> required <code>vpttype</code> <code>str</code> <p>vehicle powertrain type = veh_pt_type</p> required <code>sdf</code> <code>pd.DataFrame</code> <p>scenario dataframe</p> required <code>lw_imp_curves</code> <code>pd.DataFrame</code> <p>light weighting curve dataframe</p> required <code>aero_drag_imp_curves</code> <code>pd.DataFrame</code> <p>aero drag curve dataframe</p> required <code>eng_eff_curves</code> <code>pd.DataFrame</code> <p>engine efficiency curve dataframe</p> required <p>Returns:</p> Name Type Description <code>knobs_bounds</code> <code>dict</code> <p>dict of knobs and bounds</p> <code>curves</code> <code>dict</code> <p>dict of lw, aero, and engine efficiency curve parameters</p> Source code in <code>t3co/sweep.py</code> Python<pre><code>def get_knobs_bounds_curves(\n    selection: int,\n    vpttype: str,\n    sdf: pd.DataFrame,\n    lw_imp_curves: pd.DataFrame,\n    aero_drag_imp_curves: pd.DataFrame,\n    eng_eff_curves: pd.DataFrame,\n) -&gt; Tuple[dict, dict]:\n    \"\"\"\n    This function fetches the knobs and constraints for running the optimization for a given selection\n\n    Args:\n        selection (int): selection number\n        vpttype (str): vehicle powertrain type = veh_pt_type\n        sdf (pd.DataFrame): scenario dataframe\n        lw_imp_curves (pd.DataFrame): light weighting curve dataframe\n        aero_drag_imp_curves (pd.DataFrame): aero drag curve dataframe\n        eng_eff_curves (pd.DataFrame): engine efficiency curve dataframe\n\n    Returns:\n        knobs_bounds (dict): dict of knobs and bounds\n        curves (dict): dict of lw, aero, and engine efficiency curve parameters\n    \"\"\"\n    lw_imp_curves_file = lw_imp_curves.set_index(\"name\")\n    aero_drag_imp_curves_file = aero_drag_imp_curves.set_index(\"name\")\n    eng_eff_curves_file = eng_eff_curves.set_index(\"name\")\n    sd = dict(sdf.loc[selection, :])\n    curves = {}\n\n    knobs_bounds = {\n        \"ess_max_kwh\": [sd.get(\"knob_min_ess_kwh\"), sd.get(\"knob_max_ess_kwh\")],\n        \"mc_max_kw\": [sd.get(\"knob_min_motor_kw\"), sd.get(\"knob_max_motor_kw\")],\n        \"fcMaxOutKw\": [sd.get(\"knob_min_fc_kw\"), sd.get(\"knob_max_fc_kw\")],\n        \"fs_kwh\": [sd.get(\"knob_min_fs_kwh\"), sd.get(\"knob_max_fs_kwh\")],\n    }\n\n    if (\n        \"lw_imp_curve_sel\" in sd\n        and sd[\"lw_imp_curve_sel\"]\n        and not pd.isnull(sd[\"lw_imp_curve_sel\"])\n    ):\n        lw_curve_selection = sd[\"lw_imp_curve_sel\"]\n        ltwt_cost_curve = lw_imp_curves_file.loc[\"ltwt_cost\", lw_curve_selection]\n        ltwt_pct_curve = lw_imp_curves_file.loc[\"ltwt_pct\", lw_curve_selection]\n        wt_delta_perc_knob_max = float(\n            lw_imp_curves_file.loc[\"wt_delta_perc_knob_max\", lw_curve_selection]\n        )\n        wt_delta_perc_knob_min = float(\n            lw_imp_curves_file.loc[\"wt_delta_perc_knob_min\", lw_curve_selection]\n        )\n        assert (\n            wt_delta_perc_knob_max &lt;= 1\n        ), f\"input invalid, value for wt_delta_perc_knob_max must decimal form, got percentage point value as {wt_delta_perc_knob_max}\"\n\n        knobs_bounds[\"wt_delta_perc\"] = (wt_delta_perc_knob_min, wt_delta_perc_knob_max)\n        curves.update(\n            {\n                \"ltwt_delta_percs\": np.array(ast.literal_eval(ltwt_pct_curve)),\n                \"ltwt_dol_per_kg_costs\": np.array(ast.literal_eval(ltwt_cost_curve)),\n            }\n        )\n\n    if (\n        \"aero_drag_imp_curve_sel\" in sd\n        and sd[\"aero_drag_imp_curve_sel\"]\n        and not pd.isnull(sd[\"aero_drag_imp_curve_sel\"])\n    ):\n        cda_curve_selection = sd[\"aero_drag_imp_curve_sel\"]\n        CdA_perc_imp_at_which_wt_penalty_maxes_out = float(\n            aero_drag_imp_curves_file.loc[\n                \"CdA_perc_imp_at_which_wt_penalty_maxes_out\", cda_curve_selection\n            ]\n        )\n        CdA_perc_imp_knob_max = float(\n            aero_drag_imp_curves_file.loc[\"CdA_perc_imp_knob_max\", cda_curve_selection]\n        )\n        CdA_perc_imp_knob_min = float(\n            aero_drag_imp_curves_file.loc[\"CdA_perc_imp_knob_min\", cda_curve_selection]\n        )\n        cost_a = float(aero_drag_imp_curves_file.loc[\"cost_a\", cda_curve_selection])\n        cost_b = float(aero_drag_imp_curves_file.loc[\"cost_b\", cda_curve_selection])\n        mass_a = float(aero_drag_imp_curves_file.loc[\"mass_a\", cda_curve_selection])\n        mass_b = float(aero_drag_imp_curves_file.loc[\"mass_b\", cda_curve_selection])\n        assert (\n            CdA_perc_imp_knob_max &lt;= 1\n        ), f\"input invalid, value for CdA_perc_imp_knob_max must decimal form, got percentage point value as {CdA_perc_imp_knob_max}\"\n        assert (\n            CdA_perc_imp_at_which_wt_penalty_maxes_out &lt;= 1\n        ), f\"input invalid, value for CdA_perc_imp_at_which_wt_penalty_maxes_out must decimal form, got percentage point value as {CdA_perc_imp_at_which_wt_penalty_maxes_out}\"\n\n        knobs_bounds[\"CdA_perc_imp\"] = (CdA_perc_imp_knob_min, CdA_perc_imp_knob_max)\n        curves.update(\n            {\n                \"cda_cost_coeff_a\": cost_a,\n                \"cda_cost_coeff_b\": cost_b,\n                \"cda_mass_coeff_a\": mass_a,\n                \"cda_mass_coeff_b\": mass_b,\n                \"cda_perc_imp_at_which_wt_penalty_maxes_out\": CdA_perc_imp_at_which_wt_penalty_maxes_out,\n            }\n        )\n\n    if (\n        \"eng_eff_imp_curve_sel\" in sd\n        and sd[\"eng_eff_imp_curve_sel\"]\n        and not pd.isnull(sd[\"eng_eff_imp_curve_sel\"])\n        and vpttype != gl.BEV\n    ):\n        # TODO, FCEV should not get eng imp curve parameter\n        eng_imp_curve_selection = sd[\"eng_eff_imp_curve_sel\"]\n        fc_peak_eff_knob_min = float(\n            eng_eff_curves_file.loc[\"fc_peak_eff_knob_min\", eng_imp_curve_selection]\n        )\n        fc_peak_eff_knob_max = float(\n            eng_eff_curves_file.loc[\"fc_peak_eff_knob_max\", eng_imp_curve_selection]\n        )\n        eng_pctpt = eng_eff_curves_file.loc[\"eng_pctpt\", eng_imp_curve_selection]\n        eng_cost = eng_eff_curves_file.loc[\"eng_cost\", eng_imp_curve_selection]\n        assert (\n            fc_peak_eff_knob_max &lt;= 1\n        ), f\"input invalid, value for fc_peak_eff_knob_max must decimal form, got percentage point value as {fc_peak_eff_knob_max}\"\n\n        curves.update(\n            {\n                \"fc_eff_array\": np.array(ast.literal_eval(eng_pctpt)),\n                \"fc_cost_coeff_array\": np.array(ast.literal_eval(eng_cost)),\n            }\n        )\n\n        knobs_bounds[\"fc_peak_eff\"] = (fc_peak_eff_knob_min, fc_peak_eff_knob_max)\n\n    # validate knobs bounds and remove inactive knobs (user left blank or NA)\n    knobs = list(knobs_bounds.keys())\n    print(\"knobs and bounds\")\n    for k in knobs:\n        print(k, knobs_bounds[k][0], knobs_bounds[k][1])\n        nans = np.isnan(knobs_bounds[k][0]) or np.isnan(knobs_bounds[k][1])\n        if nans or knobs_bounds[k][0] is None or knobs_bounds[k][1] is None:\n            del knobs_bounds[k]\n    return knobs_bounds, curves\n</code></pre>"},{"location":"sweep/#t3co.sweep.get_objectives_constraints","title":"<code>get_objectives_constraints(selection: int, sdf: pd.DataFrame, verbose: bool = True) -&gt; Tuple[list, list]</code>","text":"<p>This function appends to list of necessary variables based on the constraints and objectives selected</p> <p>Parameters:</p> Name Type Description Default <code>selection</code> <code>int</code> <p>selection number</p> required <code>sdf</code> <code>DataFrame</code> <p>scenario dataframe</p> required <code>verbose</code> <code>bool</code> <p>if selected, function will print objectives and constraints. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>objectives</code> <code>list</code> <p>list of selected objective variables</p> <code>constraints</code> <code>list</code> <p>list of selected constraint variables</p> Source code in <code>t3co/sweep.py</code> Python<pre><code>def get_objectives_constraints(\n    selection: int, sdf: pd.DataFrame, verbose: bool = True\n) -&gt; Tuple[list, list]:\n    \"\"\"\n    This function appends to list of necessary variables based on the constraints and objectives selected\n\n    Args:\n        selection (int): selection number\n        sdf (DataFrame): scenario dataframe\n        verbose (bool, optional): if selected, function will print objectives and constraints. Defaults to True.\n\n    Returns:\n        objectives (list): list of selected objective variables\n        constraints (list): list of selected constraint variables\n    \"\"\"\n    sd = dict(sdf.loc[selection, :])\n    objectives = []\n    constraints = []\n    # constraints\n    if sd.get(\"constraint_range\") == True:\n        constraints.append(moo.RANGE)\n    if sd.get(\"constraint_accel\") == True:\n        constraints.extend([moo.ACCEL30, moo.ACCEL60])\n    if sd.get(\"constraint_grade\") == True:\n        constraints.extend([moo.GRADE125, moo.GRADE6])\n    if sd.get(\"constraint_c_rate\") == True:\n        constraints.append(moo.C_RATE)\n    if sd.get(\"constraint_trace_miss_dist_percent_on\") == True:\n        constraints.append(moo.TRACE_MISS_DIST_PERCENT)\n    if sd.get(\"constraint_phev_minimize_fuel_use_on\") == True:\n        constraints.append(moo.PHEV_MINIMIZE_FUEL_USE_CONSTRAINT)\n    # objectives\n    if sd.get(\"objective_phev_minimize_fuel_use\") == True:\n        objectives.append(moo.PHEV_MINIMIZE_FUEL_USE_OBJECTIVE)\n    if sd.get(\"objective_tco\") == True:\n        objectives.append(moo.TCO)\n\n    if verbose:\n        print(\"objectives:\", objectives)\n        print(\"constraints:\", constraints)\n\n    return objectives, constraints\n</code></pre>"},{"location":"sweep/#t3co.sweep.optimize","title":"<code>optimize(sel: float, sdf: pd.DataFrame, vdf: pd.DataFrame, algo: str, report_kwargs: dict, REPORT_COLS: dict, skip_opt: bool, config: run_scenario.Config, write_tsv: bool = False) -&gt; dict</code>","text":"<p>This function runs the optimization for a given selection if skip_opt = False</p> <p>Parameters:</p> Name Type Description Default <code>sel</code> <code>float</code> <p>Selection number</p> required <code>sdf</code> <code>pd.DataFrame</code> <p>Dataframe of input scenario file</p> required <code>vdf</code> <code>pd.DataFrame</code> <p>Dataframe of input vehicle file</p> required <code>algo</code> <code>str</code> <p>Multiobjective optimization Algorithm name</p> required <code>report_kwargs</code> <code>dict</code> <p>arguments related to running T3CO</p> required <code>REPORT_COLS</code> <code>dict</code> <p>Results columns dictionary for sorting the T3CO results</p> required <code>skip_opt</code> <code>bool</code> <p>skip optimization. If true, then optimizer is not run.</p> required <code>config</code> <code>run_scenario.Config</code> <p>Config object</p> required <code>write_tsv</code> <code>bool</code> <p>if selected, intermediary dataframes are saved as tsv files.. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>report_i</code> <code>dict</code> <p>Dictionary of T3CO results for given selection</p> Source code in <code>t3co/sweep.py</code> Python<pre><code>def optimize(\n    sel: float,\n    sdf: pd.DataFrame,\n    vdf: pd.DataFrame,\n    algo: str,\n    report_kwargs: dict,\n    REPORT_COLS: dict,\n    skip_opt: bool,\n    config: run_scenario.Config,\n    write_tsv: bool = False,\n) -&gt; dict:\n    \"\"\"\n    This function runs the optimization for a given selection if skip_opt = False\n\n\n    Args:\n        sel (float): Selection number\n        sdf (pd.DataFrame): Dataframe of input scenario file\n        vdf (pd.DataFrame): Dataframe of input vehicle file\n        algo (str): Multiobjective optimization Algorithm name\n        report_kwargs (dict): arguments related to running T3CO\n        REPORT_COLS (dict): Results columns dictionary for sorting the T3CO results\n        skip_opt (bool): skip optimization. If true, then optimizer is not run.\n        config (run_scenario.Config): Config object\n        write_tsv (bool, optional): if selected, intermediary dataframes are saved as tsv files.. Defaults to False.\n\n    Returns:\n        report_i (dict): Dictionary of T3CO results for given selection\n    \"\"\"\n    print(f\"sel: {sel}\")\n    scenario_name = vdf.loc[int(str(sel).split(\"_\")[0]), \"scenario_name\"]\n    print(\n        f\"\\nRunning selection {sel} for scenario {scenario_name} - skip opt = {skip_opt} -algo = {algo}\"\n    )\n\n    optpt = vdf.loc[int(str(sel).split(\"_\")[0]), \"veh_pt_type\"]\n    ti = time.time()\n    # sel = float(sel)\n    algo = report_kwargs[\"algo\"]\n    x_tol = report_kwargs[\"x_tol\"]\n    f_tol = report_kwargs[\"f_tol\"]\n    pop_size = report_kwargs[\"pop_size\"]\n    n_max_gen = report_kwargs[\"n_max_gen\"]\n    n_last = report_kwargs[\"n_last\"]\n    nth_gen = report_kwargs[\"nth_gen\"]\n    verbose = report_kwargs[\"verbose\"]\n    resdir = report_kwargs[\"resdir\"]\n    ts = report_kwargs[\"ts\"]\n    file_mark = report_kwargs[\"file_mark\"]\n    skip_save_veh = report_kwargs[\"skip_save_veh\"]\n    gl.vocation_scenario = scenario_name\n    if not skip_opt:\n        moo_results, moo_problem, moo_code = run_moo(\n            sel,\n            sdf,\n            optpt,\n            algo,\n            skip_opt,\n            pop_size,\n            n_max_gen,\n            n_last,\n            nth_gen,\n            x_tol,\n            verbose,\n            f_tol,\n            resdir,\n            config.lw_imp_curves_df,\n            config.aero_drag_imp_curves_df,\n            config.eng_eff_imp_curves_df,\n            config,\n        )\n        num_results = 1\n        if moo_code == moo.OPTIMIZATION_SUCCEEDED:\n            if moo_results.X.ndim &gt; 1:\n                num_results = moo_results.X.shape[0]\n                # ensure we're only showing unique solution set solutions\n                moo_results.X = np.array(\n                    [list(x) for x in set(tuple(x) for x in moo_results.X)]\n                )\n        if moo_problem is not None:\n            input_vehicle = moo_problem.moobasevehicle\n            print(f\"optimize: {input_vehicle.veh_pt_type}\")\n\n            report_vehicle = moo_problem.mooadvancedvehicle\n            report_scenario = moo_problem.opt_scenario\n        else:\n            input_vehicle = rs.get_vehicle(sel, veh_input_path=config.vehicle_file)\n            report_vehicle = None\n            print(f\"optimize: {input_vehicle.veh_pt_type}\")\n            report_scenario, design_cycle = rs.get_scenario_and_cycle(\n                sel, config.scenario_file, a_vehicle=input_vehicle, config=config\n            )\n\n        # update records, moo_problem can always be returned unless an exception is thrown above\n        if moo_problem is not None:\n            moo_problem.compile_reporting_vars()\n            if moo_problem.reporting_vars is not None:\n                opt_vars_f_name = (\n                    f\"{file_mark}_{algo}_var_record_selection_{sel}.csv\".strip(\"_\")\n                )\n                moo_problem.reporting_vars.to_csv(resdir / opt_vars_f_name)\n\n    elif skip_opt == True:\n        # TODO, is moo_problem.moobasevehicle really the right vehicle here?\n        num_results = 1\n        moo_code = \"NA\"\n        input_vehicle = rs.get_vehicle(sel, veh_input_path=config.vehicle_file)\n        report_scenario, design_cycle = rs.get_scenario_and_cycle(\n            sel, config.scenario_file, a_vehicle=input_vehicle, config=config\n        )\n\n        outdict = rs.vehicle_scenario_sweep(\n            input_vehicle, report_scenario, design_cycle, write_tsv=write_tsv\n        )\n\n    # iterate thru all results from run, num_results can singleton [1] from analysis-only runs\n    # or an array or a list of arrays from a parato front result\n    # res.X holds results of optimization\n    # successful optimization could be 1D (one solution)\n    # [1.0, 2.0, 3.0, 4.0, 5.0]\n    # or nD, multiple solutions on a pareto front or solution set\n    # [[1.0, 2.0, 3.0, 4.0, 5.0],\n    # [ 6.0, 7.0, 8.0, 9.0, 10.0],\n    # [ 11.0,12.0,13.0,14.0,15.0]]\n    for i in range(0, num_results):\n        full_report = True\n\n        report_i = {k: \"\" for k in REPORT_COLS.keys()}\n\n        # important, record sets information: the input vehicle, the scenario, and the optimized vehicle result, if applicable\n        for config_key in rs.Config.__dict__[\"__annotations__\"].keys():\n            if not isinstance(config.__getattribute__(config_key), pd.DataFrame):\n                report_i[\"config_\" + config_key] = config.__getattribute__(config_key)\n\n        for scen_key in rs.Scenario.__dict__[\"__annotations__\"].keys():\n            report_i[\"scenario_\" + scen_key] = report_scenario.__getattribute__(\n                scen_key\n            )\n        for v_input_k in input_vehicle.__dict__.keys():\n            if \"value_props\" not in v_input_k:\n                report_i[\"input_vehicle_value_\" + v_input_k] = (\n                    input_vehicle.__getattribute__(v_input_k)\n                )\n                # we want place-holder blank values for optimization columns even if we're not optimizing\n                report_i[\"optimized_vehicle_value_\" + v_input_k] = None\n\n        # remove value props object\n        if \"optimized_vehicle_value_props\" in report_i:\n            del report_i[\"optimized_vehicle_value_props\"]\n        if \"input_vehicle_value_props\" in report_i:\n            del report_i[\"input_vehicle_value_props\"]\n\n        opt_time = round(time.time() - ti)\n\n        report_i[\"selection\"] = sel\n        veh_selection = int(float(str(sel).split(\"_\")[0]))\n        report_i[\"scenario_name\"] = vdf.loc[veh_selection, \"scenario_name\"]\n        try:\n            report_i[\"veh_year\"] = vdf.loc[veh_selection, \"veh_year\"]\n        except KeyError:\n            report_i[\"veh_year\"] = np.nan\n        report_i[\"veh_pt_type\"] = vdf.loc[veh_selection, \"veh_pt_type\"]\n\n        report_i[\"run_time_[s]\"] = opt_time\n\n        report_i[\"algorithm\"] = algo\n        n_gens_used = 0\n        if not skip_opt:\n            if moo_code in [\n                moo.EXCEPTION_THROWN,\n                moo.OPTIMIZATION_FAILED_TO_CONVERGE,\n            ]:\n                if moo_code == moo.EXCEPTION_THROWN:\n                    report_i[\"n_gen\"] = (\n                        \"Code Exception thrown\"  # TODO, get stacktrace information and add to this\n                    )\n                elif moo_code == moo.OPTIMIZATION_FAILED_TO_CONVERGE:\n                    report_i[\"n_gen\"] = \"Optimization Failed to converge\"\n                report_i = {k: str(v) for k, v in report_i.items()}\n                # reports.append(report_i)\n                result = report_i[\"n_gen\"]\n                logging.info(f\"scenario {sel} failed. {result}\")\n                full_report = False\n                return report_i\n\n            elif moo_code == moo.OPTIMIZATION_SUCCEEDED:\n                report_i[\"opt_result_number\"] = i + 1\n                if moo_results.X.ndim == 1:\n                    x = moo_results.X\n                else:\n                    x = moo_results.X[i, :]\n\n                outdict = moo_problem.get_tco_from_moo_advanced_result(x)\n\n                # Save resulting vehicle model as YAML file\n                if not skip_save_veh:\n                    sim_drives = outdict[\"design_cycle_sim_drive_record\"]\n                    for sd in sim_drives:\n                        # sd_name = sd.name\n                        # sd = sd.to_rust()\n                        sd_file_path = (\n                            resdir\n                            / \"sim_drives\"\n                            / f\"{file_mark}sim_drive_result_{int(sel)}.yaml\".strip(\"_\")\n                        )\n                        sd_file_path.parent.mkdir(parents=True, exist_ok=True)\n                        sd.to_file(str(sd_file_path))\n\n                    veh_result = (\n                        report_vehicle.to_rust()\n                        if not skip_opt\n                        else input_vehicle.to_rust()\n                    )\n                    veh_filepath = (\n                        resdir\n                        / \"vehicles\"\n                        / f\"{file_mark}vehicle_result_{int(sel)}.yaml\".strip(\"_\")\n                    )\n                    veh_filepath.parent.mkdir(parents=True, exist_ok=True)\n                    veh_result.to_file(str(veh_filepath))\n\n                x_dixt = {\n                    knob: x[moo_problem.knobs.index(knob)] for knob in moo_problem.knobs\n                }\n                report_i[\"final_cda_pct\"] = x_dixt.get(moo.KNOB_CDA)\n                report_i[\"final_eng_eff_pct\"] = x_dixt.get(moo.KNOB_FCPEAKEFF)\n                report_i[\"final_ltwt_pct\"] = x_dixt.get(moo.KNOB_WTDELTAPERC)\n                report_i[\"final_max_motor_kw\"] = x_dixt.get(moo.KNOB_mc_max_kw)\n                report_i[\"final_battery_kwh\"] = x_dixt.get(moo.KNOB_ess_max_kwh)\n                report_i[\"final_max_fc_kw\"] = x_dixt.get(moo.KNOB_FCMAXKW)\n                report_i[\"final_fs_kwh\"] = x_dixt.get(moo.KNOB_fs_kwh)\n                for v_input_k in report_vehicle.__dict__.keys():\n                    if \"value_props\" not in v_input_k:\n                        report_i[\"optimized_vehicle_value_\" + v_input_k] = (\n                            report_vehicle.__getattribute__(v_input_k)\n                        )\n\n                n_gens_used = moo_results.history[-1].n_gen\n                report_i[\"fvals_over_gens\"] = [\n                    e.opt.get(\"F\")[0] for e in moo_results.history\n                ]\n                report_i[\"n_gen\"] = n_gens_used\n                report_i[\"max_n_gen\"] = n_max_gen\n        if full_report:\n            (\n                tot_cost,\n                disc_cost,\n                oppy_cost_set,\n                discounted_costs_df,\n                mpgge,\n                veh_cost_set,\n                veh_oper_cost_set,\n                veh_opp_cost_set,\n            ) = (\n                outdict[\"tot_cost\"],\n                outdict[\"disc_cost\"],\n                outdict[\"opportunity_cost_set\"],\n                outdict[\"discounted_costs_df\"],\n                outdict[\"mpgge\"],\n                outdict[\"veh_msrp_set\"],\n                outdict[\"veh_oper_cost_set\"],\n                outdict[\"veh_opp_cost_set\"],\n            )\n\n            print(\n                f\"selection {sel} {gl.PT_TYPES_NUM_TO_STR[optpt]} opt time [s]\",\n                opt_time,\n            )\n            print(\n                f\"selection {sel} {gl.PT_TYPES_NUM_TO_STR[optpt]} total cost\",\n                tot_cost,\n            )\n            print(f\"selection {sel} {gl.PT_TYPES_NUM_TO_STR[optpt]} mpgge\", mpgge)\n            print(\n                f\"selection {sel} {gl.PT_TYPES_NUM_TO_STR[optpt]} MSRP breakdown\",\n                veh_cost_set,\n            )\n            print(\n                f\"selection {sel} {gl.PT_TYPES_NUM_TO_STR[optpt]} Operating Costs breakdown\",\n                veh_oper_cost_set,\n            )\n            print(\n                f\"selection {sel} {gl.PT_TYPES_NUM_TO_STR[optpt]} Opportunity costs breakdown\",\n                veh_opp_cost_set,\n            )\n\n            disc_cost_agg = discounted_costs_df.groupby(\"Category\").sum(\n                numeric_only=True\n            )\n            report_i[\"range_ach_mi\"] = outdict[\"primary_fuel_range_mi\"]\n            report_i[\"target_range_mi\"] = report_scenario.target_range_mi\n            report_i[\"delta_range_mi\"] = (\n                outdict[\"primary_fuel_range_mi\"] - report_scenario.target_range_mi\n            )\n\n            report_i[\"min_speed_at_6pct_grade_in_5min_ach_mph\"] = outdict[\n                \"grade_6_mph_ach\"\n            ]\n            report_i[\"target_min_speed_at_6pct_grade_in_5min_mph\"] = (\n                report_scenario.min_speed_at_6pct_grade_in_5min_mph\n            )\n            report_i[\"delta_min_speed_at_6pct_grade_in_5min_mph\"] = (\n                outdict[\"grade_6_mph_ach\"]\n                - report_scenario.min_speed_at_6pct_grade_in_5min_mph\n            )\n\n            report_i[\"min_speed_at_1p25pct_grade_in_5min_ach_mph\"] = outdict[\n                \"grade_1_25_mph_ach\"\n            ]\n            report_i[\"target_min_speed_at_1p25pct_grade_in_5min_mph\"] = (\n                report_scenario.min_speed_at_1p25pct_grade_in_5min_mph\n            )\n            report_i[\"delta_min_speed_at_1p25pct_grade_in_5min_mph\"] = (\n                outdict[\"grade_1_25_mph_ach\"]\n                - report_scenario.min_speed_at_1p25pct_grade_in_5min_mph\n            )\n\n            report_i[\"max_time_0_to_60mph_at_gvwr_ach_s\"] = outdict[\"zero_to_60_loaded\"]\n            report_i[\"target_max_time_0_to_60mph_at_gvwr_s\"] = (\n                report_scenario.max_time_0_to_60mph_at_gvwr_s\n            )\n            if (\n                outdict[\"zero_to_60_loaded\"] is not None\n            ):  # cannot calculate if it is none (but for some reason, range and grade are handled when none)\n                report_i[\"delta_max_time_0_to_60mph_at_gvwr_s\"] = (\n                    outdict[\"zero_to_60_loaded\"]\n                    - report_scenario.max_time_0_to_60mph_at_gvwr_s\n                )\n\n            report_i[\"max_time_0_to_30mph_at_gvwr_ach_s\"] = outdict[\"zero_to_30_loaded\"]\n            report_i[\"target_max_time_0_to_30mph_at_gvwr_s\"] = (\n                report_scenario.max_time_0_to_30mph_at_gvwr_s\n            )\n            if (\n                outdict[\"zero_to_30_loaded\"] is not None\n            ):  # cannot calculate if it is none (but for some reason, range and grade are handled when none)\n                report_i[\"delta_max_time_0_to_30mph_at_gvwr_s\"] = (\n                    outdict[\"zero_to_30_loaded\"]\n                    - report_scenario.max_time_0_to_30mph_at_gvwr_s\n                )\n\n            report_i.update(mpgge)\n            # report_i[\"payload_capacity_loss_kg\"] = outdict[\"payload_capacity_loss_kg\"] This might be a good var to have\n            report_i[\"payload_cap_cost_multiplier\"] = veh_opp_cost_set[\n                \"payload_cap_cost_multiplier\"\n            ]\n            report_i[\"total_fueling_dwell_time_hr\"] = sum(\n                veh_opp_cost_set[\"net_fueling_dwell_time_hr_per_yr\"]\n            )\n            report_i[\"total_mr_downtime_hr\"] = sum(\n                veh_opp_cost_set[\"net_mr_downtime_hr_per_yr\"]\n            )\n            report_i[\"total_downtime_hr\"] = sum(\n                veh_opp_cost_set[\"total_downtime_hr_per_yr\"]\n            )\n            report_i[\"fueling_dwell_labor_cost_dol\"] = disc_cost_agg.loc[\n                \"fueling labor cost\", \"Discounted Cost [$]\"\n            ]\n            report_i[\"fueling_downtime_oppy_cost_dol\"] = disc_cost_agg.loc[\n                \"fueling downtime cost\", \"Discounted Cost [$]\"\n            ]\n            report_i[\"mr_downtime_oppy_cost_dol\"] = disc_cost_agg.loc[\n                \"MR downtime cost\", \"Discounted Cost [$]\"\n            ]\n            report_i[\"discounted_downtime_oppy_cost_dol\"] = oppy_cost_set[\n                \"discounted_downtime_oppy_cost_dol\"\n            ]\n\n            report_i[\"payload_capacity_cost_dol\"] = oppy_cost_set[\n                \"payload_capacity_cost_dol\"\n            ]\n            report_i[\"glider_cost_dol\"] = veh_cost_set[\"Glider\"]\n            report_i[\"fuel_converter_cost_dol\"] = veh_cost_set[\"Fuel converter\"]\n            report_i[\"fuel_storage_cost_dol\"] = veh_cost_set[\"Fuel Storage\"]\n            report_i[\"motor_control_power_elecs_cost_dol\"] = veh_cost_set[\n                \"Motor &amp; power electronics\"\n            ]\n            report_i[\"plug_cost_dol\"] = veh_cost_set[\"Plug\"]\n            report_i[\"battery_cost_dol\"] = veh_cost_set[\"Battery\"]\n            report_i[\"purchase_tax_dol\"] = veh_cost_set[\"Purchase tax\"]\n            report_i[\"msrp_total_dol\"] = veh_cost_set[\"msrp\"]\n            report_i[\"insurance_cost_dol\"] = disc_cost_agg.loc[\n                \"insurance\", \"Discounted Cost [$]\"\n            ]\n            report_i[\"residual_cost_dol\"] = disc_cost_agg.loc[\n                \"residual cost\", \"Discounted Cost [$]\"\n            ]\n            report_i[\"total_fuel_cost_dol\"] = disc_cost_agg.loc[\n                \"Fuel\", \"Discounted Cost [$]\"\n            ]\n\n            report_i[\"total_maintenance_cost_dol\"] = disc_cost_agg.loc[\n                \"maintenance\", \"Discounted Cost [$]\"\n            ]\n            report_i[\"discounted_tco_dol\"] = disc_cost\n\n            if outdict[\"design_cycle_sim_drive_record\"] is not None:\n                report_i[\"design_cycle_EA_err\"] = {\n                    sdr.cyc.name: sdr.energy_audit_error\n                    for sdr in outdict[\"design_cycle_sim_drive_record\"]\n                }\n                report_i[\"design_cyc_trace_miss_dist_frac\"] = {\n                    sdr.cyc.name: sdr.trace_miss_dist_frac\n                    for sdr in outdict[\"design_cycle_sim_drive_record\"]\n                }\n                report_i[\"design_cyc_trace_miss_time_frac\"] = {\n                    sdr.cyc.name: sdr.trace_miss_time_frac\n                    for sdr in outdict[\"design_cycle_sim_drive_record\"]\n                }\n                report_i[\"design_cyc_trace_miss_speed_mps\"] = {\n                    sdr.cyc.name: sdr.trace_miss_speed_mps\n                    for sdr in outdict[\"design_cycle_sim_drive_record\"]\n                }\n            if outdict[\"accel_sim_drive_record\"] is not None:\n                report_i[\"accel_EA_err\"] = outdict[\n                    \"accel_sim_drive_record\"\n                ].energy_audit_error\n            if outdict[\"accel_loaded_sim_drive_record\"] is not None:\n                report_i[\"accel_loaded_EA_err\"] = outdict[\n                    \"accel_loaded_sim_drive_record\"\n                ].energy_audit_error\n            if outdict[\"grade_6_sim_drive_record\"] is not None:\n                report_i[\"grade_6_EA_err\"] = outdict[\n                    \"grade_6_sim_drive_record\"\n                ].energy_audit_error\n            if outdict[\"grade_1p25_sim_drive_record\"] is not None:\n                report_i[\"grade_1p25_EA_err\"] = outdict[\n                    \"grade_1p25_sim_drive_record\"\n                ].energy_audit_error\n\n        # for all vehicles, save their final TCO TSV files\n        if write_tsv:\n            save_tco_files(outdict[\"tco_files\"], resdir, scenario_name, sel, ts)\n\n        report_i = {k: str(v) for k, v in report_i.items()}\n    return report_i\n</code></pre>"},{"location":"sweep/#t3co.sweep.run_moo","title":"<code>run_moo(sel: int, sdf: pd.DataFrame, optpt: str, algo: str, skip_opt: bool, pop_size: float, n_max_gen: int, n_last: int, nth_gen: int, x_tol: float, verbose: bool, f_tol: float, resdir: str, lw_imp_curves_df: pd.DataFrame, aero_drag_imp_curves_df: pd.DataFrame, eng_eff_imp_curves_df: pd.DataFrame, config: run_scenario.Scenario, **kwargs) -&gt; Tuple[pymoo.core.result.Result, moo.T3COProblem, bool]</code>","text":"<p>This function calls get_objectives_constraints and get_knobs_bounds_curves, and then calls run_optimization to perform the multiobjective optimization</p> <p>Parameters:</p> Name Type Description Default <code>sel</code> <code>int</code> <p>selection number</p> required <code>sdf</code> <code>DataFrame</code> <p>Scenario dataframe</p> required <code>optpt</code> <code>str</code> <p>FASTSim vehicle powertrain type</p> required <code>algo</code> <code>str</code> <p>algorithm name</p> required <code>skip_opt</code> <code>bool</code> <p>skip optimization boolean</p> required <code>pop_size</code> <code>int</code> <p>population size for optimization</p> required <code>n_max_gen</code> <code>int</code> <p>maximum number of generations for optimization</p> required <code>n_last</code> <code>int</code> <p>number of generations to look back for termination</p> required <code>nth_gen</code> <code>int</code> <p>number of generations to evaluate if convergence occurs</p> required <code>x_tol</code> <code>float</code> <p>tolerance in parameter space</p> required <code>verbose</code> <code>book</code> <p>if selected, function prints the optimization process</p> required <code>f_tol</code> <code>float</code> <p>tolerance in objective space</p> required <code>resdir</code> <code>str</code> <p>results directory</p> required <code>lw_imp_curves_df</code> <code>DataFrame</code> <p>light weighting curves dataframe</p> required <code>aero_drag_imp_curves_df</code> <code>DataFrame</code> <p>aero drag curves dataframe</p> required <code>eng_eff_imp_curves_df</code> <code>DataFrame</code> <p>engine efficiency curve dataframe</p> required <code>config</code> <code>Config</code> <p>Config class object</p> required <p>Returns:</p> Name Type Description <code>moo_results</code> <code>pymoo.core.result.Result</code> <p>optimization results object</p> <code>moo_problem</code> <code>T3COProblem</code> <p>minimization problem that calculates TCO</p> <code>moo_code</code> <code>bool</code> <p>Error message</p> Source code in <code>t3co/sweep.py</code> Python<pre><code>def run_moo(\n    sel: int,\n    sdf: pd.DataFrame,\n    optpt: str,\n    algo: str,\n    skip_opt: bool,\n    pop_size: float,\n    n_max_gen: int,\n    n_last: int,\n    nth_gen: int,\n    x_tol: float,\n    verbose: bool,\n    f_tol: float,\n    resdir: str,\n    lw_imp_curves_df: pd.DataFrame,\n    aero_drag_imp_curves_df: pd.DataFrame,\n    eng_eff_imp_curves_df: pd.DataFrame,\n    config: run_scenario.Scenario,\n    **kwargs,\n) -&gt; Tuple[pymoo.core.result.Result, moo.T3COProblem, bool]:\n    \"\"\"\n    This function calls get_objectives_constraints and get_knobs_bounds_curves, and then calls run_optimization to perform the multiobjective optimization\n\n    Args:\n        sel (int): selection number\n        sdf (DataFrame): Scenario dataframe\n        optpt (str): FASTSim vehicle powertrain type\n        algo (str): algorithm name\n        skip_opt (bool): skip optimization boolean\n        pop_size (int): population size for optimization\n        n_max_gen (int): maximum number of generations for optimization\n        n_last (int): number of generations to look back for termination\n        nth_gen (int): number of generations to evaluate if convergence occurs\n        x_tol (float): tolerance in parameter space\n        verbose (book): if selected, function prints the optimization process\n        f_tol (float): tolerance in objective space\n        resdir (str): results directory\n        lw_imp_curves_df (DataFrame): light weighting curves dataframe\n        aero_drag_imp_curves_df (DataFrame): aero drag curves dataframe\n        eng_eff_imp_curves_df (DataFrame): engine efficiency curve dataframe\n        config (Config): Config class object\n\n    Returns:\n        moo_results (pymoo.core.result.Result): optimization results object\n        moo_problem (T3COProblem): minimization problem that calculates TCO\n        moo_code (bool): Error message\n    \"\"\"\n    objectives, constraints = get_objectives_constraints(sel, sdf)\n\n    knobs_bounds, curve_settings = get_knobs_bounds_curves(\n        sel,\n        optpt,\n        sdf,\n        lw_imp_curves_df,\n        aero_drag_imp_curves_df,\n        eng_eff_imp_curves_df,\n    )\n\n    # moo_reults has res.X, res.F np arrays of opt params &amp; objective space resutls, respectively\n    moo_results, moo_problem, moo_code = moo.run_optimization(\n        pop_size,\n        n_max_gen,\n        knobs_bounds,\n        sel,\n        optimize_pt=optpt,\n        skip_optimization=skip_opt,\n        obj_list=objectives,\n        constr_list=constraints,\n        verbose=verbose,\n        n_last=n_last,\n        algo=algo,\n        nth_gen=nth_gen,\n        x_tol=x_tol,\n        f_tol=f_tol,\n        config=config,\n        **curve_settings,\n        **kwargs,\n    )\n    # return input_vehicle, report_vehicle, report_scenario, out_dict\n    return moo_results, moo_problem, moo_code\n</code></pre>"},{"location":"sweep/#t3co.sweep.run_optimize_analysis","title":"<code>run_optimize_analysis(sel: str | int, vdf: pd.DataFrame, sdf: pd.DataFrame, skip_all_opt: bool, config: run_scenario.Config, report_kwargs: dict, REPORT_COLS: dict) -&gt; dict</code>","text":"<p>This function runs the optimization function based on skip_all_opt input to return the report_i dictionary with T3CO results for each selection.</p> <p>Parameters:</p> Name Type Description Default <code>sel</code> <code>str | int</code> <p>selection number</p> required <code>vdf</code> <code>pd.DataFrame</code> <p>Dataframe of input vehicle file</p> required <code>sdf</code> <code>pd.DataFrame</code> <p>Dataframe of input scenario file</p> required <code>skip_all_opt</code> <code>bool</code> <p>Skip all optimization. If true, then the optimizer is not run for any scenario</p> required <code>config</code> <code>run_scenario.Config</code> <p>Config object</p> required <code>report_kwargs</code> <code>dict</code> <p>Dictionary of args required for running T3CO</p> required <code>REPORT_COLS</code> <code>dict</code> <p>Dictionary of reporting columns from T3CO</p> required <p>Returns:</p> Name Type Description <code>report_i</code> <code>dict</code> <p>Dictionary of T3CO results for given selection</p> Source code in <code>t3co/sweep.py</code> Python<pre><code>def run_optimize_analysis(\n    sel: str | int,\n    vdf: pd.DataFrame,\n    sdf: pd.DataFrame,\n    skip_all_opt: bool,\n    config: run_scenario.Config,\n    report_kwargs: dict,\n    REPORT_COLS: dict,\n) -&gt; dict:\n    \"\"\"\n    This function runs the optimization function based on skip_all_opt input to return the report_i dictionary with T3CO results for each selection.\n\n    Args:\n        sel (str | int): selection number\n        vdf (pd.DataFrame): Dataframe of input vehicle file\n        sdf (pd.DataFrame): Dataframe of input scenario file\n        skip_all_opt (bool): Skip all optimization. If true, then the optimizer is not run for any scenario\n        config (run_scenario.Config): Config object\n        report_kwargs (dict): Dictionary of args required for running T3CO\n        REPORT_COLS (dict): Dictionary of reporting columns from T3CO\n\n    Returns:\n        report_i (dict): Dictionary of T3CO results for given selection\n    \"\"\"\n    if skip_all_opt is True or skip_all_opt == \"TRUE\":\n        report_i = optimize(\n            sel=sel,\n            sdf=sdf,\n            vdf=vdf,\n            algo=\"None\",\n            report_kwargs=report_kwargs,\n            REPORT_COLS=REPORT_COLS,\n            skip_opt=True,\n            config=config,\n            write_tsv=False,\n        )\n    else:\n        for algo in algorithms:\n            print(f\"run optimize {sel}\")\n            report_i = optimize(\n                sel=sel,\n                sdf=sdf,\n                vdf=vdf,\n                algo=algo,\n                report_kwargs=report_kwargs,\n                REPORT_COLS=REPORT_COLS,\n                skip_opt=False,\n                config=config,\n                write_tsv=False,\n            )\n\n    logging.info(f\"done with selection {sel}: {report_i['scenario_name']}\")\n\n    return report_i\n</code></pre>"},{"location":"sweep/#t3co.sweep.run_vehicle_scenarios","title":"<code>run_vehicle_scenarios(config: run_scenario.Config, REPORT_COLS: dict, **kwargs) -&gt; Tuple[List[int | str], pd.DataFrame, pd.DataFrame, bool, dict, dict]</code>","text":"<p>This function reads the input files, validates inputs, compiles the selections, and returns a clean set of inputs that are needed for the current analysis.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>Config object containing analysis attributes and scenario attribute overrides</p> required <code>REPORT_COLS</code> <code>dict</code> <p>Dictionary of reporting columns from T3CO</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>input validation error</p> <code>Exception</code> <p>optimization error</p> <p>Returns:</p> Type Description <code>Tuple[List[int | str], pd.DataFrame, pd.DataFrame, bool, dict, dict]</code> <p>selections, vdf, sdf, skip_all_opt, report_kwargs, REPORT_COLS (Tuple[List[int|str], pd.DataFrame, pd.DataFrame, bool, dict, dict]): Selections list, vehicle dataframe, scenario dataframe, skip all optimization, report arguments, and report columns</p> Source code in <code>t3co/sweep.py</code> Python<pre><code>def run_vehicle_scenarios(\n    config: run_scenario.Config,\n    REPORT_COLS: dict,\n    **kwargs,\n) -&gt; Tuple[List[int | str], pd.DataFrame, pd.DataFrame, bool, dict, dict]:\n    \"\"\"\n    This function reads the input files, validates inputs, compiles the selections, and returns a clean set of inputs that are needed for the current analysis.\n\n\n    Args:\n        config (Config): Config object containing analysis attributes and scenario attribute overrides\n        REPORT_COLS (dict): Dictionary of reporting columns from T3CO\n\n    Raises:\n        Exception: input validation error\n        Exception: optimization error\n\n    Returns:\n        selections, vdf, sdf, skip_all_opt, report_kwargs, REPORT_COLS (Tuple[List[int|str], pd.DataFrame, pd.DataFrame, bool, dict, dict]): Selections list, vehicle dataframe, scenario dataframe, skip all optimization, report arguments, and report columns\n    \"\"\"\n    vdf = pd.read_csv(config.vehicle_file, index_col=\"selection\", skip_blank_lines=True)\n    sdf = pd.read_csv(\n        config.scenario_file, index_col=\"selection\", skip_blank_lines=True\n    )\n    check_input_files(vdf, \"vehicles\", config.vehicle_file)\n    check_input_files(sdf, \"scenario\", config.scenario_file)\n    config.eng_eff_imp_curves_df = pd.read_csv(config.eng_eff_imp_curves)\n    config.lw_imp_curves_df = pd.read_csv(config.lw_imp_curves)\n    config.aero_drag_imp_curves_df = pd.read_csv(config.aero_drag_imp_curves)\n\n    # optimization scenario parameters where we get our baseline vehicle and scenario\n    global FASTSIM_INPUTS, OTHER_INPUTS\n    FASTSIM_INPUTS = config.vehicle_file\n    OTHER_INPUTS = config.scenario_file\n    print(\"vehicle src:\", config.vehicle_file)\n    print(\"scenario src:\", config.scenario_file)\n\n    for scen_key in rs.Scenario.__dict__[\"__annotations__\"].keys():\n        REPORT_COLS.update({\"scenario_\" + scen_key: \"\"})\n\n    df = pd.read_csv(FASTSIM_INPUTS)\n\n    for vc in df.columns.tolist():\n        REPORT_COLS.update({\"optimized_vehicle_value_\" + vc: \"\"})\n\n    for vc in df.columns.tolist():\n        REPORT_COLS.update({\"input_vehicle_value_\" + vc: \"\"})\n\n    # optimizer and sweep tuning\n    report_kwargs = dict(kwargs)\n    n_max_gen = kwargs.pop(\n        \"n_max_gen\", 100\n    )  # max number of generations if convergence not met\n    pop_size = kwargs.pop(\"pop_size\", 30)  # population of each generation\n    nth_gen = kwargs.pop(\n        \"nth_gen\", 1\n    )  # period of generations in which to evaluate if convergence happens\n    algorithms = kwargs.pop(\"algo\")\n    n_last = kwargs.pop(\n        \"n_last\", 5\n    )  # number of generations to look back for establishing convergence\n    x_tol = kwargs.pop(\"x_tol\", 0.5)  # parameter space tolerance\n    f_tol = kwargs.pop(\"f_tol\", 3.0)  # objective space tolerance\n    verbose = kwargs.pop(\"verbose\", False)\n    look_for = kwargs.pop(\"look_for\", [\"\"])\n    assert isinstance(\n        look_for, list\n    ), \"look_for should have been input or cast as a list at this point\"\n    selections = kwargs.pop(\n        \"selections\", -1\n    )  # list of integers representing scenario selections, ex: [34,35,36]\n    exclude = kwargs.pop(\"exclude\", [\"&gt;{-&lt;&gt;-}&lt;\"])\n    dir_mark = kwargs.pop(\"dir_mark\", \"\")\n    file_mark = kwargs.pop(\"file_mark\", \"\")\n    skip_save_veh = kwargs.pop(\"skip_save_veh\")\n    skip_all_opt = kwargs.pop(\"skip_all_opt\")\n    do_input_validation = kwargs.pop(\"do_input_validation\")\n    write_tsv = kwargs.pop(\"do_input_validation\", False)\n\n    report_kwargs[\"n_max_gen\"] = n_max_gen\n    report_kwargs[\"pop_size\"] = pop_size\n    report_kwargs[\"nth_gen\"] = nth_gen\n    report_kwargs[\"algorithms\"] = algorithms\n    report_kwargs[\"n_last\"] = n_last\n    report_kwargs[\"look_for\"] = look_for\n    report_kwargs[\"selections\"] = selections\n    report_kwargs[\"exclude\"] = exclude\n    report_kwargs[\"dir_mark\"] = dir_mark\n    report_kwargs[\"file_mark\"] = file_mark\n    report_kwargs[\"skip_save_veh\"] = skip_save_veh\n    report_kwargs[\"skip_all_opt\"] = skip_all_opt\n    report_kwargs[\"do_input_validation\"] = do_input_validation\n    report_kwargs[\"write_tsv\"] = write_tsv\n    report_kwargs[\"verbose\"] = verbose\n\n    if not file_mark.endswith(\"_\"):\n        file_mark += \"_\"\n    report_kwargs[\"file_mark\"] = file_mark\n    # results dir setup\n    ts = strftime(\"%Y-%m-%d_%H-%M-%S\", gmtime())\n    report_kwargs[\"ts\"] = ts\n    report_kwargs[\"skip_save_veh\"] = skip_save_veh\n\n    if config.resfile_suffix is not None:\n        RES_FILE = f\"{file_mark}results_{ts}_{str(config.resfile_suffix)}.csv\".strip(\n            \"_\"\n        )\n    else:\n        selections_string = (\n            str(selections)\n            .strip(\"[]\")\n            .replace(\" \", \"\")\n            .replace(\"'\", \"\")\n            .replace(\",\", \"-\")\n        )\n        RES_FILE = f\"{file_mark}results_{ts}_sel_{selections_string[:20]}.csv\".strip(\n            \"_\"\n        )\n    report_kwargs[\"RES_FILE\"] = RES_FILE\n    if selections == -1:\n        selections = vdf.index\n\n    if report_kwargs[\"dst_dir\"] is None and config.dst_dir is None:\n        resdir = Path(os.path.abspath(__file__)).parents[1] / f\"results{dir_mark}\"\n    elif report_kwargs[\"dst_dir\"] is not None:\n        resdir = Path(report_kwargs[\"dst_dir\"])\n    else:\n        resdir = Path(config.dst_dir)\n\n    if not resdir.exists():\n        resdir.mkdir(parents=True)\n\n    report_kwargs[\"resdir\"] = resdir\n\n    # with open(str(resdir / RES_FILE), \"a\", newline=\"\") as f:\n    #     print(\"writing to \", resdir / RES_FILE)\n    #     writer = csv.writer(f)\n    #     writer.writerow(REPORT_COLS.keys())\n\n    loggingfname = Path(\n        str(Path(resdir / f\"{file_mark}sweep_error_log_{ts}.log\")).strip(\"_\")\n    )\n    logging.basicConfig(\n        filename=loggingfname,\n        level=logging.INFO,\n        filemode=\"a\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n        format=\"%(asctime)s %(levelname)-8s %(message)s\",\n        force=True,\n    )\n    logging.info(f\"kwargs {report_kwargs}\")\n\n    # list of report dataframes to write final output at each iteration\n\n    def input_validation(\n        sel: float, optpt: str, algo: str, config: run_scenario.Config\n    ) -&gt; None:\n        \"\"\"\n        This function obtains the vehicle, scenario, and cycle object for a given selection and runs optimization to validate inputs\n\n        Args:\n            sel (float): selection number\n            optpt (str): vehicle powertrain type\n            algo (str): algorithm name\n            config (Config): Config object\n\n        Returns:\n            None: None\n        \"\"\"\n        v = rs.get_vehicle(\n            sel,\n            veh_input_path=config.vehicle_file,\n        )\n        print(f\"input_validation: {sel} {v.veh_pt_type}\")\n        s, c = rs.get_scenario_and_cycle(\n            sel,\n            config.scenario_file,\n            a_vehicle=v,\n            config=config,\n            do_input_validation=True,\n        )\n        rs.check_phev_init_socs(v, s)\n\n        knobs_bounds, curve_settings = get_knobs_bounds_curves(\n            sel,\n            optpt,\n            sdf,\n            config.lw_imp_curves_df,\n            config.aero_drag_imp_curves_df,\n            config.eng_eff_imp_curves_df,\n        )\n        objectives, constraints = get_objectives_constraints(sel, sdf, verbose=False)\n\n        _ = moo.run_optimization(\n            pop_size,\n            n_max_gen,\n            knobs_bounds,\n            sel,\n            optimize_pt=optpt,\n            skip_optimization=True,\n            obj_list=objectives,\n            constr_list=constraints,\n            verbose=verbose,\n            n_last=n_last,\n            algo=algo,\n            nth_gen=nth_gen,\n            x_tol=x_tol,\n            f_tol=f_tol,\n            config=config,\n            do_input_validation=True,\n            **curve_settings,\n            **kwargs,\n        )\n        return None\n\n    if do_input_validation:\n        st = time.time()\n        print(\"sweep:: Running input validation...\")\n        badinputs = False\n        noinputs = True\n        for sel, scenario_name, optpt in zip(\n            vdf.index, vdf[\"scenario_name\"], vdf[\"veh_pt_type\"]\n        ):\n            if skip_scenario(\n                sel,\n                selections,\n                scenario_name,\n                report_kwargs=report_kwargs,\n                verbose=False,\n            ):\n                # print(f'input_validation skip selection: {sel}')\n                continue\n\n            for algo in algorithms:\n                try:\n                    algopart = f\"algorithm: {algo.rjust(15)} or None if skipping\"\n                    print(\n                        f\"sweep:: validating input {sel}:{scenario_name}\".ljust(90),\n                        algopart,\n                    )\n                    # print(f'config: {config}')\n\n                    input_validation(sel, optpt, algo, config)\n                except KeyboardInterrupt:\n                    raise\n                except Exception as e:\n                    badinputs = True\n                    logging.exception(\n                        f\"sweep:: INPUT ERROR selection {sel}, {scenario_name} :: {e}\",\n                        stack_info=False,\n                        exc_info=True,\n                    )\n                noinputs = False\n        print(f\"sweep:: Finished input validation, time [s] {round(time.time()-st)}\")\n        if badinputs:\n            raise Exception(\n                f\"sweep:: input_validation failure, see log file!\\n{loggingfname}\"\n            )\n        if noinputs:\n            raise Exception(\n                f\"sweep:: no inputs available, see log file!\\n{loggingfname}\"\n            )\n\n    return selections, vdf, sdf, skip_all_opt, report_kwargs, REPORT_COLS\n</code></pre>"},{"location":"sweep/#t3co.sweep.save_tco_files","title":"<code>save_tco_files(tco_files: dict, resdir: str, scenario_name: str, sel: str, ts: str) -&gt; None</code>","text":"<p>This function saves the intermediary files as tsv</p> <p>Parameters:</p> Name Type Description Default <code>tco_files</code> <code>dict</code> <p>Contains all TCO calculation dataframes</p> required <code>resdir</code> <code>str</code> <p>result directory strong</p> required <code>scenario_name</code> <code>str</code> <p>scenario name</p> required <code>sel</code> <code>str</code> <p>selection(s)</p> required <code>ts</code> <code>str</code> <p>timestring</p> required Source code in <code>t3co/sweep.py</code> Python<pre><code>def save_tco_files(\n    tco_files: dict, resdir: str, scenario_name: str, sel: str, ts: str\n) -&gt; None:\n    \"\"\"\n    This function saves the intermediary files as tsv\n\n    Args:\n        tco_files (dict): Contains all TCO calculation dataframes\n        resdir (str): result directory strong\n        scenario_name (str): scenario name\n        sel (str): selection(s)\n        ts (str): timestring\n    \"\"\"\n    scenario_name = re.sub(\"s\", \"-\", scenario_name)\n    scenario_name = re.sub(\"[^a-zA-Z0-9 \\n.]\", \"\", scenario_name)\n    tco_files_path = resdir / f\"tco_files_{ts}\" / f\"{sel}_{scenario_name}\"\n    tco_files_path.mkdir(parents=True, exist_ok=True)\n\n    veh_eff_df = tco_files[\"veh_eff_df\"]\n    veh_exp_df = tco_files[\"veh_exp_df\"]\n    veh_txp_df = tco_files[\"veh_txp_df\"]\n    veh_shr_df = tco_files[\"veh_shr_df\"]\n    veh_fxp_df = tco_files[\"veh_fxp_df\"]\n    ann_trv_df = tco_files[\"ann_trv_df\"]\n    reg_sls_df = tco_files[\"reg_sls_df\"]\n    survivl_df = tco_files[\"survivl_df\"]\n    veh_spt_df = tco_files[\"veh_spt_df\"]\n    stock = tco_files[\"stock\"]\n    ownership_costs_df = tco_files[\"ownership_costs_df\"]\n    discounted_costs_df = tco_files[\"discounted_costs_df\"]\n\n    veh_eff_df.to_csv(tco_files_path / gl.FUEL_EFF_TSV, sep=\"\\t\", index=False)\n    veh_exp_df.to_csv(tco_files_path / gl.VEH_EXP_TSV, index=False, sep=\"\\t\")\n    veh_txp_df.to_csv(tco_files_path / gl.TRAVEL_EXP_TSV, index=False, sep=\"\\t\")\n    veh_shr_df.to_csv(tco_files_path / gl.MARKET_SHARE_TSV, index=False, sep=\"\\t\")\n    veh_fxp_df.to_csv(tco_files_path / gl.FUEL_EXPENSE_TSV, index=False, sep=\"\\t\")\n    ann_trv_df.to_csv(tco_files_path / gl.ANN_TRAVEL_TSV, index=False, sep=\"\\t\")\n    reg_sls_df.to_csv(tco_files_path / gl.REGIONAL_SALES_TSV, index=False, sep=\"\\t\")\n    survivl_df.to_csv(tco_files_path / gl.SURVIVAL_TSV, index=False, sep=\"\\t\")\n    veh_spt_df.to_csv(tco_files_path / gl.FUEL_SPLIT_TSV, index=False, sep=\"\\t\")\n\n    stock.to_csv(tco_files_path / \"stock_v01.tsv\", sep=\"\\t\", index=False)\n    # emissions.to_csv(                  tco_files_path / 'emissions_v01.tsv', sep='\\t', index=False)\n    ownership_costs_df.to_csv(\n        tco_files_path / \"ownership-costs_v01.tsv\", sep=\"\\t\", index=False\n    )\n    discounted_costs_df.to_csv(\n        tco_files_path / \"discounted-ownership-costs_v01.tsv\", sep=\"\\t\", index=False\n    )\n</code></pre>"},{"location":"sweep/#t3co.sweep.skip_scenario","title":"<code>skip_scenario(sel, selections, scenario_name, report_kwargs, verbose=False) -&gt; bool</code>","text":"<p>This function checks if given selection is present in exclude or look_for selections</p> <p>Parameters:</p> Name Type Description Default <code>sel</code> <code>float</code> <p>description</p> required <code>scenario_name</code> <code>str</code> <p>scenario name</p> required <code>verbose</code> <code>bool</code> <p>if selected, prints out scenarios that are skipped. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>if not present, returns True; Else False</p> Source code in <code>t3co/sweep.py</code> Python<pre><code>def skip_scenario(sel, selections, scenario_name, report_kwargs, verbose=False) -&gt; bool:\n    \"\"\"\n    This function checks if given selection is present in exclude or look_for selections\n\n    Args:\n        sel (float): _description_\n        scenario_name (str): scenario name\n        verbose (bool, optional): if selected, prints out scenarios that are skipped. Defaults to False.\n\n    Returns:\n        bool: if not present, returns True; Else False\n    \"\"\"\n    if any(ex in scenario_name for ex in report_kwargs[\"exclude\"]):\n        if verbose:\n            print(\n                f\"skipping {sel} {exclude} has parts in scenario_name {scenario_name}\"\n            )\n        return True\n    if not any(lf in scenario_name for lf in report_kwargs[\"look_for\"]):\n        if verbose:\n            print(f\"skipping {sel}, want to run from {look_for}\")\n        return True\n    # print(str(sel))\n    # print(list(set([selection_id.split(\"_\")[0] for selection_id in selections])))\n    sel_set = list(\n        set([str(selection_id).split(\"_\")[0] for selection_id in selections])\n    )\n    if str(sel) not in sel_set:\n        if verbose:\n            print(f\"skipping {sel} not in desired selections:{selections}\")\n        return True\n    return False\n</code></pre>"},{"location":"t3co_modules/","title":"T3CO Modules","text":"<p>The T3CO submodules are categorized into:</p> <ul> <li>Sweep module:</li> <li>sweep.py</li> <li>Run Modules:</li> <li>run_scenario.py</li> <li>generateinputs.py</li> <li>Global.py</li> <li>TCO Modules:</li> <li>opportunity_costs.py</li> <li>tcocalc.py</li> <li>tco_analysis.py</li> <li>tco_stock_emissions.py</li> <li>MOO Modules:</li> <li>moo.py</li> <li>Objectives Modules:</li> <li>accel.py</li> <li>gradeability.py</li> <li>fueleconomy.py</li> </ul>"},{"location":"t3co_outputs_descriptions/","title":"T3CO Output Parameters Descriptions","text":"T3CO Output Parameter Description Data type(s) selection Selection number of vehicle/scenario int scenario_name Name of the selected scenario/vehicle string veh_year Current year int veh_pt_type Vehicle powertrain type string pareto_front_number Optimization solution number from pareto front int run_time_[s] T3CO run time for selected vehicle/scenario float algorithm Algorithm for pymoo optimization. From\u00a0 [\"NSGA2\", \"PatternSearch\"] string n_gen Number of generations of genetic algorithm optimization int fvals_over_gens Optimization objective space values across generations float design_cyc_trace_miss_dist_frac Fractional difference between achieved cumulative distance and prescribed cumulative distance. If composite drivecycle is input, the distance trace miss is output as a list dict/list[dict] design_cyc_trace_miss_time_frac Fractional difference between achieved time when trace miss is and prescribed cumulative distance. If composite drivecycle is input, the time trace miss is output as a list dict/list[dict] design_cyc_trace_miss_speed_mps Maximum speed (mps) by which vehicle\u2019s speed falls behind prescribed speed trace. If composite drivecycle is input, the time trace miss is output as a list dict/list[dict] design_cycle_EA_err Fractional difference between achieved energy consumption vs consumption estimated based on the input drivecycle. Checks for conservation of energy in the simulated results. dict/list[dict] accel_EA_err Fractional difference between achieved energy consumption vs consumption estimated based on the acceleration test drivecycle with current vehicle mass.\u00a0 Checks for conservation of energy in the simulated results dict/list[dict] accel_loaded_EA_err Fractional difference between achieved energy consumption vs consumption estimated based on the acceleration test drivecycle with fully laden vehicle. Checks for conservation of energy in the simulated results dict/list[dict] grade_6_EA_err Fractional difference between achieved energy consumption vs consumption estimated based on the 6 % gradeability test drivecycle with fully laden vehicle.\u00a0 Checks for conservation of energy in the simulated results dict/list[dict] grade_1p25_EA_err Fractional difference between achieved energy consumption vs consumption estimated based on the 1.25 % gradeability test drivecycle with fully laden vehicle.\u00a0 Checks for conservation of energy in the simulated results dict/list[dict] final_cda_pct Optimization result for percent improvement in Cd*A (drag coefficient times frontal area) - based on aero drag improvement curve float final_eng_eff_pct Optimization result for percent improvement in engine efficiency - based on engine efficiency improvement curve float final_ltwt_pct Optimization result for percent improvement in vehicle mass - based on lightweighting improvement curve float final_max_motor_kw Optimization result for motor power in kW - bound between scenario.knob_min_motor_kw and scenario.knob_max_motor_kw float final_battery_kwh Optimization result for ESS max capacity in kWh - bound between scenario.knob_min_ess_kwh and scenario.knob_max_ess_kwh float final_max_fc_kw Optimization result for fuel converter max power in kW - bound between scenario.knob_min_fc_kw and scenario.knob_max_fc_kw float final_fs_kwh Optimization result for fuel storage max capacity in kWh - bound between scenario.knob_min_fs_kwh and scenario.knob_max_fs_kwh float range_ach_mi Range achieved by vehicle based on drivecycle simulation float target_range_mi Target range constraint for design vehicle during optimization float delta_range_mi Difference between range achieved from simulation and target range of the design vehicle float min_speed_at_6pct_grade_in_5min_ach_mph Final speed achieved by design vehicle during 6 % gradeability test run for 5 mins float target_min_speed_at_6pct_grade_in_5min_mph Target speed for design vehicle during 6 % gradeability test run for 5 mins float delta_min_speed_at_6pct_grade_in_5min_mph Difference between final speed achieved and target speed during 6% gradeability test float min_speed_at_1p25pct_grade_in_5min_ach_mph Final speed achieved by design vehicle during 1.25 % gradeability test run for 5 mins float target_min_speed_at_1p25pct_grade_in_5min_mph Target speed for design vehicle during 1.25 % gradeability test run for 5 mins float delta_min_speed_at_1p25pct_grade_in_5min_mph Difference between final speed achieved and target speed during 1.25% gradeability test float max_time_0_to_60mph_at_gvwr_ach_s Time taken achieved by fully laden design vehicle during acceleration for 0 to 60mph float target_max_time_0_to_60mph_at_gvwr_s Target time taken for fully laden design vehicle during acceleration for 0 to 60mph float delta_max_time_0_to_60mph_at_gvwr_s Difference between time taken by simulated vehicle and target time for fully laden acceleration test from 0 to 60mph float max_time_0_to_30mph_at_gvwr_ach_s Time taken achieved by fully laden design vehicle during acceleration for 0 to 30mph float target_max_time_0_to_30mph_at_gvwr_s Target time taken for fully laden design vehicle during acceleration for 0 to 30mph float delta_max_time_0_to_30mph_at_gvwr_s Difference between time taken by simulated vehicle and target time for fully laden acceleration test from 0 to 30mph float glider_cost_dol Estimated glider component cost in dollars - contributes to MSRP float fuel_converter_cost_dol Estimated fuel converter component cost in dollars - contributes to MSRP float fuel_storage_cost_dol Estimated fuel storage component cost in dollars - contributes to MSRP float motor_control_power_elecs_cost_dol Estimated motor and power electronics component cost in dollars - contributes to MSRP float plug_cost_dol Estimated plugin charger component cost in dollars - contributes to MSRP float battery_cost_dol Estimated battery/ESS component cost in dollars - contributes to MSRP float purchase_tax_dol Estimated purchased/excise tax\u00a0 in dollars - calculated from MSRP float msrp_total_dol Estimated manufacturer's suggested retail price in dollars - calculated from vehicle component costs float total_fuel_cost_dol Estimated fuel operating cost in dollars - calculated from energy consumption and fuel prices float total_maintenance_cost_dol Estimated maintenance operating cost in dollars - calculated from VMT and scenario.maint_oper_cost_dol_per_mi float mpgge Miles per Gallon of Gasoline Equivalent - from drivecycle simulation float grid_mpgge Miles per Gallon of Gasoline Equivalent effect to grid - mpgge times charger efficiency float mpgde Miles per Gallon of Diesel Equivalent - from drivecycle simulation float kwh_per_mi Energy spent per mile of operation - estimated from drivecycle simulation float payload_cap_cost_multiplier Lost payload capacity opportunity cost factor - represents the fractionally extra vehicle required to compensate for reduced payload capacity compared to conventional vehicle - Currently only for Class 8 vehicles float total_fueling_dwell_time_hr Total dwell time of vehicle due to fueling/charging - used to estimate downtime opportunity cost float total_mr_downtime_hr Total dwell time of vehicle due to maintenance &amp; repair (planned, unplanned, and tire replacement) - used to estimate downtime opportunity cost float total_downtime_hr Total downtime due to fueling/charging and maintenance events float fueling_dwell_labor_cost_dol Estimated labor cost incurred during fueling/charging dwell time float fueling_downtime_oppy_cost_dol Estimated opportunity cost associated with fueling/charging dwell time float mr_downtime_oppy_cost_dol Estimated labor cost incurred during maintenance &amp; repair downtime float discounted_downtime_oppy_cost_dol Estimated discounted opportunity cost for both fueling dwell time and M&amp;R downtime in dollars - estimation is based on config.TCO_method float payload_capacity_cost_dol Lost payload capacity opportunity cost in dollars - estimated from payload_cap_cost_multiplier and estimated tco float insurance_cost_dol Estimated insurance cost of vehicle in dollars - estimated from MSRP and scenario.insurance_rates_pct_per_yr float residual_cost_dol Estimated residual cost of vehicle in dollars (residual value is the negative of residual cost) float discounted_tco_dol Estimated discounted Total Cost of Ownership in dollars - Calculated using one of DIRECT or EFFICIENCY method from different cost components, discounted year over year at a rate of scenario.discount_rate_pct_per_yr, and calculated for scenario.vehicle_life_yr float"},{"location":"tco_analysis/","title":"TCO Analysis Sub-Module","text":""},{"location":"tco_analysis/#t3co.tco.tco_analysis","title":"<code>t3co.tco.tco_analysis</code>","text":""},{"location":"tco_analysis/#t3co.tco.tco_analysis.calc_discountedTCO","title":"<code>calc_discountedTCO(scenario: run_scenario.Scenario, discounted_costs_df: pd.DataFrame, veh_cost_set: dict, veh_opp_cost_set: dict, sim_drive: fastsim.simdrive.SimDrive, TCO_switch: str = 'DIRECT') -&gt; Tuple[float, dict, dict]</code>","text":"<p>This function calculates the discounted Total Cost of Ownerhip (discounted to account for time-value of money). There are two methods to calculate discounted TCO - 'DIRECT' and 'EFFICIENCY'</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for current selection</p> required <code>discounted_costs_df</code> <code>pd.DataFrame</code> <p>discounted operating costs dataframe</p> required <code>veh_cost_set</code> <code>dict</code> <p>Dictionary containing MSRP breakdown</p> required <code>veh_opp_cost_set</code> <code>dict</code> <p>Dictionary containing opportunity costs breakdown</p> required <code>sim_drive</code> <code>fastsim.simdrive.SimDrive</code> <p>FASTSim.simdrive.SimDrive object containing inputs and outputs from vehicle simulation over a cycle</p> required <code>TCO_switch</code> <code>str</code> <p>Switch between different TCO calculations - 'DIRECT' or 'EFFICIENCY'. Defaults to 'DIRECT'.</p> <code>'DIRECT'</code> <p>Returns:</p> Name Type Description <code>discounted_tco_dol</code> <code>float</code> <p>Discounted Total Cost of Ownership value</p> <code>oppy_cost_dol_set</code> <code>dict</code> <p>Dictionary containing discounted opportunity costs breakdown</p> <code>veh_oper_cost_set</code> <code>dict</code> <p>Dictionary containing discounted operating costs breakdown</p> Source code in <code>t3co/tco/tco_analysis.py</code> Python<pre><code>def calc_discountedTCO(\n    scenario: run_scenario.Scenario,\n    discounted_costs_df: pd.DataFrame,\n    veh_cost_set: dict,\n    veh_opp_cost_set: dict,\n    sim_drive: fastsim.simdrive.SimDrive,\n    TCO_switch: str = \"DIRECT\",\n) -&gt; Tuple[float, dict, dict]:\n    \"\"\"\n    This function calculates the discounted Total Cost of Ownerhip (discounted to account for time-value of money).\n    There are two methods to calculate discounted TCO - 'DIRECT' and 'EFFICIENCY'\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object for current selection\n        discounted_costs_df (pd.DataFrame): discounted operating costs dataframe\n        veh_cost_set (dict): Dictionary containing MSRP breakdown\n        veh_opp_cost_set (dict): Dictionary containing opportunity costs breakdown\n        sim_drive (fastsim.simdrive.SimDrive): FASTSim.simdrive.SimDrive object containing inputs and outputs from vehicle simulation over a cycle\n        TCO_switch (str, optional): Switch between different TCO calculations - 'DIRECT' or 'EFFICIENCY'. Defaults to 'DIRECT'.\n\n    Returns:\n        discounted_tco_dol (float): Discounted Total Cost of Ownership value\n        oppy_cost_dol_set (dict): Dictionary containing discounted opportunity costs breakdown\n        veh_oper_cost_set (dict): Dictionary containing discounted operating costs breakdown\n    \"\"\"\n    operatingCosts_df = get_operating_costs(discounted_costs_df, TCO_switch)\n    totaloperatingCosts_df = operatingCosts_df.groupby([\"Year\", \"Model Year\"]).sum(\n        \"Cost [$]\"\n    )\n\n    payloadmultiplier = veh_opp_cost_set[\"payload_cap_cost_multiplier\"] or 1\n    disc_operating_costs = totaloperatingCosts_df[\"Discounted Cost [$]\"].sum()\n    disc_residual_costs = discounted_costs_df[\n        discounted_costs_df[\"Category\"].isin([\"residual cost\"])\n    ][\"Discounted Cost [$]\"].sum()\n    disc_opportunity_costs = discounted_costs_df[\n        discounted_costs_df[\"Category\"].isin(\n            [\"fueling downtime cost\", \"MR downtime cost\"]\n        )\n    ][\"Discounted Cost [$]\"].sum()\n    sum_operating_costsdf = operatingCosts_df.groupby(\"Category\", as_index=False).sum(\n        \"Discounted Cost [$]\"\n    )\n    veh_oper_cost_set = dict(\n        zip(\n            sum_operating_costsdf[\"Category\"],\n            sum_operating_costsdf[\"Discounted Cost [$]\"],\n        )\n    )\n    if TCO_switch == \"DIRECT\":\n        discounted_tco_dol = payloadmultiplier * (\n            veh_cost_set[\"msrp\"]\n            + veh_cost_set[\"Purchase tax\"]\n            + disc_operating_costs\n            + disc_residual_costs\n        )\n        payload_capacity_cost = (\n            (payloadmultiplier - 1) / payloadmultiplier * discounted_tco_dol\n        )\n        oppy_cost_dol_set = {\n            \"discounted_downtime_oppy_cost_dol\": disc_opportunity_costs,\n            \"payload_capacity_cost_dol\": payload_capacity_cost,\n        }\n\n    elif TCO_switch == \"EFFICIENCY\":\n        disc_VMT_sum = sum(\n            [\n                scenario.vmt[i] / (1 + scenario.discount_rate_pct_per_yr) ** (i)\n                for i in range(scenario.vehicle_life_yr)\n            ]\n        )\n        disc_downtime_sum = sum(\n            [\n                veh_opp_cost_set[\"total_downtime_hrPerYr\"][i]\n                / (1 + scenario.discount_rate_pct_per_yr) ** (i + 1)\n                for i in range(scenario.vehicle_life_yr)\n            ]\n        )\n        avg_speed_mph = (\n            sum(sim_drive.cyc.mps) / max(sim_drive.cyc.time_s) * gl.mps_to_mph\n        )\n        downtime_efficiency = 1 / (1 + avg_speed_mph * disc_downtime_sum / disc_VMT_sum)\n        # print(f'downtime_efficiency = {downtime_efficiency}')\n        discounted_tco_dol = payloadmultiplier * (\n            (veh_cost_set[\"msrp\"] + veh_cost_set[\"Purchase tax\"] + disc_operating_costs)\n            / downtime_efficiency\n            + disc_residual_costs\n        )\n        discounted_downtime_oppy_cost_dol = (\n            veh_cost_set[\"msrp\"]\n            + veh_cost_set[\"Purchase tax\"]\n            + disc_operating_costs\n            + disc_opportunity_costs\n        ) * (1 / downtime_efficiency - 1)\n        payload_capacity_cost = (\n            (payloadmultiplier - 1) / payloadmultiplier * discounted_tco_dol\n        )\n        oppy_cost_dol_set = {\n            \"discounted_downtime_oppy_cost_dol\": discounted_downtime_oppy_cost_dol,\n            \"payload_capacity_cost_dol\": payload_capacity_cost,\n        }\n\n    return discounted_tco_dol, oppy_cost_dol_set, veh_oper_cost_set\n</code></pre>"},{"location":"tco_analysis/#t3co.tco.tco_analysis.discounted_costs","title":"<code>discounted_costs(scenario: run_scenario.Scenario, ownershipCosts: pd.DataFrame) -&gt; pd.DataFrame</code>","text":"<p>This function calculates the yearly discounted costs for each category of ownershipCosts based on scenario.discRate</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for current selection</p> required <code>ownershipCosts</code> <code>pd.DataFrame</code> <p>Dataframe containing year-wise ownership costs estimations like Fuel, maintenance, insurance, etc</p> required <p>Returns:</p> Name Type Description <code>ownershipCosts</code> <code>pd.DataFrame</code> <p>ownershipCosts dataframe with additional 'Discounted Cost [$]' column</p> Source code in <code>t3co/tco/tco_analysis.py</code> Python<pre><code>def discounted_costs(\n    scenario: run_scenario.Scenario, ownershipCosts: pd.DataFrame\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This function calculates the yearly discounted costs for each category of ownershipCosts based on scenario.discRate\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object for current selection\n        ownershipCosts (pd.DataFrame): Dataframe containing year-wise ownership costs estimations like Fuel, maintenance, insurance, etc\n\n    Returns:\n        ownershipCosts (pd.DataFrame): ownershipCosts dataframe with additional 'Discounted Cost [$]' column\n    \"\"\"\n    ownershipCosts[\"Discounted Cost [$]\"] = ownershipCosts[\"Cost [$]\"] / (\n        1.0 + scenario.discount_rate_pct_per_yr\n    ) ** (ownershipCosts[\"Year\"] - ownershipCosts[\"Model Year\"])\n    # veh_opp_cost_set['Discounted Cost [$]'] = veh_opp_cost_set['Cost [$]'] / (1. + scenario.discount_rate_pct_per_yr) ** (veh_opp_cost_set['Year'] - veh_opp_cost_set['Model Year'])\n    # veh_residual_df['Discounted Cost [$]'] = veh_residual_df['Cost [$]'] / (1. + scenario.discount_rate_pct_per_yr) ** (veh_residual_df['Year'] - veh_residual_df['Model Year'])\n\n    return ownershipCosts\n</code></pre>"},{"location":"tco_analysis/#t3co.tco.tco_analysis.get_operating_costs","title":"<code>get_operating_costs(ownershipCosts: pd.DataFrame, TCO_switch: str = 'DIRECT') -&gt; pd.DataFrame</code>","text":"<p>This function creates a dataframe of operating cost from ownershipCosts dataframe based on TCO_switch ('DIRECT' or 'EFFICIENCY')</p> <p>Parameters:</p> Name Type Description Default <code>ownershipCosts</code> <code>pd.DataFrame</code> <p>Dataframe containing year-wise ownership costs estimations like Fuel, maintenance, insurance, etc</p> required <code>TCO_switch</code> <code>str</code> <p>Switch between different TCO calculations - 'DIRECT' or 'EFFICIENCY'. Defaults to 'DIRECT'.</p> <code>'DIRECT'</code> <p>Returns:</p> Name Type Description <code>operatingCosts_df</code> <code>pd.DataFrame</code> <p>Dataframe containing operating cost categories based on TCO_switch</p> Source code in <code>t3co/tco/tco_analysis.py</code> Python<pre><code>def get_operating_costs(\n    ownershipCosts: pd.DataFrame, TCO_switch: str = \"DIRECT\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This function creates a dataframe of operating cost from ownershipCosts dataframe based on TCO_switch ('DIRECT' or 'EFFICIENCY')\n\n    Args:\n        ownershipCosts (pd.DataFrame): Dataframe containing year-wise ownership costs estimations like Fuel, maintenance, insurance, etc\n        TCO_switch (str, optional): Switch between different TCO calculations - 'DIRECT' or 'EFFICIENCY'. Defaults to 'DIRECT'.\n\n    Returns:\n        operatingCosts_df (pd.DataFrame): Dataframe containing operating cost categories based on TCO_switch\n    \"\"\"\n    if TCO_switch == \"DIRECT\":\n        operating_costs_categories = [\n            \"Fuel\",\n            \"maintenance\",\n            \"insurance\",\n            \"fueling labor cost\",\n            \"fueling downtime cost\",\n            \"MR downtime cost\",\n        ]\n        operatingCosts_df = ownershipCosts[\n            ownershipCosts[\"Category\"].isin(operating_costs_categories)\n        ]\n\n    elif TCO_switch == \"EFFICIENCY\":\n        operating_costs_categories = [\n            \"Fuel\",\n            \"maintenance\",\n            \"insurance\",\n            \"fueling labor cost\",\n        ]\n\n        operatingCosts_df = ownershipCosts[\n            ownershipCosts[\"Category\"].isin(operating_costs_categories)\n        ]\n    return operatingCosts_df\n</code></pre>"},{"location":"tco_analysis/#t3co.tco.tco_analysis.get_tco_of_vehicle","title":"<code>get_tco_of_vehicle(vehicle: fastsim.vehicle.Vehicle, range_cyc: fastsim.cycle.Cycle, scenario: run_scenario.Scenario, write_tsv: bool = False) -&gt; Tuple[float, float, dict, pd.DataFrame, pd.DataFrame, dict, dict, fastsim.simdrive.SimDrive, dict, dict, dict]</code>","text":"<p>This function calculates the Total Cost of Ownership of a vehicle and scenario for a given cycle. The three main components are: - Opportunity Costs - MSRP - Operating Costs</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of selected vehicle</p> required <code>range_cyc</code> <code>fastsim.cycle.Cycle</code> <p>FASTSim range cycle object</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object for current selection</p> required <code>write_tsv</code> <code>bool</code> <p>if True, save intermediate files as TSV. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>tot_cost_dol</code> <code>float</code> <p>TCO in dollars</p> <code>discounted_tco_dol</code> <code>float</code> <p>discounted TCO in dollars</p> <code>oppy_cost_set</code> <code>dict</code> <p>Dictionary of opportunity cost breakdown</p> <code>ownership_costs_df</code> <code>pd.DataFrame</code> <p>Ownerhip Costs dataframe containing different categories per year</p> <code>discounted_costs_df</code> <code>pd.DataFrame</code> <p>discounted Ownerhip Costs dataframe containing different categories per year</p> <code>mpgge</code> <code>dict</code> <p>Dictionary containing MPGGEs</p> <code>veh_cost_set</code> <code>dict</code> <p>Dictionary containing MSRP breakdown</p> <code>design_cycle_sdr</code> <code>fastsim.simdrive.SimDrive</code> <p>FASTSim SimDrive object for design drivecycle</p> <code>veh_oper_cost_set</code> <code>dict</code> <p>Dictionary containing operating costs breakdown</p> <code>veh_opp_cost_set</code> <code>dict</code> <p>Dictionary containing opportunity costs breakdown</p> <code>tco_files</code> <code>dict</code> <p>Dictionary containing TCO intermediate dataframes</p> Source code in <code>t3co/tco/tco_analysis.py</code> Python<pre><code>def get_tco_of_vehicle(\n    vehicle: fastsim.vehicle.Vehicle,\n    range_cyc: fastsim.cycle.Cycle,\n    scenario: run_scenario.Scenario,\n    write_tsv: bool = False,\n) -&gt; Tuple[\n    float,\n    float,\n    dict,\n    pd.DataFrame,\n    pd.DataFrame,\n    dict,\n    dict,\n    fastsim.simdrive.SimDrive,\n    dict,\n    dict,\n    dict,\n]:\n    \"\"\"\n    This function calculates the Total Cost of Ownership of a vehicle and scenario for a given cycle. The three main components are:\n    - Opportunity Costs\n    - MSRP\n    - Operating Costs\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of selected vehicle\n        range_cyc (fastsim.cycle.Cycle): FASTSim range cycle object\n        scenario (run_scenario.Scenario): Scenario object for current selection\n        write_tsv (bool, optional): if True, save intermediate files as TSV. Defaults to False.\n\n    Returns:\n        tot_cost_dol (float): TCO in dollars\n        discounted_tco_dol (float): discounted TCO in dollars\n        oppy_cost_set (dict): Dictionary of opportunity cost breakdown\n        ownership_costs_df (pd.DataFrame): Ownerhip Costs dataframe containing different categories per year\n        discounted_costs_df (pd.DataFrame): discounted Ownerhip Costs dataframe containing different categories per year\n        mpgge (dict): Dictionary containing MPGGEs\n        veh_cost_set (dict): Dictionary containing MSRP breakdown\n        design_cycle_sdr (fastsim.simdrive.SimDrive): FASTSim SimDrive object for design drivecycle\n        veh_oper_cost_set (dict): Dictionary containing operating costs breakdown\n        veh_opp_cost_set (dict): Dictionary containing opportunity costs breakdown\n        tco_files (dict): Dictionary containing TCO intermediate dataframes\n    \"\"\"\n\n    mpgge, sim_drives = fueleconomy.get_mpgge(range_cyc, vehicle, scenario)\n    range_dict = fueleconomy.get_range_mi(mpgge, vehicle, scenario)\n    veh_opp_cost_set = tcocalc.calculate_opp_costs(vehicle, scenario, range_dict)\n    veh_cost_set = tcocalc.calculate_dollar_cost(vehicle, scenario)\n    veh_eff_df = tcocalc.fill_fuel_eff_file(vehicle, scenario, mpgge)\n    veh_exp_df = tcocalc.fill_veh_expense_file(scenario, veh_cost_set)\n    veh_spt_df = tcocalc.fill_fuel_split_tsv(vehicle, scenario, mpgge)\n    veh_txp_df = tcocalc.fill_trav_exp_tsv(vehicle, scenario)\n    veh_fxp_df = tcocalc.fill_fuel_expense_tsv(vehicle, scenario)\n    veh_shr_df = tcocalc.fill_market_share_tsv(scenario)\n    ann_trv_df = tcocalc.fill_annual_tsv(scenario)\n    reg_sls_df = tcocalc.fill_reg_sales_tsv(scenario)\n    survivl_df = tcocalc.fill_survival_tsv(scenario)\n    veh_insurance_df = tcocalc.fill_insurance_tsv(scenario, veh_cost_set)\n    veh_residual_df = tcocalc.fill_residual_cost_tsc(vehicle, scenario, veh_cost_set)\n    veh_downtime_labor_df = tcocalc.fill_downtimelabor_cost_tsv(\n        scenario, veh_opp_cost_set\n    )\n\n    # emission_df = pd.read_csv(gl.TCO_INTERMEDIATES / gl.EMISSION_RATE_TSV, index_col=None, header=0, sep='\\t')\n    emission_df = None\n\n    # run stock model\n    stock, emissions, ownership_costs_df = tco_stock_emissions.stockModel(\n        reg_sls_df,\n        veh_shr_df,\n        survivl_df,\n        ann_trv_df,\n        veh_spt_df,\n        veh_eff_df,\n        emission_df,\n        veh_exp_df,\n        veh_txp_df,\n        veh_fxp_df,\n        veh_insurance_df,\n        veh_residual_df,\n        veh_downtime_labor_df,\n        write_files=gl.write_files,\n    )\n\n    # discountRate = float(scenario.discount_rate_pct_per_yr)\n    # discounted_costs_df = DCF(ownership_costs_df.copy(), rate=discountRate)\n    # print(discounted_costs_df)\n    discounted_costs_df = discounted_costs(scenario, ownership_costs_df)\n    # should only be one vocation in these files but this as good a thing to aggregate on as any\n    tot_cost_dol = discounted_costs_df[\"Cost [$]\"].sum()\n\n    # discounted_tco_dol, discounted_downtime_oppy_cost_dol, veh_oper_cost_set = calc_discountedTCO(scenario, discounted_costs_df, veh_cost_set, veh_opp_cost_set, sim_drives[-1], TCO_switch = 'DIRECT')\n    # print(f'New disc DIRECT TCO: {discounted_tco_dol}')\n    discounted_tco_dol, oppy_cost_set, veh_oper_cost_set = calc_discountedTCO(\n        scenario,\n        discounted_costs_df,\n        veh_cost_set,\n        veh_opp_cost_set,\n        sim_drives[-1],\n        TCO_switch=\"DIRECT\",\n    )\n    # print(f'New disc EFFICIENCY TCO: {discounted_tco_dol}')\n\n    # if veh_opp_cost_set['payload_cap_cost_multiplier'] is not None:\n    #     discounted_costs_df[\"Payload Corrected Discounted Cost [$]\"] = \\\n    #       discounted_costs_df[\"Discounted Cost [$]\"] * veh_opp_cost_set['payload_cap_cost_multiplier']\n    #     disc_cost = discounted_costs_df[\"Payload Corrected Discounted Cost [$]\"].sum()\n\n    # write output files\n    tco_files = {}\n    if write_tsv:\n        tco_files = {\n            \"veh_eff_df\": veh_eff_df,\n            \"veh_exp_df\": veh_exp_df,\n            \"veh_txp_df\": veh_txp_df,\n            \"veh_shr_df\": veh_shr_df,\n            \"veh_fxp_df\": veh_fxp_df,\n            \"ann_trv_df\": ann_trv_df,\n            \"reg_sls_df\": reg_sls_df,\n            \"survivl_df\": survivl_df,\n            \"veh_spt_df\": veh_spt_df,\n            \"stock\": stock,\n            \"ownership_costs_df\": ownership_costs_df,\n            \"discounted_costs_df\": discounted_costs_df,\n        }\n\n    return (\n        tot_cost_dol,\n        discounted_tco_dol,\n        oppy_cost_set,\n        ownership_costs_df,\n        discounted_costs_df,\n        mpgge,\n        veh_cost_set,\n        sim_drives,\n        veh_oper_cost_set,\n        veh_opp_cost_set,\n        tco_files,\n    )\n</code></pre>"},{"location":"tco_stock_emissions/","title":"TCO Stock and Emissions Sub-Module","text":""},{"location":"tco_stock_emissions/#t3co.tco.tco_stock_emissions","title":"<code>t3co.tco.tco_stock_emissions</code>","text":""},{"location":"tco_stock_emissions/#t3co.tco.tco_stock_emissions.dropCols","title":"<code>dropCols(df: pd.DataFrame) -&gt; pd.DataFrame</code>","text":"<p>This helper method drops columns if any row contains ['*']</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>pd.DataFrame</code> <p>Input dataframe</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Output dataframe with dropped dummy columns</p> Source code in <code>t3co/tco/tco_stock_emissions.py</code> Python<pre><code>def dropCols(df: pd.DataFrame) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method drops columns if any row contains ['*']\n\n    Args:\n        df (pd.DataFrame): Input dataframe\n\n    Returns:\n        df (pd.DataFrame): Output dataframe with dropped dummy columns\n    \"\"\"\n    if df is not None:\n        droplist = [i for i in df.columns if df[i].isin([\"*\"]).any()]\n        df = df.drop(droplist, axis=1)\n    return df\n</code></pre>"},{"location":"tco_stock_emissions/#t3co.tco.tco_stock_emissions.stockModel","title":"<code>stockModel(sales: pd.DataFrame, marketShares: pd.DataFrame, survival: pd.DataFrame, annualTravel: pd.DataFrame, fuelSplit: pd.DataFrame, fuelEfficiency: pd.DataFrame, emissions: pd.DataFrame, vehicleCosts: pd.DataFrame = None, travelCosts: pd.DataFrame = None, fuelCosts: pd.DataFrame = None, insuranceCosts: pd.DataFrame = None, residualCosts: pd.DataFrame = None, downtimeCosts: pd.DataFrame = None, write_files: bool = False) -&gt; Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]</code>","text":"<p>This function generates the ownershipCosts dataframe from the dataframes for each cost category</p> <p>Parameters:</p> Name Type Description Default <code>sales</code> <code>pd.DataFrame</code> <p>Dataframe of yearly number of vehicles sales</p> required <code>marketShares</code> <code>pd.DataFrame</code> <p>Dataframe of yearly Market Share of selection's vocation per vehicle [veh/veh]</p> required <code>survival</code> <code>pd.DataFrame</code> <p>Dataframe of yearly Surviving vehicle per each vehicle [veh/veh]</p> required <code>annualTravel</code> <code>pd.DataFrame</code> <p>Dataframe of vehicle's vmt: Annual Travel [mi/yr]</p> required <code>fuelSplit</code> <code>pd.DataFrame</code> <p>Dataframe of fraction of travel using each fuel [mi/mi]</p> required <code>fuelEfficiency</code> <code>pd.DataFrame</code> <p>Dataframe of vehicle's yearly average fuel efficiency [mi/gge]</p> required <code>emissions</code> <code>pd.DataFrame</code> <p>Dataframe of vehicle's yearly average emissions</p> required <code>vehicleCosts</code> <code>pd.DataFrame</code> <p>Dataframe of vehicle components costs [dol]. Defaults to None.</p> <code>None</code> <code>travelCosts</code> <code>pd.DataFrame</code> <p>Dataframe of maintenance costs [dol/mi]. Defaults to None.</p> <code>None</code> <code>fuelCosts</code> <code>pd.DataFrame</code> <p>Dataframe of fuel operating costs [dol/gge]. Defaults to None.</p> <code>None</code> <code>insuranceCosts</code> <code>pd.DataFrame</code> <p>Dataframe of yearly insurance costs [dol]. Defaults to None.</p> <code>None</code> <code>residualCosts</code> <code>pd.DataFrame</code> <p>Dataframe of yearly residual costs [dol]. Defaults to None.</p> <code>None</code> <code>downtimeCosts</code> <code>pd.DataFrame</code> <p>Dataframe of yearly downtime costs [dol]. Defaults to None.</p> <code>None</code> <code>write_files</code> <code>bool</code> <p>if True, save vehicleCosts, travelCosts, fuelCosts, insuranceCosts,residualCosts, downtimeCosts . Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>stock</code> <code>pd.DataFrame</code> <p>Dataframe of stock model of vehicles in the market</p> <code>emissions</code> <code>pd.DataFrame</code> <p>Dataframe of total emissions</p> <code>ownershipCosts</code> <code>pd.DataFrame</code> <p>Dataframe of all ownership costs for given selection</p> Source code in <code>t3co/tco/tco_stock_emissions.py</code> Python<pre><code>def stockModel(\n    sales: pd.DataFrame,\n    marketShares: pd.DataFrame,\n    survival: pd.DataFrame,\n    annualTravel: pd.DataFrame,\n    fuelSplit: pd.DataFrame,\n    fuelEfficiency: pd.DataFrame,\n    emissions: pd.DataFrame,\n    vehicleCosts: pd.DataFrame = None,\n    travelCosts: pd.DataFrame = None,\n    fuelCosts: pd.DataFrame = None,\n    insuranceCosts: pd.DataFrame = None,\n    residualCosts: pd.DataFrame = None,\n    downtimeCosts: pd.DataFrame = None,\n    write_files: bool = False,\n) -&gt; Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]:\n    \"\"\"\n    This function generates the ownershipCosts dataframe from the dataframes for each cost category\n\n    Args:\n        sales (pd.DataFrame): Dataframe of yearly number of vehicles sales\n        marketShares (pd.DataFrame): Dataframe of yearly Market Share of selection's vocation per vehicle [veh/veh]\n        survival (pd.DataFrame): Dataframe of yearly Surviving vehicle per each vehicle [veh/veh]\n        annualTravel (pd.DataFrame): Dataframe of vehicle's vmt: Annual Travel [mi/yr]\n        fuelSplit (pd.DataFrame): Dataframe of fraction of travel using each fuel [mi/mi]\n        fuelEfficiency (pd.DataFrame): Dataframe of vehicle's yearly average fuel efficiency [mi/gge]\n        emissions (pd.DataFrame): Dataframe of vehicle's yearly average emissions\n        vehicleCosts (pd.DataFrame, optional): Dataframe of vehicle components costs [dol]. Defaults to None.\n        travelCosts (pd.DataFrame, optional): Dataframe of maintenance costs [dol/mi]. Defaults to None.\n        fuelCosts (pd.DataFrame, optional): Dataframe of fuel operating costs [dol/gge]. Defaults to None.\n        insuranceCosts (pd.DataFrame, optional): Dataframe of yearly insurance costs [dol]. Defaults to None.\n        residualCosts (pd.DataFrame, optional): Dataframe of yearly residual costs [dol]. Defaults to None.\n        downtimeCosts (pd.DataFrame, optional): Dataframe of yearly downtime costs [dol]. Defaults to None.\n        write_files (bool, optional): if True, save vehicleCosts, travelCosts, fuelCosts, insuranceCosts,residualCosts, downtimeCosts . Defaults to False.\n\n    Returns:\n        stock (pd.DataFrame): Dataframe of stock model of vehicles in the market\n        emissions (pd.DataFrame): Dataframe of total emissions\n        ownershipCosts (pd.DataFrame): Dataframe of all ownership costs for given selection\n\n    \"\"\"\n    # drop columns with *\n    sales = dropCols(sales)\n    marketShares = dropCols(marketShares)\n    survival = dropCols(survival)\n    annualTravel = dropCols(annualTravel)\n    fuelSplit = dropCols(fuelSplit)\n    fuelEfficiency = dropCols(fuelEfficiency)\n    emissions = dropCols(emissions)\n    vehicleCosts = dropCols(vehicleCosts)\n    travelCosts = dropCols(travelCosts)\n    fuelCosts = dropCols(fuelCosts)\n    insuranceCosts = dropCols(insuranceCosts)\n    residualCosts = dropCols(residualCosts)\n    downtimeCosts = dropCols(downtimeCosts)\n\n    # compute stock\n    years = marketShares[\"Model Year\"].unique()\n    regionalSales = pd.merge(\n        sales, marketShares\n    )  # on='Model Year'  # seems to default to cross method\n    regionalSales[\"Sales [veh]\"] = (\n        regionalSales[\"Sales [veh]\"] * regionalSales[\"Market Share [veh/veh]\"]\n    )\n    regionalSales = regionalSales.drop([\"Market Share [veh/veh]\"], axis=1)\n\n    stock = []\n    for y in years:\n        df = regionalSales[regionalSales[\"Model Year\"] &lt;= y].copy()\n        df[\"Year\"] = y\n        stock.append(df)\n\n    stock = pd.concat(stock)\n    stock[\"Age [yr]\"] = stock[\"Year\"] - stock[\"Model Year\"]\n    stock = pd.merge(survival, stock)\n    stock[\"Stock [veh]\"] = stock[\"Sales [veh]\"] * stock[\"Surviving Vehicles [veh/veh]\"]\n    stock = stock.drop([\"Surviving Vehicles [veh/veh]\"], axis=1)\n\n    # compute vmt\n    stock = pd.merge(stock, annualTravel)\n    stock[\"Travel [mi]\"] = stock[\"Annual Travel [mi/yr]\"] * stock[\"Stock [veh]\"]\n    # stock['Maintenance Cost [dol/mi]'] = stock['Maintenance Cost [dol/mi]'] * stock['Stock [veh]']\n    stock = stock.drop([\"Annual Travel [mi/yr]\", \"Age [yr]\"], axis=1)\n\n    # compute energy\n    energy = pd.merge(pd.merge(stock, fuelEfficiency), fuelSplit)\n    energy[\"Travel [mi]\"] = (\n        energy[\"Travel [mi]\"] * energy[\"Fraction of Travel [mi/mi]\"]\n    )  # travel [mi] by fuel type\n    energy[\"Energy [gge]\"] = energy[\"Travel [mi]\"] / energy[\"Fuel Efficiency [mi/gge]\"]\n\n    df = energy.copy()  # store for ownership costs calculations\n    df[\"Age [yr]\"] = df[\"Year\"] - df[\"Model Year\"]\n\n    energy = energy.groupby(\n        [\"Region\", \"Vehicle\", \"Vocation\", \"Model Year\", \"Year\"], as_index=False\n    ).agg({\"Energy [gge]\": \"sum\"})\n    stock = pd.merge(stock, energy).sort_values(\n        by=[\"Year\", \"Model Year\", \"Region\", \"Vocation\", \"Vehicle\"]\n    )\n    stock = stock[\n        [\n            \"Year\",\n            \"Region\",\n            \"Vocation\",\n            \"Vehicle\",\n            \"Model Year\",\n            \"Sales [veh]\",\n            \"Stock [veh]\",\n            \"Travel [mi]\",\n            \"Energy [gge]\",\n        ]\n    ]\n\n    # # compute emissions if it specified\n    # if emissions is not None: # quickly wrote this on 6/19/19 at 10pm at night. Probably a better way to make this more robust and optional inputs for other cost files as well\n    #     emissions = pd.merge(df, emissions)\n    #     emissions['Emission [g]'] = emissions['Emission Rate [g/gge]'] * emissions['Energy [gge]']\n    #     emissions = emissions.drop(['Emission Rate [g/gge]'], axis=1)\n    #     emissions = emissions.groupby(['Year','Region','Vocation','Vehicle','Fuel','Pollutant'], as_index=False).agg({'Stock [veh]' : np.sum, 'Travel [mi]' : np.sum, 'Energy [gge]' : np.sum, 'Emission [g]' : np.sum})\n\n    # compute ownership costs\n    vehicleCosts = pd.merge(vehicleCosts, df[df[\"Age [yr]\"] &lt; 0.1])\n    vehicleCosts[\"Cost [$]\"] = (\n        vehicleCosts[\"Stock [veh]\"] * vehicleCosts[\"Cost [$/veh]\"]\n    )\n    vehicleCosts = vehicleCosts.drop([\"Cost [$/veh]\"], axis=1)\n\n    travelCosts = pd.merge(travelCosts, df)\n\n    travelCosts[\"Cost [$]\"] = travelCosts[\"Travel [mi]\"] * travelCosts[\"Cost [$/mi]\"]\n    travelCosts = travelCosts.drop([\"Cost [$/mi]\"], axis=1)\n\n    fuelCosts = pd.merge(fuelCosts, df)\n    fuelCosts[\"Cost [$]\"] = fuelCosts[\"Energy [gge]\"] * fuelCosts[\"Cost [$/gge]\"]\n    fuelCosts = fuelCosts.drop([\"Cost [$/gge]\"], axis=1)\n\n    insuranceCosts = pd.merge(insuranceCosts, df)\n    insuranceCosts[\"Cost [$]\"] = insuranceCosts[\"Cost [$/Yr]\"]\n    insuranceCosts = insuranceCosts.drop([\"Cost [$/Yr]\"], axis=1)\n\n    residualCosts = pd.merge(residualCosts, df)\n    residualCosts[\"Cost [$]\"] = residualCosts[\"Cost [$/Yr]\"]\n    residualCosts = residualCosts.drop([\"Cost [$/Yr]\"], axis=1)\n\n    downtimeCosts = pd.merge(downtimeCosts, df)\n    downtimeCosts[\"Cost [$]\"] = downtimeCosts[\"Cost [$/Yr]\"]\n    downtimeCosts = downtimeCosts.drop([\"Cost [$/Yr]\"], axis=1)\n\n    if write_files:\n        vehicleCosts.to_csv(gl.TCO_INTERMEDIATES / \"vehicle_costs.csv\", index=False)\n        travelCosts.to_csv(gl.TCO_INTERMEDIATES / \"travel_costs.csv\", index=False)\n        fuelCosts.to_csv(gl.TCO_INTERMEDIATES / \"fuel_costs.csv\", index=False)\n        insuranceCosts.to_csv(gl.TCO_INTERMEDIATES / \"insurance_costs.csv\", index=False)\n        residualCosts.to_csv(gl.TCO_INTERMEDIATES / \"residual_costs.csv\", index=False)\n        downtimeCosts.to_csv(gl.TCO_INTERMEDIATES / \"downtime_costs.csv\", index=False)\n\n    ownershipCosts = pd.concat(\n        [\n            vehicleCosts,\n            travelCosts,\n            fuelCosts,\n            insuranceCosts,\n            residualCosts,\n            downtimeCosts,\n        ]\n    )\n    ownershipCosts = ownershipCosts.groupby(\n        [\"Region\", \"Vehicle\", \"Vocation\", \"Model Year\", \"Year\", \"Category\"],\n        as_index=False,\n    ).agg({\"Cost [$]\": \"sum\"})\n    ownershipCosts = ownershipCosts.sort_values(\n        by=[\"Year\", \"Model Year\", \"Region\", \"Vocation\", \"Vehicle\"]\n    )[[\"Year\", \"Region\", \"Vocation\", \"Vehicle\", \"Model Year\", \"Category\", \"Cost [$]\"]]\n    return stock, emissions, ownershipCosts\n</code></pre>"},{"location":"tcocalc/","title":"TCO Calculations Sub-Module","text":""},{"location":"tcocalc/#t3co.tco.tcocalc","title":"<code>t3co.tco.tcocalc</code>","text":""},{"location":"tcocalc/#t3co.tco.tcocalc.calculate_dollar_cost","title":"<code>calculate_dollar_cost(veh: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario) -&gt; dict</code>","text":"<p>This helper method calculates the MSRP breakdown dictionary from -   Glider -   Fuel converter -   Fuel Storage -   Motor &amp; power electronics -   Plug -   Battery -   Battery replacement -   Purchase tax</p> <p>Parameters:</p> Name Type Description Default <code>veh</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <p>Returns:</p> Name Type Description <code>cost_set</code> <code>dict</code> <p>Dictionary containing MSRP breakdown</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def calculate_dollar_cost(\n    veh: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n) -&gt; dict:\n    \"\"\"\n    This helper method calculates the MSRP breakdown dictionary from\n    -   Glider\n    -   Fuel converter\n    -   Fuel Storage\n    -   Motor &amp; power electronics\n    -   Plug\n    -   Battery\n    -   Battery replacement\n    -   Purchase tax\n\n    Args:\n        veh (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n\n    Returns:\n        cost_set (dict): Dictionary containing MSRP breakdown\n    \"\"\"\n    chargingOn = False\n\n    fc_ice_base_cost_dol = scenario.fc_ice_base_cost_dol\n    markup_pct = scenario.markup_pct\n    fc_ice_cost_dol_per_kw = scenario.fc_ice_cost_dol_per_kw\n    pe_mc_base_cost_dol = scenario.pe_mc_base_cost_dol\n    pe_mc_cost_dol_per_kw = scenario.pe_mc_cost_dol_per_kw\n    ess_base_cost_dol = scenario.ess_base_cost_dol\n    ess_cost_dol_per_kwh = scenario.ess_cost_dol_per_kwh\n    plugPrice = scenario.plug_base_cost_dol\n    tax_rate_pct = scenario.tax_rate_pct\n    # TODO add fc_fuelcell_cost_dol_per_kw in this list?\n\n    # vehicle glider price does not have markup_pct applied to it\n    # on 11/23/2021 it was discussed but we decided it's fine to keep it this way. Glider price is an input that could\n    # already have this factored in, especially for TDA, the current main user of T3CO\n    vehicle_glider_cost_dol = scenario.vehicle_glider_cost_dol\n\n    veh_pt_type = veh.veh_pt_type\n\n    fc_max_kw = veh.fc_max_kw\n\n    # old python fcEffType maps\n    # if self.fcEffType == 1:    # SI:         SI engine\n    # elif self.fcEffType == 2:  # Atkinson:   Atkinson cycle SI engine -- greater expansion\n    # elif self.fcEffType == 3:  # Diesel:     Diesel (compression ignition) engine\n    # elif self.fcEffType == 4:  # H2FC:       H2 fuel cell\n    # elif self.fcEffType == 5:  # HD_Diesel:  heavy duty Diesel engine\n    # new enumeration for types\n    # FC_EFF_TYPES = (\"SI\", \"Atkinson\", \"Diesel\", \"H2FC\", \"HD_Diesel\")\n\n    # #  TODO, need an assert for veh.fcEffType in vehicle.effTypes []\n    # fcPrice\n    if veh.veh_pt_type == gl.BEV or veh.fc_max_kw == 0:\n        fcPrice = 0\n\n    elif veh.fc_eff_type == \"H2FC\":\n        fcPrice = scenario.fc_fuelcell_cost_dol_per_kw * fc_max_kw\n    # TODO, what should 9 map too??\n    elif veh.fc_eff_type == 9:\n        fcPrice = (\n            scenario.fc_cng_ice_cost_dol_per_kw * fc_max_kw\n        ) + fc_ice_base_cost_dol\n\n    else:\n        fcPrice = (fc_ice_cost_dol_per_kw * fc_max_kw) + fc_ice_base_cost_dol\n    fcPrice *= markup_pct\n\n    # TODO,this should get handled in fastsim.vehicle on INPUT VALIDATION\n    # that code has a bug and some logic errors, needs fixing\n    # if fcPrice != 0:\n    #     eff_type_err_msg = f\"ERROR: veh.fc_eff_type {veh.fc_eff_type} must be part of vehicle.FC_EFF_TYPES {vehicle.FC_EFF_TYPES}\"\n    #     eff_type_err_msg += \"\"\"\\n\\toverwrite 1 with 'SI'\\n\\toverwrite 2 with 'Atkinson'\"\"\"\n    #     eff_type_err_msg += \"\"\"\\n\\toverwrite 3 with 'Diesel'\\n\\toverwrite 4 with 'H2FC'\"\"\"\n    #     eff_type_err_msg += \"\"\"\\n\\toverwrite 5 with 'HD_Diesel'\"\"\"\n    #     assert veh.fc_eff_type in vehicle.FC_EFF_TYPES, eff_type_err_msg\n\n    # fuelStorPrice\n    if veh.veh_pt_type == gl.BEV:\n        fuelStorPrice = 0\n    elif veh.veh_pt_type == gl.HEV and scenario.fuel_type[0] == \"hydrogen\":\n        fuelStorPrice = scenario.fs_h2_cost_dol_per_kwh * veh.fs_kwh\n    elif (\n        veh.veh_pt_type in [gl.CONV, gl.HEV, gl.PHEV] and scenario.fuel_type[0] == \"cng\"\n    ):\n        fuelStorPrice = scenario.fs_cng_cost_dol_per_kwh * veh.fs_kwh\n    elif veh.veh_pt_type in [gl.CONV, gl.HEV, gl.PHEV]:\n        fuelStorPrice = scenario.fs_cost_dol_per_kwh * veh.fs_kwh\n    fuelStorPrice *= markup_pct\n\n    # calculate mcPrice\n    mc_max_kw = veh.mc_max_kw\n    if mc_max_kw == 0:\n        mcPrice = 0\n    else:\n        mcPrice = pe_mc_base_cost_dol + (pe_mc_cost_dol_per_kw * mc_max_kw)\n    mc_max_kw *= markup_pct\n\n    # calc ESS price\n    if veh.ess_max_kwh == 0:\n        essPrice = 0\n    else:\n        essPrice = ess_base_cost_dol + (ess_cost_dol_per_kwh * veh.ess_max_kwh)\n    essPrice *= markup_pct\n\n    # calc plugPrice\n    if (\n        veh_pt_type == gl.PHEV\n        or veh_pt_type == gl.BEV\n        or (veh_pt_type == gl.HEV and chargingOn)\n    ):\n        plugPrice = plugPrice\n    else:\n        plugPrice = 0\n    plugPrice *= markup_pct\n\n    if veh_pt_type == gl.CONV:\n        msrp = vehicle_glider_cost_dol + fuelStorPrice + fcPrice\n    # could be HEV or FCEV\n    elif veh_pt_type == gl.HEV:\n        msrp = vehicle_glider_cost_dol + fuelStorPrice + fcPrice + mcPrice + essPrice\n    elif veh_pt_type == gl.PHEV:\n        msrp = (\n            vehicle_glider_cost_dol\n            + fuelStorPrice\n            + fcPrice\n            + mcPrice\n            + essPrice\n            + plugPrice\n        )\n    elif veh_pt_type == gl.BEV:\n        msrp = vehicle_glider_cost_dol + mcPrice + essPrice + plugPrice\n\n    pTaxCost = tax_rate_pct * msrp\n\n\n    cost_set = {\n        \"Glider\": vehicle_glider_cost_dol,\n        \"Fuel converter\": fcPrice,\n        \"Fuel Storage\": fuelStorPrice,\n        \"Motor &amp; power electronics\": mcPrice,\n        \"Plug\": plugPrice,\n        \"Battery\": essPrice,\n        \"Battery replacement\": 0,\n        \"Purchase tax\": pTaxCost,\n        \"msrp\": msrp,\n        # \"Insurance\": insurance_cost,\n        # \"Residual Cost\": residual_cost\n    }\n    return cost_set\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.calculate_opp_costs","title":"<code>calculate_opp_costs(vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario, range_dict: dict) -&gt; dict</code>","text":"<p>This helper method calculates opportunity costs and generates veh_opp_cost_set from -   Payload Lost Capacity Cost/Multiplier -   Fueling Downtime -   Maintenance and Repair Downtime</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>range_dict</code> <code>dict</code> <p>Dictionary containing range values from fueleconomy.get_range_mi()</p> required <p>Returns:</p> Name Type Description <code>veh_opp_cost_set</code> <code>dict</code> <p>Dictionary containing opportunity cost results</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def calculate_opp_costs(\n    vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario, range_dict: dict\n) -&gt; dict:\n    \"\"\"\n    This helper method calculates opportunity costs and generates veh_opp_cost_set from\n    -   Payload Lost Capacity Cost/Multiplier\n    -   Fueling Downtime\n    -   Maintenance and Repair Downtime\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        range_dict (dict): Dictionary containing range values from fueleconomy.get_range_mi()\n\n    Returns:\n        veh_opp_cost_set (dict): Dictionary containing opportunity cost results\n    \"\"\"\n    oppcostobj = opportunity_cost.OpportunityCost(scenario, range_dict)\n    if scenario.activate_tco_payload_cap_cost_multiplier:\n        assert gl.not_falsy(scenario.plf_ref_veh_empty_mass_kg)\n        assert np.isnan(scenario.plf_ref_veh_empty_mass_kg) == False\n        oppcostobj.set_payload_loss_factor(vehicle, scenario)\n\n    if scenario.activate_tco_fueling_dwell_time_cost:\n        assert gl.not_falsy(scenario.downtime_oppy_cost_dol_per_hr)\n        assert not np.isnan(scenario.fdt_num_free_dwell_trips)\n        assert not np.isnan(scenario.fdt_dwpt_fraction_power_pct)\n        assert not np.isnan(scenario.fdt_available_freetime_hr)\n        assert not np.isnan(scenario.fdt_avg_overhead_hr_per_dwell_hr)\n        assert (\n            gl.not_falsy(scenario.shifts_per_year)\n            and len(oppcostobj.shifts_per_year) &gt;= scenario.vehicle_life_yr\n        ), f\"Provide scenario.shifts_per_year as a vector of length &gt; scenario.vehicle_life_yr. Currently {len(oppcostobj.shifts_per_year)}\"\n        assert gl.not_falsy(scenario.fdt_frac_full_charge_bounds)\n        oppcostobj.set_fueling_dwell_time_cost(vehicle, scenario)\n\n    if scenario.activate_mr_downtime_cost:\n        assert gl.not_falsy(scenario.mr_planned_downtime_hr_per_yr)\n        assert any(np.isnan(scenario.mr_unplanned_downtime_hr_per_mi)) == False\n        assert np.isnan(scenario.mr_tire_replace_downtime_hr_per_event) == False\n        assert gl.not_falsy(scenario.mr_avg_tire_life_mi)\n        oppcostobj.set_M_R_downtime_cost(vehicle, scenario)\n\n    veh_opp_cost_set = {\n        \"payload_cap_cost_multiplier\": oppcostobj.payload_cap_cost_multiplier,\n        \"daily_trip_distance_mi\": oppcostobj.d_trip_mi,\n        \"net_fueling_dwell_time_hr_per_yr\": oppcostobj.net_fueling_dwell_time_hr_per_yr,\n        \"fueling_dwell_labor_cost_dol_per_yr\": oppcostobj.fueling_dwell_labor_cost_dol_per_yr,\n        \"fueling_downtime_oppy_cost_dol_per_yr\": oppcostobj.fueling_downtime_oppy_cost_dol_per_yr,\n        \"net_mr_downtime_hr_per_yr\": oppcostobj.net_net_mr_downtime_hr_per_yr_per_yr,\n        \"mr_downtime_oppy_cost_dol_per_yr\": oppcostobj.mr_downtime_oppy_cost_dol_per_yr,\n        \"total_downtime_hr_per_yr\": np.array(\n            oppcostobj.net_fueling_dwell_time_hr_per_yr\n        )\n        + np.array(oppcostobj.net_net_mr_downtime_hr_per_yr_per_yr),\n    }\n    return veh_opp_cost_set\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_annual_tsv","title":"<code>fill_annual_tsv(scenario: run_scenario.Scenario) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe of annual vehicle miles traveled (vmt) - Annual Travel [mi/yr]</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing Annual Travel [mi/yr]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_annual_tsv(scenario: run_scenario.Scenario) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe of annual vehicle miles traveled (vmt) - Annual Travel [mi/yr]\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object of current selection\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing Annual Travel [mi/yr]\n    \"\"\"\n    columns = [\"Age [yr]\", \"Annual Travel [mi/yr]\"]\n    data = []\n\n    veh_life_years = int(scenario.vehicle_life_yr)\n\n    vmt = scenario.vmt\n    assert len(vmt) == veh_life_years, (\n        f\"vehicle_life_yr of {veh_life_years} &amp; length of input vmt {len(vmt)} do not align; \"\n        f\"vehicle_life_yr life years &amp; number of years in vmt should match\\n\"\n        f\"[vehicle_life_yr/[VMT_1,...,VMT_N]]:[{veh_life_years}/{vmt}]\"\n    )\n\n    for i in range(0, veh_life_years):\n        miles = vmt[i]\n        # i is age, give it a vmt value for each entry in vmt or defer to last vmt entry\n        data.append([i, miles])\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_downtimelabor_cost_tsv","title":"<code>fill_downtimelabor_cost_tsv(scenario: run_scenario.Scenario, oppy_cost_set: dict) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe containing fueling downtime and M&amp;R downtime costs in Cost [$/Yr]</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>oppy_cost_set</code> <code>dict</code> <p>Dictionary containing fueling_downtime_oppy_cost_dol_per_yr,fueling_dwell_labor_cost_dol_per_yr and mr_downtime_oppy_cost_dol_per_yr</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing fueling and MR downtime costs in Cost [$/Yr]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_downtimelabor_cost_tsv(\n    scenario: run_scenario.Scenario, oppy_cost_set: dict\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe containing fueling downtime and M&amp;R downtime costs in Cost [$/Yr]\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        oppy_cost_set (dict): Dictionary containing fueling_downtime_oppy_cost_dol_per_yr,fueling_dwell_labor_cost_dol_per_yr and mr_downtime_oppy_cost_dol_per_yr\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing fueling and MR downtime costs in Cost [$/Yr]\n    \"\"\"\n    columns = [\"Age [yr]\", \"Category\", \"Cost [$/Yr]\"]\n    data = []\n\n    veh_life_years = int(scenario.vehicle_life_yr)\n\n    fueling_downtime_oppy_cost_dol_per_yr = oppy_cost_set[\n        \"fueling_downtime_oppy_cost_dol_per_yr\"\n    ]\n    fueling_dwell_labor_cost_dol_per_yr = oppy_cost_set[\n        \"fueling_dwell_labor_cost_dol_per_yr\"\n    ]\n    mr_downtime_oppy_cost_dol_per_yr = oppy_cost_set[\"mr_downtime_oppy_cost_dol_per_yr\"]\n\n    for i in range(0, veh_life_years):\n        # downtime_costs_Dol = fueling_downtime_oppy_cost_dol[i] + MR_downtime_cost_Dol[i]\n        # i is age, give it a VMT value for each entry in VMT or defer to last VMT entry\n        data.append(\n            [i, \"fueling downtime cost\", fueling_downtime_oppy_cost_dol_per_yr[i]]\n        )\n        data.append([i, \"fueling labor cost\", fueling_dwell_labor_cost_dol_per_yr[i]])\n        data.append([i, \"MR downtime cost\", mr_downtime_oppy_cost_dol_per_yr[i]])\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_fuel_eff_file","title":"<code>fill_fuel_eff_file(vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario, mpgge_dict: dict) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe of Fuel Efficiency [mi/gge] For PHEV, cd_grid_electric_mpgge, cd_fuel_mpgge, and cs_fuel_mpgge For BEV, grid_mpgge For HEV and CONV, mpgge</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>mpgge_dict</code> <code>dict</code> <p>MPGGE dictionary from fueleconomy.get_mpgge()</p> required <p>Returns:</p> Name Type Description <code>fefdata</code> <code>pd.DataFrame</code> <p>Dictionary containing Fuel Efficiency [mi/gge]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_fuel_eff_file(\n    vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario, mpgge_dict: dict\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe of Fuel Efficiency [mi/gge]\n    For PHEV, cd_grid_electric_mpgge, cd_fuel_mpgge, and cs_fuel_mpgge\n    For BEV, grid_mpgge\n    For HEV and CONV, mpgge\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        mpgge_dict (dict): MPGGE dictionary from fueleconomy.get_mpgge()\n\n    Returns:\n        fefdata (pd.DataFrame): Dictionary containing Fuel Efficiency [mi/gge]\n    \"\"\"\n    # this fuel efficiency value is for over all fuel costs\n    # so it needs to factor in charging efficiency, if applicable\n\n    if vehicle.veh_pt_type == gl.PHEV:\n        # grid efficiency charge depleting mpgge first, then charge sustaining\n        mpgges = [\n            mpgge_dict[\"cd_grid_electric_mpgge\"],\n            mpgge_dict[\"cd_fuel_mpgge\"],\n            mpgge_dict[\"cs_fuel_mpgge\"],\n        ]\n    if vehicle.veh_pt_type == gl.BEV:\n        mpgges = [mpgge_dict[\"grid_mpgge\"]]\n    if vehicle.veh_pt_type in [gl.HEV, gl.CONV]:\n        mpgges = [mpgge_dict[\"mpgge\"]]\n    vehicle_segment_name = scenario.segment_name\n    model_year = int(scenario.model_year)\n    region = scenario.region\n    vocation = scenario.vocation\n\n    # get age of vehicle\n    # if age &lt; 0: age = \"*\"\n    # can ignore age, so always make it \"*\" - Kevin Bennion, 8/12/2019\n    age = \"*\"\n\n    fuels = scenario.fuel_type\n\n    assert len(fuels) == len(mpgges), f\"fuels/mpgges: {fuels}/{mpgges}\"\n    if (\n        vehicle.veh_pt_type == gl.PHEV\n    ):  # FIXME: this assumes the PHEV is plug-in hybrid electric with diesel. In future, scenario.fuel_type should be parsed to see if it is a electric/gasoline PHEV, for example.\n        assert (\n            \"cd_electricity\" in fuels[0]\n        ), r'fuels for electric/diesel PHEVs must be of format: [\"cd_electricity\", \"cd_diesel\", \"cs_diesel\"]'\n        assert (\n            \"cd_diesel\" in fuels[1]\n        ), r'fuels for electric/diesel PHEVs must be of format: [\"cd_electricity\", \"cd_diesel\", \"cs_diesel\"]'\n        assert (\n            \"cs_diesel\" in fuels[2]\n        ), r'fuels for electric/diesel PHEVs must be of format: [\"cd_electricity\", \"cd_diesel\", \"cs_diesel\"]'\n\n    data = []\n    for fuel_type, mpgge in zip(fuels, mpgges):\n        data.append(\n            [model_year, region, vehicle_segment_name, vocation, fuel_type, mpgge, age]\n        )\n    fefdata = pd.DataFrame(\n        data,\n        columns=[\n            \"Model Year\",\n            \"Region\",\n            \"Vehicle\",\n            \"Vocation\",\n            \"Fuel\",\n            \"Fuel Efficiency [mi/gge]\",\n            \"Age [yr]\",\n        ],\n    )\n\n    return fefdata\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_fuel_expense_tsv","title":"<code>fill_fuel_expense_tsv(vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe of fuel operating costs in Cost [$/gge]</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <p>Raises:</p> Type Description <code>Exception</code> <p>Invalid fuel_type type</p> <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing fuel operating costs in Cost [$/gge]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_fuel_expense_tsv(\n    vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe of fuel operating costs in Cost [$/gge]\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n\n    Raises:\n        Exception: Invalid fuel_type type\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing fuel operating costs in Cost [$/gge]\n    \"\"\"\n\n    fuels = scenario.fuel_type\n\n    if vehicle.veh_pt_type in [gl.CONV, gl.HEV]:\n        assert scenario.fuel_type[0].lower() in [\n            \"cng\",\n            \"gasoline\",\n            \"diesel\",\n            \"hydrogen\",\n        ]\n    elif vehicle.veh_pt_type in [gl.BEV]:\n        assert scenario.fuel_type[0].lower() in [\"electricity\"]\n    elif vehicle.veh_pt_type == gl.PHEV:\n        assert (\n            \"cd_electricity\" in fuels[0]\n        ), r'fuels must be of format: [\"cd_electricity\", \"cd_diesel\", \"cs_diesel\"]'\n        assert (\n            \"cd_diesel\" in fuels[1]\n        ), r'fuels must be of format: [\"cd_electricity\", \"cd_diesel\", \"cs_diesel\"]'\n        assert (\n            \"cs_diesel\" in fuels[2]\n        ), r'fuels must be of format: [\"cd_electricity\", \"cd_diesel\", \"cs_diesel\"]'\n\n    veh_life_span = int(scenario.vehicle_life_yr)\n    cat = \"Fuel\"\n    columns = [\"Year\", \"Fuel\", \"Category\", \"Cost [$/gge]\"]\n    data = []\n    regdf = pd.read_csv(gl.REGIONAL_FUEL_PRICES_BY_TYPE_BY_YEAR)\n    regdf = regdf.set_index(\"Fuel\")\n    for fuel_type in fuels:\n        # cat = fuel_type\n        for yr in range(\n            int(scenario.model_year), int(scenario.model_year + veh_life_span)\n        ):\n            regdf = regdf[regdf[\"Region\"] == scenario.region]\n            # all costs are converted to $ per gallon gasoline equivalent\n            # TODO, may want to be more explicit than just finding substrings\n            if \"diesel\" in fuel_type.lower() and \"bio\" not in fuel_type.lower():\n                dieselDolPerGal = regdf.loc[\"dieselDolPerGal\", str(yr)]\n                Dslgge = 1 * (33.7 / 37.95)\n                cost = dieselDolPerGal * Dslgge\n            elif \"gasoline\" in fuel_type.lower():\n                gasolineDolPerGal = regdf.loc[\"gasolineDolPerGal\", str(yr)]\n                cost = gasolineDolPerGal\n            elif \"electricity\" in fuel_type.lower():\n                dolPerKwh = regdf.loc[\"dolPerKwh\", str(yr)]\n                cost = dolPerKwh * 33.7  # 33.41 kwh per gallon of gasoline\n            elif fuel_type.lower() == \"cng\":\n                CNGDolPerGge = regdf.loc[\"CNGDolPerGge\", str(yr)]\n                cost = CNGDolPerGge\n            elif fuel_type.lower() == \"hydrogen\":\n                hydrogenDolPerGGE = regdf.loc[\"hydrogenDolPerGGE\", str(yr)]\n                cost = hydrogenDolPerGGE\n            else:\n                raise Exception(\n                    f\"TCO fuel calc: fill_fuel_expense_tsv:: unknown fuel type {fuel_type}\"\n                )\n            data.append([yr, fuel_type, cat, cost])\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_fuel_split_tsv","title":"<code>fill_fuel_split_tsv(vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario, mpgge: dict) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe of fraction of travel in each fuel type as Fraction of Travel [mi/mi]</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>mpgge</code> <code>dict</code> <p>MPGGE dictionary from fueleconomy.get_mpgge()</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing fraction of travel in each fuel type as Fraction of Travel [mi/mi]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_fuel_split_tsv(\n    vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario, mpgge: dict\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe of fraction of travel in each fuel type as Fraction of Travel [mi/mi]\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        mpgge (dict): MPGGE dictionary from fueleconomy.get_mpgge()\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing fraction of travel in each fuel type as Fraction of Travel [mi/mi]\n    \"\"\"\n    columns = [\"Vehicle\", \"Fuel\", \"Vocation\", \"Fraction of Travel [mi/mi]\"]\n    vocation = scenario.vocation\n    vehicle_segment = scenario.segment_name\n    fuels = scenario.fuel_type\n\n    if vehicle.veh_pt_type == gl.PHEV:\n        uf = run_scenario.get_phev_util_factor(scenario, vehicle, mpgge)\n\n    if vehicle.veh_pt_type != gl.PHEV:\n        frac_time_traveled_mi_mi = 1\n        data = [[vehicle_segment, fuels[0], vocation, frac_time_traveled_mi_mi]]\n    else:\n        data = [\n            [vehicle_segment, fuels[0], vocation, uf],  # cd_electricity\n            [vehicle_segment, fuels[1], vocation, uf],  # cd_diesel\n            [vehicle_segment, fuels[2], vocation, 1 - uf],  # cs_diesel\n        ]\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_insurance_tsv","title":"<code>fill_insurance_tsv(scenario: run_scenario.Scenario, veh_cost_set: dict) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe containing vehicle insurance costs as Cost [$/Yr]</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>veh_cost_set</code> <code>dict</code> <p>Dictionary containing MSRP costs</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing insurance costs in Cost [$/Yr]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_insurance_tsv(\n    scenario: run_scenario.Scenario, veh_cost_set: dict\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe containing vehicle insurance costs as Cost [$/Yr]\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        veh_cost_set (dict): Dictionary containing MSRP costs\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing insurance costs in Cost [$/Yr]\n    \"\"\"\n    columns = [\"Age [yr]\", \"Category\", \"Cost [$/Yr]\"]\n    data = []\n\n    veh_life_years = int(scenario.vehicle_life_yr)\n\n    insurance_rates = scenario.insurance_rates_pct_per_yr\n    assert len(insurance_rates) &gt;= veh_life_years, (\n        f\"vehicle_life_yr of {veh_life_years} &amp; length of input insurance rates {len(insurance_rates)} do not align; \"\n        f\"vehicle_life_yr life years &amp; number of years in vmt should match\\n\"\n        f\"[vehicle_life_yr/[VMT_1,...,VMT_N]]:[{veh_life_years}/{insurance_rates}]\"\n    )\n\n    MSRP = veh_cost_set[\"msrp\"]\n    for i in range(0, veh_life_years):\n        insurance_costperyear = insurance_rates[i] * MSRP / 100\n        # i is age, give it a vmt value for each entry in vmt or defer to last vmt entry\n        data.append([i, \"insurance\", insurance_costperyear])\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_market_share_tsv","title":"<code>fill_market_share_tsv(scenario: run_scenario.Scenario, num_vs: int = 1) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe containing market share of current vehicle selection per vehicle sold</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>num_vs</code> <code>int</code> <p>Number of vehicles. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing market share of current vehicle in Market Share [veh/veh]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_market_share_tsv(\n    scenario: run_scenario.Scenario, num_vs: int = 1\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe containing market share of current vehicle selection per vehicle sold\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        num_vs (int, optional): Number of vehicles. Defaults to 1.\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing market share of current vehicle in Market Share [veh/veh]\n    \"\"\"\n\n    vocation = scenario.vocation\n    vehicle = scenario.segment_name\n    reg = scenario.region\n\n    veh_life_years = int(scenario.vehicle_life_yr)\n    model_year = int(scenario.model_year)\n    data = []\n    columns = [\"Vehicle\", \"Vocation\", \"Model Year\", \"Region\", \"Market Share [veh/veh]\"]\n    data.append([vehicle, vocation, model_year, reg, 1 / num_vs])\n    for yr in range(model_year + 1, model_year + veh_life_years):\n        data.append([vehicle, vocation, yr, reg, 0])\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_reg_sales_tsv","title":"<code>fill_reg_sales_tsv(scenario: run_scenario.Scenario, num_vs: int = 1) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe containing vehicle sales per year - Sales [veh]</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>num_vs</code> <code>int</code> <p>Number of vehicles. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing vehicle sales in Sales [veh]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_reg_sales_tsv(\n    scenario: run_scenario.Scenario, num_vs: int = 1\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe containing vehicle sales per year - Sales [veh]\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        num_vs (int, optional): Number of vehicles. Defaults to 1.\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing vehicle sales in Sales [veh]\n    \"\"\"\n    veh_life_years = int(scenario.vehicle_life_yr)\n    model_year = int(scenario.model_year)\n    reg = scenario.region\n\n    columns = [\"Model Year\", \"Region\", \"Sales [veh]\"]\n    data = []\n    for yr in range(model_year, veh_life_years + model_year):\n        if yr == model_year:\n            data.append([yr, reg, num_vs])\n        else:\n            data.append([yr, reg, 0])\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_residual_cost_tsc","title":"<code>fill_residual_cost_tsc(vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario, veh_cost_set: dict) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe of residual costs as Cost [$/Yr]</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>veh_cost_set</code> <code>dict</code> <p>Dictionary containing MSRP costs</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing vehicle residual costs as Cost [$/Yr]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_residual_cost_tsc(\n    vehicle: fastsim.vehicle.Vehicle,\n    scenario: run_scenario.Scenario,\n    veh_cost_set: dict,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe of residual costs as Cost [$/Yr]\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        veh_cost_set (dict): Dictionary containing MSRP costs\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing vehicle residual costs as Cost [$/Yr]\n    \"\"\"\n    columns = [\"Age [yr]\", \"Category\", \"Cost [$/Yr]\"]\n    data = []\n\n    veh_life_years = int(scenario.vehicle_life_yr)\n\n    residual_rate = find_residual_rates(vehicle, scenario)\n\n    MSRP = veh_cost_set[\"msrp\"]\n    for i in range(0, veh_life_years):\n        if i == veh_life_years - 1:\n            residual_cost = -residual_rate * MSRP\n        else:\n            residual_cost = 0\n        data.append([i, \"residual cost\", residual_cost])\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_survival_tsv","title":"<code>fill_survival_tsv(scenario: run_scenario.Scenario, num_vs=1) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe containing surviving vehicles as Surviving Vehicles [veh/veh]</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>num_vs</code> <code>int</code> <p>Number of vehicles. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing number of surviving vehicles on road in Surviving Vehicles [veh/veh]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_survival_tsv(scenario: run_scenario.Scenario, num_vs=1) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe containing surviving vehicles as Surviving Vehicles [veh/veh]\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        num_vs (int, optional): Number of vehicles. Defaults to 1.\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing number of surviving vehicles on road in Surviving Vehicles [veh/veh]\n    \"\"\"\n\n    columns = [\"Age [yr]\", \"Surviving Vehicles [veh/veh]\"]\n    data = []\n    veh_life_span = int(scenario.vehicle_life_yr)\n    for yr in range(0, veh_life_span):\n        data.append([yr, num_vs / num_vs])\n\n    df = pd.DataFrame(data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_trav_exp_tsv","title":"<code>fill_trav_exp_tsv(vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe containing maintenance costs in Cost [$/mi]</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <p>Returns:</p> Name Type Description <code>df</code> <code>pd.DataFrame</code> <p>Dataframe containing maintenance costs in Cost [$/mi]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_trav_exp_tsv(\n    vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe containing maintenance costs in Cost [$/mi]\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n\n    Returns:\n        df (pd.DataFrame): Dataframe containing maintenance costs in Cost [$/mi]\n    \"\"\"\n\n    columns = [\"Year\", \"Region\", \"Vocation\", \"Vehicle\", \"Category\", \"Cost [$/mi]\"]\n    region = scenario.region\n    vocation = scenario.vocation\n    vehicle_name = scenario.segment_name\n    maint = scenario.maint_oper_cost_dol_per_mi\n    maint = list(np.float_(maint.strip(\" ][\").split(\",\")))\n    veh_life_years = int(scenario.vehicle_life_yr)\n\n    assert len(maint) == veh_life_years, (\n        f\"vehicle_life_yr of {veh_life_years} &amp; length of input maint_oper_cost_dol_per_mi {len(maint)} do not align; \"\n        f\"vehicle_life_yr life years &amp; number of years in vmt should match\\n\"\n        f\"[vehicle_life_yr/[maint_oper_cost_dol_per_mi_1,...,maint_oper_cost_dol_per_mi_N]]:[{veh_life_years}/{maint}]\"\n    )\n    data = []\n    for i, yr in enumerate(\n        range(int(scenario.model_year), int(scenario.model_year + veh_life_years))\n    ):\n        l1 = [yr, region, vocation, vehicle_name, \"maintenance\", maint[i]]\n        data.append(l1)\n\n    df = pd.DataFrame(data=data, columns=columns)\n\n    return df\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.fill_veh_expense_file","title":"<code>fill_veh_expense_file(scenario: run_scenario.Scenario, cost_set: dict) -&gt; pd.DataFrame</code>","text":"<p>This helper method generates a dataframe of MSRP breakdown costs as Cost [$/veh]</p> <p>Parameters:</p> Name Type Description Default <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <code>cost_set</code> <code>dict</code> <p>Dictionary containing MSRP breakdown cost components</p> required <p>Returns:</p> Name Type Description <code>vexpdf</code> <code>pd.DataFrame</code> <p>Dataframe containing MSRP components costs as Cost [$/veh]</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def fill_veh_expense_file(\n    scenario: run_scenario.Scenario, cost_set: dict\n) -&gt; pd.DataFrame:\n    \"\"\"\n    This helper method generates a dataframe of MSRP breakdown costs as Cost [$/veh]\n\n    Args:\n        scenario (run_scenario.Scenario): Scenario object of current selection\n        cost_set (dict): Dictionary containing MSRP breakdown cost components\n\n    Returns:\n        vexpdf (pd.DataFrame): Dataframe containing MSRP components costs as Cost [$/veh]\n    \"\"\"\n    # read in scenario values needed, such as segment name, vocation, etc.\n    vehicle = scenario.segment_name\n    vocation = scenario.vocation\n    model_year = int(scenario.model_year)\n\n    data = [\n        [vehicle, vocation, model_year, cost_set[\"Glider\"], \"Glider\"],\n        [vehicle, vocation, model_year, cost_set[\"Fuel converter\"], \"Fuel converter\"],\n        [vehicle, vocation, model_year, cost_set[\"Fuel Storage\"], \"Fuel Storage\"],\n        [\n            vehicle,\n            vocation,\n            model_year,\n            cost_set[\"Motor &amp; power electronics\"],\n            \"Motor &amp; power electronics\",\n        ],\n        [vehicle, vocation, model_year, cost_set[\"Plug\"], \"Plug\"],\n        [vehicle, vocation, model_year, cost_set[\"Battery\"], \"Battery\"],\n        [\n            vehicle,\n            vocation,\n            model_year,\n            cost_set[\"Battery replacement\"],\n            \"Battery replacement\",\n        ],\n        [vehicle, vocation, model_year, cost_set[\"Purchase tax\"], \"Purchase tax\"],\n    ]\n    vexpdf = pd.DataFrame(\n        data, columns=[\"Vehicle\", \"Vocation\", \"Model Year\", \"Cost [$/veh]\", \"Category\"]\n    )\n\n    return vexpdf\n</code></pre>"},{"location":"tcocalc/#t3co.tco.tcocalc.find_residual_rates","title":"<code>find_residual_rates(vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario) -&gt; float</code>","text":"<p>This helper method gets the residual rates from ResidualValues.csv</p> <p>Parameters:</p> Name Type Description Default <code>vehicle</code> <code>fastsim.vehicle.Vehicle</code> <p>FASTSim vehicle object of analysis vehicle</p> required <code>scenario</code> <code>run_scenario.Scenario</code> <p>Scenario object of current selection</p> required <p>Returns:</p> Name Type Description <code>residual_rates</code> <code>float</code> <p>Residual rate as percentage of MSRP</p> Source code in <code>t3co/tco/tcocalc.py</code> Python<pre><code>def find_residual_rates(\n    vehicle: fastsim.vehicle.Vehicle, scenario: run_scenario.Scenario\n) -&gt; float:  # finds residual rate at end of vehicle life\n    \"\"\"\n    This helper method gets the residual rates from ResidualValues.csv\n\n    Args:\n        vehicle (fastsim.vehicle.Vehicle): FASTSim vehicle object of analysis vehicle\n        scenario (run_scenario.Scenario): Scenario object of current selection\n\n    Returns:\n        residual_rates (float): Residual rate as percentage of MSRP\n    \"\"\"\n    residual_rates_all = pd.read_csv(gl.RESIDUAL_VALUE_PER_YEAR)\n    vehicle_class = scenario.vehicle_class\n    powertrain_type = vehicle.veh_pt_type.lower()\n    year = str(scenario.vehicle_life_yr)\n    residual_rates = residual_rates_all.loc[\n        (residual_rates_all[\"VehicleClass\"].str.lower() == vehicle_class)\n        &amp; (residual_rates_all[\"PowertrainType\"].str.lower() == powertrain_type)\n    ][year].values[0]\n    return residual_rates\n</code></pre>"},{"location":"vehicle_inputs_descriptions/","title":"Vehicle Input Descriptions","text":"Vehicle Input Parameter Description Data Type(s) Accepted scenario_name Vehicle name \u00a0string selection Vehicle database ID \u00a0int veh_year Vehicle year \u00a0int veh_pt_type Vehicle powertrain type, one of [CONV,\u00a0HEV,\u00a0PHEV,\u00a0BEV] \u00a0string drag_coef Aerodynamic drag coefficient \u00a0float frontal_area_m2 Frontal area, $m^2$ \u00a0float glider_kg Vehicle mass excluding cargo, passengers, and powertrain components, $kg$ \u00a0float veh_cg_m Vehicle center of mass height, $m$\u00a0NOTE:\u00a0positive for FWD, negative for RWD, AWD, 4WD \u00a0float drive_axle_weight_frac Fraction of weight on the drive axle while stopped \u00a0float wheel_base_m Wheelbase, $m$ \u00a0float cargo_kg Cargo mass including passengers, $kg$ \u00a0float veh_override_kg Total vehicle mass, overrides mass calculation, $kg$ (Optional) \u00a0float comp_mass_multiplier Component mass multiplier for vehicle mass calculation \u00a0float fs_max_kw Fuel storage max power output, $kW$ \u00a0float fs_secs_to_peak_pwr Fuel storage time to peak power, $s$ \u00a0float fs_kwh Fuel storage energy capacity, $kWh$ \u00a0float fs_kwh_per_kg Fuel specific energy, $\\frac{kWh}{kg}$ \u00a0float fc_max_kw Fuel converter peak continuous power, $kW$ \u00a0float fc_pwr_out_perc Fuel converter output power percentage map, x values of\u00a0fc_eff_map \u00a0list[float] fc_eff_map Fuel converter efficiency map \u00a0list[float] fc_eff_type Fuel converter efficiency type, one of [SI,\u00a0ATKINSON,\u00a0DIESEL,\u00a0H2FC,\u00a0HD_DIESEL] Used for calculating\u00a0fc_eff_map, and other calculations if H2FC \u00a0string fc_sec_to_peak_pwr Fuel converter time to peak power, $s$ \u00a0float fc_base_kg Fuel converter base mass, $kg$ \u00a0float fc_kw_per_kg Fuel converter specific power (power-to-weight ratio), $\\frac{kW}{kg}$ \u00a0float min_fc_time_on Minimum time fuel converter must be on before shutoff (for HEV, PHEV) \u00a0float idle_fc_kw Fuel converter idle power, $kW$ \u00a0float mc_max_kw Peak continuous electric motor power, $kW$ \u00a0float mc_pwr_out_perc Electric motor output power percentage map, x values of\u00a0mc_eff_map \u00a0list[float] mc_eff_map Electric motor efficiency map \u00a0list[float] mc_sec_to_peak_pwr Electric motor time to peak power, $s$ \u00a0float mc_pe_kg_per_kw Motor power electronics mass per power output, $\\frac{kg}{kW}$ \u00a0float mc_pe_base_kg Motor power electronics base mass, $kg$ \u00a0float ess_max_kw Traction battery maximum power output, $kW$ \u00a0float ess_max_kwh Traction battery energy capacity, $kWh$ \u00a0float ess_kg_per_kwh Traction battery mass per energy, $\\frac{kg}{kWh}$ \u00a0float ess_base_kg Traction battery base mass, $kg$ \u00a0float ess_round_trip_eff Traction battery round-trip efficiency \u00a0float ess_life_coef_a Traction battery cycle life coefficient A, see\u00a0reference \u00a0float ess_life_coef_b Traction battery cycle life coefficient B, see\u00a0reference \u00a0float min_soc Traction battery minimum state of charge \u00a0float max_soc Traction battery maximum state of charge \u00a0float ess_dischg_to_fc_max_eff_perc ESS discharge effort toward max FC efficiency \u00a0float ess_chg_to_fc_max_eff_perc ESS charge effort toward max FC efficiency \u00a0float wheel_inertia_kg_m2 Mass moment of inertia per wheel, $kg \\cdot m^2$ \u00a0float num_wheels Number of wheels \u00a0float wheel_rr_coef Rolling resistance coefficient \u00a0float wheel_radius_m Wheel radius, $m$ \u00a0float wheel_coef_of_fric Wheel coefficient of friction \u00a0float max_accel_buffer_mph Speed where the battery reserved for accelerating is zero \u00a0float max_accel_buffer_perc_of_useable_soc Percent of usable battery energy reserved to help accelerate \u00a0float perc_high_acc_buf Percent SOC buffer for high accessory loads during cycles with long idle time \u00a0float mph_fc_on Speed at which the fuel converter must turn on, $mph$ \u00a0float kw_demand_fc_on Power demand above which to require fuel converter on, $kW$ \u00a0float max_regen Maximum brake regeneration efficiency \u00a0float stop_start Stop/start micro-HEV flag \u00a0bool force_aux_on_fc Force auxiliary power load to come from fuel converter \u00a0bool alt_eff Alternator efficiency \u00a0float chg_eff Charger efficiency \u00a0float aux_kw Auxiliary load power, $kW$ \u00a0float trans_kg Transmission mass, $kg$ \u00a0float trans_eff Transmission efficiency \u00a0float ess_to_fuel_ok_error Maximum acceptable ratio of change in ESS energy to expended fuel energy (used in hybrid SOC balancing), $\\frac{\\Delta E_{ESS}}{\\Delta E_{fuel}}$ \u00a0float fc_peak_eff_override Fuel converter efficiency peak override, scales entire curve(Optional) \u00a0float mc_peak_eff_override Motor efficiency peak override, scales entire curve (Optional) \u00a0float"},{"location":"functions/CodeReference/","title":"Table of Contents","text":"<ul> <li>t3co</li> <li>t3co.visualization.charts</li> <li>T3COCharts<ul> <li>__init__</li> <li>from_file</li> <li>from_df</li> <li>to_df</li> <li>parse_scenario_name</li> <li>generate_tco_plots</li> <li>generate_violin_plot</li> <li>generate_histogram</li> </ul> </li> <li>t3co.visualization</li> <li>t3co.tco</li> <li>t3co.tco.tcocalc</li> <li>find_residual_rates</li> <li>calculate_dollar_cost</li> <li>calculate_opp_costs</li> <li>fill_fuel_eff_file</li> <li>fill_veh_expense_file</li> <li>fill_trav_exp_tsv</li> <li>fill_downtimelabor_cost_tsv</li> <li>fill_market_share_tsv</li> <li>fill_fuel_expense_tsv</li> <li>fill_annual_tsv</li> <li>fill_reg_sales_tsv</li> <li>fill_insurance_tsv</li> <li>fill_residual_cost_tsc</li> <li>fill_survival_tsv</li> <li>fill_fuel_split_tsv</li> <li>t3co.tco.opportunity_cost</li> <li>OpportunityCost<ul> <li>__init__</li> <li>set_kdes</li> <li>set_payload_loss_factor</li> <li>set_fueling_dwell_time_cost</li> <li>set_M_R_downtime_cost</li> </ul> </li> <li>main</li> <li>t3co.tco.tco_stock_emissions</li> <li>dropCols</li> <li>stockModel</li> <li>t3co.tco.tco_analysis</li> <li>get_operating_costs</li> <li>discounted_costs</li> <li>calc_discountedTCO</li> <li>get_tco_of_vehicle</li> <li>t3co.tests.test_tcos</li> <li>remove</li> <li>RunCONVTCOTests<ul> <li>compare</li> </ul> </li> <li>t3co.tests</li> <li>t3co.tests.tco_tests.t2co_tco_benchmark</li> <li>veh_no</li> <li>t3co.tests.tco_tests.t2co_bev_mpgge_benchmark</li> <li>veh_no</li> <li>t3co.tests.test_moo</li> <li>t3co.moopack</li> <li>t3co.moopack.moo</li> <li>T3COProblem<ul> <li>setup_opt_records</li> <li>__init__</li> <li>compile_reporting_vars</li> <li>instantiate_moo_vehicles_and_scenario</li> <li>cda_percent_delta_knob</li> <li>weight_delta_percent_knob</li> <li>fc_peak_eff_knob</li> <li>get_objs</li> <li>adjust_fc_peak_eff</li> <li>sweep_knob</li> <li>get_tco_from_moo_advanced_result</li> </ul> </li> <li>T3CODisplay<ul> <li>__init__</li> </ul> </li> <li>run_optimization</li> <li>t3co.objectives.accel</li> <li>get_accel</li> <li>t3co.objectives.fueleconomy</li> <li>get_range_mi</li> <li>get_sim_drive</li> <li>get_mpgge</li> <li>t3co.objectives.gradeability</li> <li>get_gradeability</li> <li>t3co.objectives</li> <li>t3co.utilities.demo_inputs_installer</li> <li>main</li> <li>copy_demo_input_files</li> <li>t3co.sweep</li> <li>deug_traces</li> <li>save_tco_files</li> <li>get_knobs_bounds_curves</li> <li>get_objectives_constraints</li> <li>run_moo</li> <li>check_input_files</li> <li>skip_scenario</li> <li>optimize</li> <li>run_vehicle_scenarios</li> <li>run_optimize_analysis</li> <li>t3co.run.Global</li> <li>DieselGalPerGasGal</li> <li>kgH2_per_gge</li> <li>mps_to_mph</li> <li>m_to_mi</li> <li>get_kwh_per_gge</li> <li>set_tco_intermediates</li> <li>set_tco_results</li> <li>kg_to_lbs</li> <li>lbs_to_kgs</li> <li>not_falsy</li> <li>t3co.run</li> <li>t3co.run.generateinputs</li> <li>generate</li> <li>t3co.run.run_scenario</li> <li>Config<ul> <li>from_file</li> <li>from_dict</li> <li>validate_analysis_id</li> <li>check_drivecycles_and_create_selections</li> </ul> </li> <li>Scenario<ul> <li>originalcargo_kg</li> <li>plf_scenario_vehicle_cargo_capacity_kg</li> <li>from_config</li> </ul> </li> <li>check_phev_init_socs</li> <li>get_phev_util_factor</li> <li>get_objective_simdrive</li> <li>run_grade_or_accel</li> <li>create_fastsim_vehicle</li> <li>get_vehicle</li> <li>get_scenario_and_cycle</li> <li>load_scenario</li> <li>load_design_cycle_from_scenario</li> <li>load_design_cycle_from_path</li> <li>set_test_weight</li> <li>reset_vehicle_weight</li> <li>limit_cargo_kg_for_moo_hev_bev</li> <li>set_max_motor_kw</li> <li>set_max_battery_kwh</li> <li>set_max_battery_power_kw</li> <li>set_max_fuel_converter_kw</li> <li>set_fuel_store_kwh</li> <li>set_cargo_kg</li> <li>vehicle_scenario_sweep</li> <li>run</li> <li>rerun</li> <li>t3co.demos.opp_cost_demo</li> <li>t3co.demos.hev_sweep_and_moo</li> <li>vnum</li> <li>t3co.demos.example_load_and_run</li> <li>t3co.demos.t2co_opt_benchmark</li> <li>t3co.demos.visualization_demo</li> <li>t3co.demos.Spencer</li> </ul>"},{"location":"functions/CodeReference/#t3co","title":"t3co","text":""},{"location":"functions/CodeReference/#t3covisualizationcharts","title":"t3co.visualization.charts","text":""},{"location":"functions/CodeReference/#t3cocharts-objects","title":"T3COCharts Objects","text":"Python<pre><code>class T3COCharts()\n</code></pre> <p>This class takes T3CO output CSV file as input and generates different plots to gain insights from T3CO Results</p> <p></p>"},{"location":"functions/CodeReference/#__init__","title":"__init__","text":"Python<pre><code>def __init__(\n    filename: str = None,\n    results_df: pd.DataFrame = None,\n    results_guide: str | Path = Path(__file__).parents[1] / \"resources\" /\n    \"visualization\" / \"t3co_outputs_guide.csv\"\n) -&gt; None\n</code></pre> <p>This constructor initializes the T3COCharts object either from a dataframe or a CSV file path.</p> <p>Arguments:</p> <ul> <li><code>filename</code> str, optional - Filepath to T3CO Results CSV File. Defaults to None.</li> <li><code>results_df</code> pd.DataFrame, optional - Input pandas dataframe containing T3CO Results. Defaults to None.</li> <li><code>results_guide</code> str | Path, optional - File path to t3co_outputs_guide.csv file that contains useful parameter descriptions and axis labels. Defaults to Path(file).parents[1]/\"resources\"/\"visualization\"/\"t3co_outputs_guide.csv\".</li> </ul> <p></p>"},{"location":"functions/CodeReference/#from_file","title":"from_file","text":"Python<pre><code>def from_file(filename: str | Path = None) -&gt; None\n</code></pre> <p>This method reads a T3CO Results CSV file into a dataframe</p> <p>Arguments:</p> <ul> <li><code>filename</code> str | Path, optional - Path to T3CO Results CSV File. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/CodeReference/#from_df","title":"from_df","text":"Python<pre><code>def from_df(results_df: pd.DataFrame) -&gt; None\n</code></pre> <p>This method reads t3co_results from a dataframe</p> <p>Arguments:</p> <ul> <li><code>results_df</code> pd.DataFrame - Input T3CO Results dataframe</li> </ul> <p></p>"},{"location":"functions/CodeReference/#to_df","title":"to_df","text":"Python<pre><code>def to_df() -&gt; pd.DataFrame\n</code></pre> <p>This returns the self.t3co_results member</p> <p>Returns:</p> <ul> <li><code>pd.DataFrame</code> - T3CO Results dataframe</li> </ul> <p></p>"},{"location":"functions/CodeReference/#parse_scenario_name","title":"parse_scenario_name","text":"Python<pre><code>def parse_scenario_name() -&gt; None\n</code></pre> <p>This method parses 'scenario_name' into 'vehicle_type', 'tech_progress', and 'vehicle_fuel_type' and uses 'scenario_gvwr_kg' to create 'vehicle_weight_class'</p> <p></p>"},{"location":"functions/CodeReference/#generate_tco_plots","title":"generate_tco_plots","text":"Python<pre><code>def generate_tco_plots(x_group_col: str,\n                       y_group_col: str,\n                       subplot_group_col: str = \"vehicle_fuel_type\",\n                       fig_x_size: int = 8,\n                       fig_y_size: int = 8,\n                       bar_width: float = 0.8,\n                       legend_pos: float = 0.25,\n                       edgecolor: str = \"none\") -&gt; matplotlib.figure.Figure\n</code></pre> <p>This method generates a TCO Breakdown plot based on input arguments. If x_group_col and/or y_group_col are provided, then a matrix/grid of subplots are generated within the same figure based on row- and column-wise groupings</p> <p>Arguments:</p> <ul> <li><code>x_group_col</code> str - T3CO Results parameter name to group on x-axis, i.e., grouping criteria for columns in subplots grid</li> <li><code>y_group_col</code> str - T3CO Results parameter name to group on y-axis, i.e., grouping criteria for rows in subplots grid</li> <li><code>subplot_group_col</code> str, optional - T3CO Results parameter to display within each subplots cell. Defaults to \"vehicle_fuel_type\".</li> <li><code>fig_x_size</code> int, optional - Figure width relative to each bar on x-axis within subplot. Defaults to 8.</li> <li><code>fig_y_size</code> int, optional - Figure height relative to each subplot cell. Defaults to 8.</li> <li><code>bar_width</code> float, optional - Relative width of bars based on available width. Takes values between 0.0 and 1.0. Defaults to 0.8.</li> <li><code>legend_pos</code> float, optional - Relative position of legend on the right side of plots. Takes values between 0.0 and 1.0. Defaults to 0.25.</li> <li><code>edgecolor</code> str, optional - Edge color to distinguish cost elements in the stacked bars. Defaults to \"none\".</li> </ul> <p>Returns:</p> <ul> <li><code>matplotlib.figure.Figure</code> - TCO Breakdown Figure object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#generate_violin_plot","title":"generate_violin_plot","text":"Python<pre><code>def generate_violin_plot(\n        x_group_col: str,\n        y_group_col: str = \"discounted_tco_dol\") -&gt; matplotlib.figure.Figure\n</code></pre> <p>This method generates a violin plot based on x-axis group column and y-axis column name.</p> <p>Arguments:</p> <ul> <li><code>x_group_col</code> str - T3CO Results parameter to group by on x-axis inside violinplot</li> <li><code>y_group_col</code> str, optional - T3CO Results parameter to plot on y-axis. Defaults to \"discounted_tco_dol\".</li> </ul> <p>Returns:</p> <ul> <li><code>matplotlib.figure.Figure</code> - Violin Plot Figure object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#generate_histogram","title":"generate_histogram","text":"Python<pre><code>def generate_histogram(hist_col: str,\n                       n_bins: int,\n                       show_pct: bool = False) -&gt; matplotlib.figure.Figure\n</code></pre> <p>This method generates a histogram plot based on inputs hist_col and n_bins</p> <p>Arguments:</p> <ul> <li><code>hist_col</code> str - T3CO column name to plot histogram</li> <li><code>n_bins</code> int - Number of bins in histogram</li> <li><code>show_pct</code> bool, optional - If True, plots percentage on y-axis instead of number of items. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>matplotlib.figure.Figure</code> - Histogram figure object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3covisualization","title":"t3co.visualization","text":""},{"location":"functions/CodeReference/#t3cotco","title":"t3co.tco","text":""},{"location":"functions/CodeReference/#t3cotcotcocalc","title":"t3co.tco.tcocalc","text":""},{"location":"functions/CodeReference/#find_residual_rates","title":"find_residual_rates","text":"Python<pre><code>def find_residual_rates(vehicle: fastsim.vehicle.Vehicle,\n                        scenario: run_scenario.Scenario) -&gt; float\n</code></pre> <p>This helper method gets the residual rates from ResidualValues.csv</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>residual_rates</code> float - Residual rate as percentage of MSRP</li> </ul> <p></p>"},{"location":"functions/CodeReference/#calculate_dollar_cost","title":"calculate_dollar_cost","text":"Python<pre><code>def calculate_dollar_cost(veh: fastsim.vehicle.Vehicle,\n                          scenario: run_scenario.Scenario) -&gt; dict\n</code></pre> <p>This helper method calculates the MSRP breakdown dictionary from -   Glider -   Fuel converter -   Fuel Storage -   Motor &amp; power electronics -   Plug -   Battery -   Battery replacement -   Purchase tax</p> <p>Arguments:</p> <ul> <li><code>veh</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>cost_set</code> dict - Dictionary containing MSRP breakdown</li> </ul> <p></p>"},{"location":"functions/CodeReference/#calculate_opp_costs","title":"calculate_opp_costs","text":"Python<pre><code>def calculate_opp_costs(vehicle: fastsim.vehicle.Vehicle,\n                        scenario: run_scenario.Scenario,\n                        range_dict: dict) -&gt; dict\n</code></pre> <p>This helper method calculates opportunity costs and generates veh_opp_cost_set from -   Payload Lost Capacity Cost/Multiplier -   Fueling Downtime -   Maintenance and Repair Downtime</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>range_dict</code> dict - Dictionary containing range values from fueleconomy.get_range_mi()</li> </ul> <p>Returns:</p> <ul> <li><code>veh_opp_cost_set</code> dict - Dictionary containing opportunity cost results</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_fuel_eff_file","title":"fill_fuel_eff_file","text":"Python<pre><code>def fill_fuel_eff_file(vehicle: fastsim.vehicle.Vehicle,\n                       scenario: run_scenario.Scenario,\n                       mpgge_dict: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of Fuel Efficiency [mi/gge] For PHEV, cd_grid_electric_mpgge, cd_fuel_mpgge, and cs_fuel_mpgge For BEV, grid_mpgge For HEV and CONV, mpgge</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>mpgge_dict</code> dict - MPGGE dictionary from fueleconomy.get_mpgge()</li> </ul> <p>Returns:</p> <ul> <li><code>fefdata</code> pd.DataFrame - Dictionary containing Fuel Efficiency [mi/gge]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_veh_expense_file","title":"fill_veh_expense_file","text":"Python<pre><code>def fill_veh_expense_file(scenario: run_scenario.Scenario,\n                          cost_set: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of MSRP breakdown costs as Cost [$/veh]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>cost_set</code> dict - Dictionary containing MSRP breakdown cost components</li> </ul> <p>Returns:</p> <ul> <li><code>vexpdf</code> pd.DataFrame - Dataframe containing MSRP components costs as Cost [$/veh]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_trav_exp_tsv","title":"fill_trav_exp_tsv","text":"Python<pre><code>def fill_trav_exp_tsv(vehicle: fastsim.vehicle.Vehicle,\n                      scenario: run_scenario.Scenario) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing maintenance costs in Cost [$/mi]</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing maintenance costs in Cost [$/mi]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_downtimelabor_cost_tsv","title":"fill_downtimelabor_cost_tsv","text":"Python<pre><code>def fill_downtimelabor_cost_tsv(scenario: run_scenario.Scenario,\n                                oppy_cost_set: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing fueling downtime and M&amp;R downtime costs in Cost [$/Yr]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>oppy_cost_set</code> dict - Dictionary containing fueling_downtime_oppy_cost_dol_per_yr,fueling_dwell_labor_cost_dol_per_yr and mr_downtime_oppy_cost_dol_per_yr</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing fueling and MR downtime costs in Cost [$/Yr]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_market_share_tsv","title":"fill_market_share_tsv","text":"Python<pre><code>def fill_market_share_tsv(scenario: run_scenario.Scenario,\n                          num_vs: int = 1) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing market share of current vehicle selection per vehicle sold</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>num_vs</code> int, optional - Number of vehicles. Defaults to 1.</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing market share of current vehicle in Market Share [veh/veh]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_fuel_expense_tsv","title":"fill_fuel_expense_tsv","text":"Python<pre><code>def fill_fuel_expense_tsv(vehicle: fastsim.vehicle.Vehicle,\n                          scenario: run_scenario.Scenario) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of fuel operating costs in Cost [$/gge]</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code> - Invalid fuel_type type</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing fuel operating costs in Cost [$/gge]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_annual_tsv","title":"fill_annual_tsv","text":"Python<pre><code>def fill_annual_tsv(scenario: run_scenario.Scenario) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of annual vehicle miles traveled (vmt) - Annual Travel [mi/yr]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing Annual Travel [mi/yr]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_reg_sales_tsv","title":"fill_reg_sales_tsv","text":"Python<pre><code>def fill_reg_sales_tsv(scenario: run_scenario.Scenario,\n                       num_vs: int = 1) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing vehicle sales per year - Sales [veh]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>num_vs</code> int, optional - Number of vehicles. Defaults to 1.</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing vehicle sales in Sales [veh]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_insurance_tsv","title":"fill_insurance_tsv","text":"Python<pre><code>def fill_insurance_tsv(scenario: run_scenario.Scenario,\n                       veh_cost_set: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing vehicle insurance costs as Cost [$/Yr]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>veh_cost_set</code> dict - Dictionary containing MSRP costs</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing insurance costs in Cost [$/Yr]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_residual_cost_tsc","title":"fill_residual_cost_tsc","text":"Python<pre><code>def fill_residual_cost_tsc(vehicle: fastsim.vehicle.Vehicle,\n                           scenario: run_scenario.Scenario,\n                           veh_cost_set: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of residual costs as Cost [$/Yr]</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>veh_cost_set</code> dict - Dictionary containing MSRP costs</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing vehicle residual costs as Cost [$/Yr]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_survival_tsv","title":"fill_survival_tsv","text":"Python<pre><code>def fill_survival_tsv(scenario: run_scenario.Scenario,\n                      num_vs=1) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing surviving vehicles as Surviving Vehicles [veh/veh]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>num_vs</code> int, optional - Number of vehicles. Defaults to 1.</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing number of surviving vehicles on road in Surviving Vehicles [veh/veh]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fill_fuel_split_tsv","title":"fill_fuel_split_tsv","text":"Python<pre><code>def fill_fuel_split_tsv(vehicle: fastsim.vehicle.Vehicle,\n                        scenario: run_scenario.Scenario,\n                        mpgge: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of fraction of travel in each fuel type as Fraction of Travel [mi/mi]</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>mpgge</code> dict - MPGGE dictionary from fueleconomy.get_mpgge()</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing fraction of travel in each fuel type as Fraction of Travel [mi/mi]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3cotcoopportunity_cost","title":"t3co.tco.opportunity_cost","text":""},{"location":"functions/CodeReference/#opportunitycost-objects","title":"OpportunityCost Objects","text":"Python<pre><code>class OpportunityCost()\n</code></pre> <p>This class is used to calculate the different opportunity costs for a scenario and vehicle - Payload Capacity Cost Multiplier - Fueling Downtime Cost - Maintenance and Repair Downtime Cost</p> <p></p>"},{"location":"functions/CodeReference/#__init___1","title":"__init__","text":"Python<pre><code>def __init__(scenario: run_scenario.Scenario,\n             range_dict: dict = None,\n             **kwargs) -&gt; None\n</code></pre> <p>Initializes OpportunityCost object using Scenario object, range_dict (from fueleconomy module), and other arguments</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object</li> <li><code>range_dict</code> dict, optional - dictionary containing primary_fuel_range_mi from fueleconomy.get_range_mi function. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_kdes","title":"set_kdes","text":"Python<pre><code>def set_kdes(scenario: run_scenario.Scenario,\n             bw_method: float = 0.15,\n             verbose: bool = False) -&gt; None\n</code></pre> <p>This method sets tje kde kernel. This is time-consuming, only call this once, if possible.</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object</li> <li><code>bw_method</code> float, optional - kernel bandwidth method used by guassian_kde. Defaults to .15.</li> <li><code>verbose</code> bool, optional - if True, prints process sets. Defaults to False.</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_payload_loss_factor","title":"set_payload_loss_factor","text":"Python<pre><code>def set_payload_loss_factor(a_vehicle: fastsim.vehicle.Vehicle,\n                            scenario: run_scenario.Scenario,\n                            plots: bool = False,\n                            plots_dir: str = None) -&gt; None\n</code></pre> <p>This method runs teh kernel density estimation function set_kdes and calculates the payload capacity loss factor (payload_cap_cost_multiplier)             of the new vehicle compared to a conventional vehicle's reference empty weight.</p> <p>Arguments:</p> <ul> <li><code>a_vehicle</code> fastsim.vehicle - FASTSim vehicle object of the analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>plots</code> bool, optional - if True, creates histogram of KDE weight bins. Defaults to False.</li> <li><code>plots_dir</code> str, optional - output diretory for saving plot figure. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_fueling_dwell_time_cost","title":"set_fueling_dwell_time_cost","text":"Python<pre><code>def set_fueling_dwell_time_cost(a_vehicle: fastsim.vehicle.Vehicle,\n                                scenario: run_scenario.Scenario) -&gt; None\n</code></pre> <p>This function calculates the fueling dwell time cost for a vehicle based on fuel fill rate/charging power and shifts_per_year</p> <p>Arguments:</p> <ul> <li><code>a_vehicle</code> fastsim.vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_m_r_downtime_cost","title":"set_M_R_downtime_cost","text":"Python<pre><code>def set_M_R_downtime_cost(a_vehicle: fastsim.vehicle.Vehicle,\n                          scenario: run_scenario.Scenario) -&gt; None\n</code></pre> <p>This function calculates the Maintenance and Repair (M&amp;R) downtime cost based on planned, unplanned, and tire replacement downtime inputs</p> <p>Arguments:</p> <ul> <li><code>a_vehicle</code> fastsim.vehicle - FASTSim object of the analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for the current selection</li> </ul> <p></p>"},{"location":"functions/CodeReference/#main","title":"main","text":"Python<pre><code>def main()\n</code></pre> <p>Runs the opportunity cost module as a standalone code based on input vehicles and scenarios</p> <p></p>"},{"location":"functions/CodeReference/#t3cotcotco_stock_emissions","title":"t3co.tco.tco_stock_emissions","text":""},{"location":"functions/CodeReference/#dropcols","title":"dropCols","text":"Python<pre><code>def dropCols(df: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>This helper method drops columns if any row contains ['*']</p> <p>Arguments:</p> <ul> <li><code>df</code> pd.DataFrame - Input dataframe</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Output dataframe with dropped dummy columns</li> </ul> <p></p>"},{"location":"functions/CodeReference/#stockmodel","title":"stockModel","text":"Python<pre><code>def stockModel(\n    sales: pd.DataFrame,\n    marketShares: pd.DataFrame,\n    survival: pd.DataFrame,\n    annualTravel: pd.DataFrame,\n    fuelSplit: pd.DataFrame,\n    fuelEfficiency: pd.DataFrame,\n    emissions: pd.DataFrame,\n    vehicleCosts: pd.DataFrame = None,\n    travelCosts: pd.DataFrame = None,\n    fuelCosts: pd.DataFrame = None,\n    insuranceCosts: pd.DataFrame = None,\n    residualCosts: pd.DataFrame = None,\n    downtimeCosts: pd.DataFrame = None,\n    write_files: bool = False\n) -&gt; Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]\n</code></pre> <p>This function generates the ownershipCosts dataframe from the dataframes for each cost category</p> <p>Arguments:</p> <ul> <li><code>sales</code> pd.DataFrame - Dataframe of yearly number of vehicles sales</li> <li><code>marketShares</code> pd.DataFrame - Dataframe of yearly Market Share of selection's vocation per vehicle [veh/veh]</li> <li><code>survival</code> pd.DataFrame - Dataframe of yearly Surviving vehicle per each vehicle [veh/veh]</li> <li><code>annualTravel</code> pd.DataFrame - Dataframe of vehicle's vmt: Annual Travel [mi/yr]</li> <li><code>fuelSplit</code> pd.DataFrame - Dataframe of fraction of travel using each fuel [mi/mi]</li> <li><code>fuelEfficiency</code> pd.DataFrame - Dataframe of vehicle's yearly average fuel efficiency [mi/gge]</li> <li><code>emissions</code> pd.DataFrame - Dataframe of vehicle's yearly average emissions</li> <li><code>vehicleCosts</code> pd.DataFrame, optional - Dataframe of vehicle components costs [dol]. Defaults to None.</li> <li><code>travelCosts</code> pd.DataFrame, optional - Dataframe of maintenance costs [dol/mi]. Defaults to None.</li> <li><code>fuelCosts</code> pd.DataFrame, optional - Dataframe of fuel operating costs [dol/gge]. Defaults to None.</li> <li><code>insuranceCosts</code> pd.DataFrame, optional - Dataframe of yearly insurance costs [dol]. Defaults to None.</li> <li><code>residualCosts</code> pd.DataFrame, optional - Dataframe of yearly residual costs [dol]. Defaults to None.</li> <li><code>downtimeCosts</code> pd.DataFrame, optional - Dataframe of yearly downtime costs [dol]. Defaults to None.</li> <li><code>write_files</code> bool, optional - if True, save vehicleCosts, travelCosts, fuelCosts, insuranceCosts,residualCosts, downtimeCosts . Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>stock</code> pd.DataFrame - Dataframe of stock model of vehicles in the market</li> <li><code>emissions</code> pd.DataFrame - Dataframe of total emissions</li> <li><code>ownershipCosts</code> pd.DataFrame - Dataframe of all ownership costs for given selection</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3cotcotco_analysis","title":"t3co.tco.tco_analysis","text":""},{"location":"functions/CodeReference/#get_operating_costs","title":"get_operating_costs","text":"Python<pre><code>def get_operating_costs(ownershipCosts: pd.DataFrame,\n                        TCO_switch: str = \"DIRECT\") -&gt; pd.DataFrame\n</code></pre> <p>This function creates a dataframe of operating cost from ownershipCosts dataframe based on TCO_switch ('DIRECT' or 'EFFICIENCY')</p> <p>Arguments:</p> <ul> <li><code>ownershipCosts</code> pd.DataFrame - Dataframe containing year-wise ownership costs estimations like Fuel, maintenance, insurance, etc</li> <li><code>TCO_switch</code> str, optional - Switch between different TCO calculations - 'DIRECT' or 'EFFICIENCY'. Defaults to 'DIRECT'.</li> </ul> <p>Returns:</p> <ul> <li><code>operatingCosts_df</code> pd.DataFrame - Dataframe containing operating cost categories based on TCO_switch</li> </ul> <p></p>"},{"location":"functions/CodeReference/#discounted_costs","title":"discounted_costs","text":"Python<pre><code>def discounted_costs(scenario: run_scenario.Scenario,\n                     ownershipCosts: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>This function calculates the yearly discounted costs for each category of ownershipCosts based on scenario.discRate</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> <li><code>ownershipCosts</code> pd.DataFrame - Dataframe containing year-wise ownership costs estimations like Fuel, maintenance, insurance, etc</li> </ul> <p>Returns:</p> <ul> <li><code>ownershipCosts</code> pd.DataFrame - ownershipCosts dataframe with additional 'Discounted Cost [$]' column</li> </ul> <p></p>"},{"location":"functions/CodeReference/#calc_discountedtco","title":"calc_discountedTCO","text":"Python<pre><code>def calc_discountedTCO(scenario: run_scenario.Scenario,\n                       discounted_costs_df: pd.DataFrame,\n                       veh_cost_set: dict,\n                       veh_opp_cost_set: dict,\n                       sim_drive: fastsim.simdrive.SimDrive,\n                       TCO_switch: str = \"DIRECT\") -&gt; Tuple[float, dict, dict]\n</code></pre> <p>This function calculates the discounted Total Cost of Ownerhip (discounted to account for time-value of money). There are two methods to calculate discounted TCO - 'DIRECT' and 'EFFICIENCY'</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> <li><code>discounted_costs_df</code> pd.DataFrame - discounted operating costs dataframe</li> <li><code>veh_cost_set</code> dict - Dictionary containing MSRP breakdown</li> <li><code>veh_opp_cost_set</code> dict - Dictionary containing opportunity costs breakdown</li> <li><code>sim_drive</code> fastsim.simdrive.SimDrive - FASTSim.simdrive.SimDrive object containing inputs and outputs from vehicle simulation over a cycle</li> <li><code>TCO_switch</code> str, optional - Switch between different TCO calculations - 'DIRECT' or 'EFFICIENCY'. Defaults to 'DIRECT'.</li> </ul> <p>Returns:</p> <ul> <li><code>discounted_tco_dol</code> float - Discounted Total Cost of Ownership value</li> <li><code>oppy_cost_dol_set</code> dict - Dictionary containing discounted opportunity costs breakdown</li> <li><code>veh_oper_cost_set</code> dict - Dictionary containing discounted operating costs breakdown</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_tco_of_vehicle","title":"get_tco_of_vehicle","text":"Python<pre><code>def get_tco_of_vehicle(\n    vehicle: fastsim.vehicle.Vehicle,\n    range_cyc: fastsim.cycle.Cycle,\n    scenario: run_scenario.Scenario,\n    write_tsv: bool = False\n) -&gt; Tuple[\n        float,\n        float,\n        dict,\n        pd.DataFrame,\n        pd.DataFrame,\n        dict,\n        dict,\n        fastsim.simdrive.SimDrive,\n        dict,\n        dict,\n        dict,\n]\n</code></pre> <p>This function calculates the Total Cost of Ownership of a vehicle and scenario for a given cycle. The three main components are: - Opportunity Costs - MSRP - Operating Costs</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of selected vehicle</li> <li><code>range_cyc</code> fastsim.cycle.Cycle - FASTSim range cycle object</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> <li><code>write_tsv</code> bool, optional - if True, save intermediate files as TSV. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>tot_cost_dol</code> float - TCO in dollars</li> <li><code>discounted_tco_dol</code> float - discounted TCO in dollars</li> <li><code>oppy_cost_set</code> dict - Dictionary of opportunity cost breakdown</li> <li><code>ownership_costs_df</code> pd.DataFrame - Ownerhip Costs dataframe containing different categories per year</li> <li><code>discounted_costs_df</code> pd.DataFrame - discounted Ownerhip Costs dataframe containing different categories per year</li> <li><code>mpgge</code> dict - Dictionary containing MPGGEs</li> <li><code>veh_cost_set</code> dict - Dictionary containing MSRP breakdown</li> <li><code>design_cycle_sdr</code> fastsim.simdrive.SimDrive - FASTSim SimDrive object for design drivecycle</li> <li><code>veh_oper_cost_set</code> dict - Dictionary containing operating costs breakdown</li> <li><code>veh_opp_cost_set</code> dict - Dictionary containing opportunity costs breakdown</li> <li><code>tco_files</code> dict - Dictionary containing TCO intermediate dataframes</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3coteststest_tcos","title":"t3co.tests.test_tcos","text":"<p>Testing module for TCO to ensure the TCO related results remain consistent over time</p> <p>Flow: code reads TCO tests vehicles and scenarios one at a time. Generates TCO output dictionaries and compares the results with the hard coded dictionaries below in comparison_dict.</p> <p></p>"},{"location":"functions/CodeReference/#remove","title":"remove","text":"Python<pre><code>def remove(out)\n</code></pre> <p>removes key-values from output dict that can't be compared very easily</p> <p></p>"},{"location":"functions/CodeReference/#runconvtcotests-objects","title":"RunCONVTCOTests Objects","text":"Python<pre><code>class RunCONVTCOTests(unittest.TestCase)\n</code></pre>"},{"location":"functions/CodeReference/#compare","title":"compare","text":"Python<pre><code>def compare(runresults, staticresults)\n</code></pre> <p>Check all key-value pairs between dicts for equality</p> <p>Arguments:</p> <ul> <li><code>runresults</code>: dict of results from generated vehicle results</li> <li><code>staticresults</code>: dict of results from static comparison dict</li> </ul> <p>Returns:</p> <p>None</p> <p></p>"},{"location":"functions/CodeReference/#t3cotests","title":"t3co.tests","text":"<p>Package for testing modules compliant with unittest folder structure.</p> <p></p>"},{"location":"functions/CodeReference/#t3coteststco_testst2co_tco_benchmark","title":"t3co.tests.tco_tests.t2co_tco_benchmark","text":"<p>Testing module for TCO to ensure the TCO related results remain consistent over time with previous model (Tech Targets c 2019)</p> <p>Flow: code reads TCO tests vehicles and scenarios one at a time. Generates TCO output dictionaries and compares the results with the hard coded dictionaries below in comparison_dict.</p> <p></p>"},{"location":"functions/CodeReference/#veh_no","title":"veh_no","text":""},{"location":"functions/CodeReference/#t3coteststco_testst2co_bev_mpgge_benchmark","title":"t3co.tests.tco_tests.t2co_bev_mpgge_benchmark","text":"<p>Testing module for TCO to ensure the TCO related results remain consistent over time with previous model (Tech Targets c 2019)</p> <p>Flow: code reads TCO tests vehicles and scenarios one at a time. Generates TCO output dictionaries and compares the results with the hard coded dictionaries below in comparison_dict.</p> <p></p>"},{"location":"functions/CodeReference/#veh_no_1","title":"veh_no","text":""},{"location":"functions/CodeReference/#t3coteststest_moo","title":"t3co.tests.test_moo","text":"<p>Module for testing moo.  Folder structure, file name, and code  are written to be compliant with python's unittest package, but  main() can be called via importing</p> <p></p>"},{"location":"functions/CodeReference/#t3comoopack","title":"t3co.moopack","text":"<p>Sub-package contaning module that runs PyMOO optimization</p> <p></p>"},{"location":"functions/CodeReference/#t3comoopackmoo","title":"t3co.moopack.moo","text":""},{"location":"functions/CodeReference/#t3coproblem-objects","title":"T3COProblem Objects","text":"Python<pre><code>class T3COProblem(ElementwiseProblem)\n</code></pre> <p>Class for creating PyMoo problem.</p> <p></p>"},{"location":"functions/CodeReference/#setup_opt_records","title":"setup_opt_records","text":"Python<pre><code>def setup_opt_records()\n</code></pre> <p>This method sets up the empty optimization record arrays</p> <p></p>"},{"location":"functions/CodeReference/#__init___2","title":"__init__","text":"Python<pre><code>def __init__(knobs_bounds: dict,\n             vnum: float,\n             optimize_pt: str,\n             obj_list: list = None,\n             constr_list: list = None,\n             verbose: bool = False,\n             config: run_scenario.Config = None,\n             do_input_validation: bool = False,\n             **kwargs) -&gt; None\n</code></pre> <p>This constructor initializes optimization input variables</p> <p>Arguments:</p> <ul> <li><code>knobs_bounds</code> dict - Dictionary containing knobs bounds for optimization</li> <li><code>vnum</code> float - Vehicle selection number</li> <li><code>optimize_pt</code> str, optional - Vehicle powertrain type - Conv, BEV, HEV, PHEV. Defaults to gl.BEV.</li> <li><code>obj_list</code> list, optional - List of objectives. Defaults to None.</li> <li><code>constr_list</code> list, optional - List of constraints. Defaults to None.</li> <li><code>verbose</code> bool, optional - if True, prints process steps. Defaults to False.</li> <li><code>config</code> run_scenario.Config, optional - T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/CodeReference/#compile_reporting_vars","title":"compile_reporting_vars","text":"Python<pre><code>def compile_reporting_vars() -&gt; None\n</code></pre> <p>This method creates an output dictionary containing optimization results</p> <p></p>"},{"location":"functions/CodeReference/#instantiate_moo_vehicles_and_scenario","title":"instantiate_moo_vehicles_and_scenario","text":"Python<pre><code>def instantiate_moo_vehicles_and_scenario(\n        vnum: int,\n        config: run_scenario.Config = None,\n        do_input_validation: bool = False) -&gt; None\n</code></pre> <p>This method instantiates the multi-objective optimization problem vehicles and scenarios, starting with the baseline Conventional vehicle.</p> <p>Arguments:</p> <ul> <li><code>vnum</code> int - vehicle selection number</li> <li><code>config</code> run_scenario.Config, optional - T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code> - Invalid optimize_pt selection</li> </ul> <p></p>"},{"location":"functions/CodeReference/#cda_percent_delta_knob","title":"cda_percent_delta_knob","text":"Python<pre><code>def cda_percent_delta_knob(CdA_perc_reduction: str,\n                           optvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This method sets the drag_coef based on aero improvement curve and glider_kg based on cda_cost_coeff_a and cda_cost_coeff_b</p> <p>Arguments:</p> <ul> <li><code>CdA_perc_reduction</code> str - Name of aero improvement curve file</li> <li><code>optvehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for optimization vehicle</li> </ul> <p></p>"},{"location":"functions/CodeReference/#weight_delta_percent_knob","title":"weight_delta_percent_knob","text":"Python<pre><code>def weight_delta_percent_knob(wt_perc_reduction: float,\n                              optvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This method sets the knob from the lightweighting curve</p> <p>Arguments:</p> <ul> <li><code>wt_perc_reduction</code> float - Weight reduction percentage value from lightweighting curve</li> <li><code>optvehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of the optimization vehicle</li> </ul> <p></p>"},{"location":"functions/CodeReference/#fc_peak_eff_knob","title":"fc_peak_eff_knob","text":"Python<pre><code>def fc_peak_eff_knob(fc_peak_eff: float,\n                     optvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This method sets the knob from the engine efficiency curve</p> <p>Arguments:</p> <ul> <li><code>fc_peak_eff</code> float - Fuel converter peak effiency override from engine efficiency improvement curve</li> <li><code>optvehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for optimization vehicle</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_objs","title":"get_objs","text":"Python<pre><code>def get_objs(x: dict,\n             write_tsv: bool = False) -&gt; Tuple[np.array, np.array, dict]\n</code></pre> <p>This method gets called when PyMoo calls _evaluate. It initializes objectives and constraints and runs vehicle_scenario_sweep</p> <p>x optimization knobs = [max motor kw, battery kwh, drag coeff % improvement] Function for running FE cycles and accel tests then returning fuel consumption and zero-to-sixty times.</p> <p>x is a set of genes (or parameters), so kwh size is a gene chromosome is a full gene, all values in x</p> <p>Arguments:</p> <ul> <li><code>x</code> dict - Dictionary containing optimization knobs - {max motor kw, battery kwh, drag coeff % improvement}</li> <li><code>write_tsv</code> bool, optional - if True, save intermediate dataframes. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>obj_arr_F</code> np.array - Array of objectives - tot_cost and phev_cd_fuel_used_kwh</li> <li><code>constraint_results_G</code> np.array - Array of constraints</li> <li><code>rs_sweep</code> dict - Output dictionary from vehicle_scenario_sweep</li> </ul> <p></p>"},{"location":"functions/CodeReference/#adjust_fc_peak_eff","title":"adjust_fc_peak_eff","text":"Python<pre><code>def adjust_fc_peak_eff(fc_peak_eff: float, scenario: run_scenario.Scenario,\n                       optvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This method augments an advanced vehicle fc_eff_array based on new fc_peak_eff using baseline fc_eff_array</p> <p>Arguments:</p> <ul> <li><code>fc_peak_eff</code> float - Fuel converter peak efficiency override</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>optvehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of optimization vehicle</li> </ul> <p></p>"},{"location":"functions/CodeReference/#sweep_knob","title":"sweep_knob","text":"Python<pre><code>def sweep_knob(knob: list,\n               definition: int = 100,\n               plot: bool = False,\n               optres: float = None,\n               **kwargs) -&gt; list\n</code></pre> <p>This method sweeps the optimization knob of vehicle from lbound to ubound, return TCO             plot optres to see if there's agreement from opt solution and your sweep</p> <p>Arguments:</p> <ul> <li><code>knob</code> list - list of knobs names for optimization</li> <li><code>definition</code> int, optional - Number of points. Defaults to 100.</li> <li><code>plot</code> bool, optional - if True, saves plot of bounds and TCOs. Defaults to False.</li> <li><code>optres</code> float, optional - Optimization resolution. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>tcos</code> list - List of TCOs of length=definition</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_tco_from_moo_advanced_result","title":"get_tco_from_moo_advanced_result","text":"Python<pre><code>def get_tco_from_moo_advanced_result(x: dict) -&gt; dict\n</code></pre> <p>This method is a utility function to get detailed TCO information from optimized MOO result</p> <p>Arguments:</p> <ul> <li><code>x</code> dict - Dictionary containing optimization knobs - [max motor kw, battery kwh, drag coeff % improvement]</li> </ul> <p>Returns:</p> <ul> <li><code>out</code> dict - Dictionary containing TCO results for optimization runs</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3codisplay-objects","title":"T3CODisplay Objects","text":"Python<pre><code>class T3CODisplay(Output)\n</code></pre> <p>This class contains the display object for Pymoo optimization printouts - pymoo.util.display.Display</p> <p>Arguments:</p> <ul> <li><code>Output</code> pymoo.util.display.output.Output - Pymoo minimize display object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#__init___3","title":"__init__","text":"Python<pre><code>def __init__(**kwargs) -&gt; None\n</code></pre> <p>This constructor initializes the pymoo.util.display.Display object</p> <p></p>"},{"location":"functions/CodeReference/#run_optimization","title":"run_optimization","text":"Python<pre><code>def run_optimization(\n        pop_size: int,\n        n_max_gen: int,\n        knobs_bounds: dict,\n        vnum: int,\n        x_tol: float,\n        f_tol: float,\n        nth_gen: int,\n        n_last: int,\n        algo: str,\n        obj_list: list = None,\n        config: run_scenario.Config = None,\n        do_input_validation=True,\n        **kwargs) -&gt; Tuple[pymoo.core.result.Result, T3COProblem, bool]\n</code></pre> <p>This method creates and runs T3COProblem minimization</p> <p>Arguments:</p> <ul> <li><code>pop_size</code> int - Population size for optimization</li> <li><code>n_max_gen</code> int - maximum number of generations for optimization</li> <li><code>knobs_bounds</code> dict - Dictionary containing knobs and bounds</li> <li><code>vnum</code> int - vehicle selection number</li> <li><code>x_tol</code> float - tolerance in parameter space</li> <li><code>f_tol</code> float - tolerance in objective space</li> <li><code>nth_gen</code> int - number of generations to evaluate if convergence occurs</li> <li><code>n_last</code> int - number of generations to look back for termination</li> <li><code>algo</code> str - algorithm name</li> <li><code>obj_list</code> list, optional - list of objectives - TCO or PHEV_MINIMIZE_FUEL_USE_OBJECTIVE. Defaults to None.</li> <li><code>config</code> run_scenario.Config, optional - T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>res</code> pymoo.core.result.Result - Pymoo optimization result object</li> <li><code>problem</code> moo.T3COProblem - T3COProblem ElementwiseProblem object</li> <li><code>OPTIMIZATION_SUCCEEDED</code> bool - if True, pymoo.minimize succeeded</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3coobjectivesaccel","title":"t3co.objectives.accel","text":"<p>Module for simulating acceleration performance.</p> <p></p>"},{"location":"functions/CodeReference/#get_accel","title":"get_accel","text":"Python<pre><code>def get_accel(\n        analysis_vehicle: fastsim.vehicle.Vehicle,\n        scenario: run_scenario.Scenario = None,\n        set_weight_to_max_kg: bool = True,\n        verbose=False,\n        ess_init_soc=None) -&gt; Tuple[float, float, fastsim.vehicle.Vehicle]\n</code></pre> <p>This function runs a simdrive for getting 0-to-60 and 0-30 mph time with fully laden weight at GVWR (plus gvwr_credit_kg?)</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario, optional - Scenario object for current selection. Defaults to None.</li> <li><code>set_weight_to_max_kg</code> bool, optional - if True, runs run_scenario.set_test_weight(). Defaults to True.</li> <li><code>verbose</code> bool, optional - if True, prints the process steps. Defaults to False.</li> <li><code>ess_init_soc</code> float, optional - ESS initial SOC override. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>zero_to_sixty</code> float - 0-60 mph acceleration time in sec</li> <li><code>zero_to_thirty</code> float - 0-30 mph acceleration time in sec</li> <li><code>accel_simdrive</code> fastsim.simdrive.SimDrive - FASTSim.simdrive.SimDrive object for running the acceleration drivecycle</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3coobjectivesfueleconomy","title":"t3co.objectives.fueleconomy","text":"<p>Module containing functions for calculating fuel economy objectives.</p> <p></p>"},{"location":"functions/CodeReference/#get_range_mi","title":"get_range_mi","text":"Python<pre><code>def get_range_mi(mpgge_info: dict, vehicle: fastsim.vehicle.Vehicle,\n                 scenario: run_scenario.Scenario) -&gt; dict\n</code></pre> <p>This funcion computes range [miles] from mpgge using vehicle powertrain type and energy (or fuel) store size.</p> <p>Considerations: - at some point each vehicle powertrain type could employ the concept of a \"first fuel\" or \"primary fuel\" - so return a primary fuel-based range for all powertrains. - PHEVs have two fuels (generally diesel and electricity). So return two ranges: -- One for determining range during optimization i.e. the CD range that PHEVs are commonly specified with (e.g. PHEV-50 = PHEV with 50 mi AER \"All-Electric Range\" ~= CD range) -- One that represents the \"true\" total PHEV range (CD + CS using both ESS and FS)</p> <p>Arguments:</p> <ul> <li><code>mpgge_info</code> dict - Dictionary containing MPGGE breakdown</li> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>range_dict</code> dict - Dictionary containing different range results</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_sim_drive","title":"get_sim_drive","text":"Python<pre><code>def get_sim_drive(erc, v, scenario)\n</code></pre> <p>This helper method returns a FASTSim SimDrive object using the vehicle, drive cycle and scenario</p> <p>Arguments:</p> <ul> <li><code>erc</code> fastsim.cycle.Cycle| List[Tuple[fastsim.cycle.Cycle, float - FASTSim range cycle object or list of tuples of cycles</li> <li><code>v</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> </ul> <p>Returns:</p> <ul> <li><code>sim_drive</code> fastsim.simdrive.SimDrive - FASTSim SimDrive object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_mpgge","title":"get_mpgge","text":"Python<pre><code>def get_mpgge(\n    eff_range_cyc: fastsim.cycle.Cycle\n    | List[Tuple[fastsim.cycle.Cycle, float]],\n    v: fastsim.vehicle.Vehicle,\n    scenario,\n    diagnostic=False\n) -&gt; Tuple[dict, List[fastsim.simdrive.SimDrive], List[dict]]\n</code></pre> <p>This helper method gets the composite mpgge fuel efficiency of vehicle for each efficiency_range Drive Cycle and weight. It runs the vehicle using efficiency range cycle(s) and returns mpgge based on the powertrain type</p> <p>Method computes a composite mpgge from multiple drive cycles and weights for each cycle. If the user passes in a single Drive Cycle rather than a list of tuples, the base case of a composite mpgge from a single Drive Cycle and a single weight, 1, is computed.</p> <p>Also updates the vehicle's corresponding scenario object</p> <p>Arguments:</p> <ul> <li><code>eff_range_cyc</code> fastsim.cycle.Cycle | List[Tuple[fastsim.cycle.Cycle, float]] - efficiency range cycle</li> <li><code>v</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> <li><code>diagnostic</code> bool, optional - if True, returns all mpgge dicts. Defaults to False.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - unknown vehicle powertrain type</li> </ul> <p>Returns:</p> <ul> <li><code>mpgge_comp</code> dict - Dictionary containing MPGGE breakdowns</li> <li><code>sim_drives</code> List[fastsim.simdrive.SimDrive] - List of simdrives for charge depleting and charge sustaining cycles</li> <li><code>mpgges</code> List[dict], optional - if diagnostic==True, returns additional</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3coobjectivesgradeability","title":"t3co.objectives.gradeability","text":""},{"location":"functions/CodeReference/#get_gradeability","title":"get_gradeability","text":"Python<pre><code>def get_gradeability(\n    analysis_vehicle: fastsim.vehicle.Vehicle,\n    scenario: run_scenario.Scenario = None,\n    verbose: bool = False,\n    ess_init_soc: float = None,\n    set_weight_to_max_kg: bool = True\n) -&gt; Tuple[float, float, fastsim.simdrive.SimDrive, fastsim.simdrive.SimDrive]\n</code></pre> <p>This function runs SimDrives to determine the gradeability at given speed and the grade vehicle is evaluated at how much it meets or exceeds target speed at the target grade.</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario, optional - Scenario object for current selection. Defaults to None.</li> <li><code>verbose</code> bool, optional - if True, prints process steps. Defaults to False.</li> <li><code>ess_init_soc</code> float, optional - ESS Initial SOC override. Defaults to None.</li> <li><code>set_weight_to_max_kg</code> bool, optional - if True, run_scenario.set_test_weight() overrides vehice weight to GVWR. Defaults to True.</li> </ul> <p>Returns:</p> <ul> <li><code>grade_6percent_mph_ach</code> float - Achieved speed on 6% grade test</li> <li><code>grade_1pt25percent_mph_ach</code> float - Achieved speed on 1.25% grade test</li> <li><code>grade_6_simdrive</code> fastsim.simdrive.SimDrive - FASTSim SimDrive for gradeability test of 6% grade</li> <li><code>grade_1p25_simdrive</code> fastsim.simdrive.SimDrive - FASTSim SimDrive for gradeability test of 1.25% grade</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3coobjectives","title":"t3co.objectives","text":"<p>Sub-package contaning modules that calculate optimization objectives.</p> <p></p>"},{"location":"functions/CodeReference/#t3coutilitiesdemo_inputs_installer","title":"t3co.utilities.demo_inputs_installer","text":""},{"location":"functions/CodeReference/#main_1","title":"main","text":"Python<pre><code>def main()\n</code></pre> <p>This function requests user inputs for whether and where to copy T3CO demo input files from the t3co.resources folder. It then calls the copy_demo_input_files function.</p> <p></p>"},{"location":"functions/CodeReference/#copy_demo_input_files","title":"copy_demo_input_files","text":"Python<pre><code>def copy_demo_input_files(destination_path: str)\n</code></pre> <p>This function copies the t3co.resources folder that includes demo input files to a user input destination_path.</p> <p>Arguments:</p> <ul> <li><code>destination_path</code> str | Path - Path of destination directory for copying t3co.resources folder</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3cosweep","title":"t3co.sweep","text":""},{"location":"functions/CodeReference/#deug_traces","title":"deug_traces","text":"Python<pre><code>def deug_traces(vehicle: fastsim.vehicle.Vehicle,\n                cycles: List[fastsim.cycle.Cycle],\n                scenario: run_scenario.Scenario) -&gt; None\n</code></pre> <p>This function gets a diagnostic trace of get_mpgge</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim Vehicle object</li> <li><code>cycles</code> List[fastsim.cycle.Cycle] - List of FASTSim drivecycle objects</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#save_tco_files","title":"save_tco_files","text":"Python<pre><code>def save_tco_files(tco_files: dict, resdir: str, scenario_name: str, sel: str,\n                   ts: str) -&gt; None\n</code></pre> <p>This function saves the intermediary files as tsv</p> <p>Arguments:</p> <ul> <li><code>tco_files</code> dict - Contains all TCO calculation dataframes</li> <li><code>resdir</code> str - result directory strong</li> <li><code>scenario_name</code> str - scenario name</li> <li><code>sel</code> str - selection(s)</li> <li><code>ts</code> str - timestring</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_knobs_bounds_curves","title":"get_knobs_bounds_curves","text":"Python<pre><code>def get_knobs_bounds_curves(selection: int, vpttype: str, sdf: pd.DataFrame,\n                            lw_imp_curves: pd.DataFrame,\n                            aero_drag_imp_curves: pd.DataFrame,\n                            eng_eff_curves: pd.DataFrame) -&gt; Tuple[dict, dict]\n</code></pre> <p>This function fetches the knobs and constraints for running the optimization for a given selection</p> <p>Arguments:</p> <ul> <li><code>selection</code> int - selection number</li> <li><code>vpttype</code> str - vehicle powertrain type = veh_pt_type</li> <li><code>sdf</code> pd.DataFrame - scenario dataframe</li> <li><code>lw_imp_curves</code> pd.DataFrame - light weighting curve dataframe</li> <li><code>aero_drag_imp_curves</code> pd.DataFrame - aero drag curve dataframe</li> <li><code>eng_eff_curves</code> pd.DataFrame - engine efficiency curve dataframe</li> </ul> <p>Returns:</p> <ul> <li><code>knobs_bounds</code> dict - dict of knobs and bounds</li> <li><code>curves</code> dict - dict of lw, aero, and engine efficiency curve parameters</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_objectives_constraints","title":"get_objectives_constraints","text":"Python<pre><code>def get_objectives_constraints(selection: int,\n                               sdf: pd.DataFrame,\n                               verbose: bool = True) -&gt; Tuple[list, list]\n</code></pre> <p>This function appends to list of necessary variables based on the constraints and objectives selected</p> <p>Arguments:</p> <ul> <li><code>selection</code> int - selection number</li> <li><code>sdf</code> DataFrame - scenario dataframe</li> <li><code>verbose</code> bool, optional - if selected, function will print objectives and constraints. Defaults to True.</li> </ul> <p>Returns:</p> <ul> <li><code>objectives</code> list - list of selected objective variables</li> <li><code>constraints</code> list - list of selected constraint variables</li> </ul> <p></p>"},{"location":"functions/CodeReference/#run_moo","title":"run_moo","text":"Python<pre><code>def run_moo(\n        sel: int, sdf: pd.DataFrame, optpt: str, algo: str, skip_opt: bool,\n        pop_size: float, n_max_gen: int, n_last: int, nth_gen: int,\n        x_tol: float, verbose: bool, f_tol: float, resdir: str,\n        lw_imp_curves_df: pd.DataFrame, aero_drag_imp_curves_df: pd.DataFrame,\n        eng_eff_imp_curves_df: pd.DataFrame, config: run_scenario.Scenario,\n        **kwargs) -&gt; Tuple[pymoo.core.result.Result, moo.T3COProblem, bool]\n</code></pre> <p>This function calls get_objectives_constraints and get_knobs_bounds_curves, and then calls run_optimization to perform the multiobjective optimization</p> <p>Arguments:</p> <ul> <li><code>sel</code> int - selection number</li> <li><code>sdf</code> DataFrame - Scenario dataframe</li> <li><code>optpt</code> str - FASTSim vehicle powertrain type</li> <li><code>algo</code> str - algorithm name</li> <li><code>skip_opt</code> bool - skip optimization boolean</li> <li><code>pop_size</code> int - population size for optimization</li> <li><code>n_max_gen</code> int - maximum number of generations for optimization</li> <li><code>n_last</code> int - number of generations to look back for termination</li> <li><code>nth_gen</code> int - number of generations to evaluate if convergence occurs</li> <li><code>x_tol</code> float - tolerance in parameter space</li> <li><code>verbose</code> book - if selected, function prints the optimization process</li> <li><code>f_tol</code> float - tolerance in objective space</li> <li><code>resdir</code> str - results directory</li> <li><code>lw_imp_curves_df</code> DataFrame - light weighting curves dataframe</li> <li><code>aero_drag_imp_curves_df</code> DataFrame - aero drag curves dataframe</li> <li><code>eng_eff_imp_curves_df</code> DataFrame - engine efficiency curve dataframe</li> <li><code>config</code> Config - Config class object</li> </ul> <p>Returns:</p> <ul> <li><code>moo_results</code> pymoo.core.result.Result - optimization results object</li> <li><code>moo_problem</code> T3COProblem - minimization problem that calculates TCO</li> <li><code>moo_code</code> bool - Error message</li> </ul> <p></p>"},{"location":"functions/CodeReference/#check_input_files","title":"check_input_files","text":"Python<pre><code>def check_input_files(df: pd.DataFrame, filetype: str, filepath: str) -&gt; None\n</code></pre> <p>This function contains assert statements that make sure input vehicle and scenario dataframes do not contain numm rows</p> <p>Arguments:</p> <ul> <li><code>df</code> DataFrame - vehicle or scenario dataframe</li> <li><code>filetype</code> str - 'vehicle' or 'scenario'</li> <li><code>filepath</code> str - filepath of the vehicle or scenario input files</li> </ul> <p></p>"},{"location":"functions/CodeReference/#skip_scenario","title":"skip_scenario","text":"Python<pre><code>def skip_scenario(sel,\n                  selections,\n                  scenario_name,\n                  report_kwargs,\n                  verbose=False) -&gt; bool\n</code></pre> <p>This function checks if given selection is present in exclude or look_for selections</p> <p>Arguments:</p> <ul> <li><code>sel</code> float - description</li> <li><code>scenario_name</code> str - scenario name</li> <li><code>verbose</code> bool, optional - if selected, prints out scenarios that are skipped. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - if not present, returns True; Else False</li> </ul> <p></p>"},{"location":"functions/CodeReference/#optimize","title":"optimize","text":"Python<pre><code>def optimize(sel: float,\n             sdf: pd.DataFrame,\n             vdf: pd.DataFrame,\n             algo: str,\n             report_kwargs: dict,\n             REPORT_COLS: dict,\n             skip_opt: bool,\n             config: run_scenario.Config,\n             write_tsv: bool = False) -&gt; dict\n</code></pre> <p>This function runs the optimization for a given selection if skip_opt = False</p> <p>Arguments:</p> <ul> <li><code>sel</code> float - Selection number</li> <li><code>sdf</code> pd.DataFrame - Dataframe of input scenario file</li> <li><code>vdf</code> pd.DataFrame - Dataframe of input vehicle file</li> <li><code>algo</code> str - Multiobjective optimization Algorithm name</li> <li><code>report_kwargs</code> dict - arguments related to running T3CO</li> <li><code>REPORT_COLS</code> dict - Results columns dictionary for sorting the T3CO results</li> <li><code>skip_opt</code> bool - skip optimization. If true, then optimizer is not run.</li> <li><code>config</code> run_scenario.Config - Config object</li> <li><code>write_tsv</code> bool, optional - if selected, intermediary dataframes are saved as tsv files.. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>report_i</code> dict - Dictionary of T3CO results for given selection</li> </ul> <p></p>"},{"location":"functions/CodeReference/#run_vehicle_scenarios","title":"run_vehicle_scenarios","text":"Python<pre><code>def run_vehicle_scenarios(\n    config: run_scenario.Config, REPORT_COLS: dict, **kwargs\n) -&gt; Tuple[List[int | str], pd.DataFrame, pd.DataFrame, bool, dict, dict]\n</code></pre> <p>This function reads the input files, validates inputs, compiles the selections, and returns a clean set of inputs that are needed for the current analysis.</p> <p>Arguments:</p> <ul> <li><code>config</code> Config - Config object containing analysis attributes and scenario attribute overrides</li> <li><code>REPORT_COLS</code> dict - Dictionary of reporting columns from T3CO</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code> - input validation error</li> <li><code>Exception</code> - optimization error</li> </ul> <p>Returns:</p> <p>selections, vdf, sdf, skip_all_opt, report_kwargs, REPORT_COLS (Tuple[List[int|str], pd.DataFrame, pd.DataFrame, bool, dict, dict]): Selections list, vehicle dataframe, scenario dataframe, skip all optimization, report arguments, and report columns</p> <p></p>"},{"location":"functions/CodeReference/#run_optimize_analysis","title":"run_optimize_analysis","text":"Python<pre><code>def run_optimize_analysis(sel: str | int, vdf: pd.DataFrame, sdf: pd.DataFrame,\n                          skip_all_opt: bool, config: run_scenario.Config,\n                          report_kwargs: dict, REPORT_COLS: dict) -&gt; dict\n</code></pre> <p>This function runs the optimization function based on skip_all_opt input to return the report_i dictionary with T3CO results for each selection.</p> <p>Arguments:</p> <ul> <li><code>sel</code> str | int - selection number</li> <li><code>vdf</code> pd.DataFrame - Dataframe of input vehicle file</li> <li><code>sdf</code> pd.DataFrame - Dataframe of input scenario file</li> <li><code>skip_all_opt</code> bool - Skip all optimization. If true, then the optimizer is not run for any scenario</li> <li><code>config</code> run_scenario.Config - Config object</li> <li><code>report_kwargs</code> dict - Dictionary of args required for running T3CO</li> <li><code>REPORT_COLS</code> dict - Dictionary of reporting columns from T3CO</li> </ul> <p>Returns:</p> <ul> <li><code>report_i</code> dict - Dictionary of T3CO results for given selection</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3corunglobal","title":"t3co.run.Global","text":"<p>Global constants Stores paths to directories used for input files, as well as constants referenced throughout the code base</p> <p></p>"},{"location":"functions/CodeReference/#dieselgalpergasgal","title":"DieselGalPerGasGal","text":"<p>energy equivalent gallons of diesel per 1 gallon gas</p> <p></p>"},{"location":"functions/CodeReference/#kgh2_per_gge","title":"kgH2_per_gge","text":"<p>https://epact.energy.gov/fuel-conversion-factors for Hydrogen</p> <p></p>"},{"location":"functions/CodeReference/#mps_to_mph","title":"mps_to_mph","text":"<p>1 mps = 2.23694 mph</p> <p></p>"},{"location":"functions/CodeReference/#m_to_mi","title":"m_to_mi","text":"<p>1 m = 0.000621371 mi</p> <p></p>"},{"location":"functions/CodeReference/#get_kwh_per_gge","title":"get_kwh_per_gge","text":"Python<pre><code>def get_kwh_per_gge()\n</code></pre> <p>This is a getter for kwh_per_gge, sim and scenario dependant var that can change important to get from one location each time so we can track when and how it's used</p> <p>Returns:</p> <ul> <li><code>kwh_per_gge</code> float - kWh per Gasoline Gallon Equivalent</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_tco_intermediates","title":"set_tco_intermediates","text":"Python<pre><code>def set_tco_intermediates()\n</code></pre> <p>This function sets path for TCO_INTERMEDIATES to save tsv files</p> <p></p>"},{"location":"functions/CodeReference/#set_tco_results","title":"set_tco_results","text":"Python<pre><code>def set_tco_results()\n</code></pre> <p>This function sets path for TCO_RESULTS</p> <p></p>"},{"location":"functions/CodeReference/#kg_to_lbs","title":"kg_to_lbs","text":"Python<pre><code>def kg_to_lbs(kgs: float) -&gt; float\n</code></pre> <p>This function converts kg to lb</p> <p>Arguments:</p> <ul> <li><code>kgs</code> float - mass in kg</li> </ul> <p>Returns:</p> <ul> <li><code>(float)</code> - mass in pounds</li> </ul> <p></p>"},{"location":"functions/CodeReference/#lbs_to_kgs","title":"lbs_to_kgs","text":"Python<pre><code>def lbs_to_kgs(lbs: float) -&gt; float\n</code></pre> <p>This function converts lb to kg</p> <p>Arguments:</p> <ul> <li><code>lbs</code> float - mass in pounds</li> </ul> <p>Returns:</p> <ul> <li><code>(float)</code> - mass in kg</li> </ul> <p></p>"},{"location":"functions/CodeReference/#not_falsy","title":"not_falsy","text":"Python<pre><code>def not_falsy(var: float) -&gt; bool\n</code></pre> <p>This function returns True to verify that var is NOT falsy: not in [None, np.nan, 0, False]</p> <p>Arguments:</p> <ul> <li><code>var</code> float - variable to check</li> </ul> <p>Returns:</p> <ul> <li><code>(bool)</code> - True if not in [None, 0, False]</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3corun","title":"t3co.run","text":""},{"location":"functions/CodeReference/#t3corungenerateinputs","title":"t3co.run.generateinputs","text":""},{"location":"functions/CodeReference/#generate","title":"generate","text":"Python<pre><code>def generate(vocation: str, dst: str = gl.OPTIMIZATION_AND_TCO_RCRS)\n</code></pre> <p>This function aggregates specifications from users for powertrains, desired ranges, component costs etc. into two csv files - FASTSimInputs and OtherInputs</p> <p>Arguments:</p> <ul> <li><code>vocation</code> str - Vocation type description</li> <li><code>dst</code> str, optional - results directory file path. Defaults to gl.OPTIMIZATION_AND_TCO_RCRS.</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3corunrun_scenario","title":"t3co.run.run_scenario","text":"<p>Module for loading vehicles, scenarios, running them and managing them</p> <p></p>"},{"location":"functions/CodeReference/#config-objects","title":"Config Objects","text":"Python<pre><code>@dataclass\nclass Config()\n</code></pre> <p>This class reads T3COConfig.csv file containing analysis attributes like vehicle and scenario paths, TCO_method, and scenario attribute overrides.</p> <p></p>"},{"location":"functions/CodeReference/#from_file_1","title":"from_file","text":"Python<pre><code>def from_file(filename: str, analysis_id: int) -&gt; Self\n</code></pre> <p>This method generates a Config dictionary from CSV file and calls Config.from_dict</p> <p>Arguments:</p> <ul> <li><code>filename</code> str - path of input T3CO Config file</li> <li><code>analysis_id</code> int - analysis ID selections</li> </ul> <p>Returns:</p> <ul> <li><code>Self.from_dict</code> - method that gets Config instance from config_dict</li> </ul> <p></p>"},{"location":"functions/CodeReference/#from_dict","title":"from_dict","text":"Python<pre><code>def from_dict(config_dict: dict) -&gt; Self\n</code></pre> <p>This method generates a Config instance from config_dict</p> <p>Arguments:</p> <ul> <li><code>config_dict</code> dict - dictionary containing fields from T3CO Config input CSV file</li> </ul> <p>Returns:</p> <ul> <li><code>Self</code> - Config instance containining all values from T3CO Config CSV file</li> </ul> <p></p>"},{"location":"functions/CodeReference/#validate_analysis_id","title":"validate_analysis_id","text":"Python<pre><code>def validate_analysis_id(filename: str, analysis_id: int = 0) -&gt; Self\n</code></pre> <p>This method validates that correct analysis id is input</p> <p>Arguments:</p> <ul> <li><code>filename</code> str - T3CO Config input CSV file path</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code> - Error if analysis_id not found</li> </ul> <p></p>"},{"location":"functions/CodeReference/#check_drivecycles_and_create_selections","title":"check_drivecycles_and_create_selections","text":"Python<pre><code>def check_drivecycles_and_create_selections(config_file: str | Path)\n</code></pre> <p>This method checks if the config.drive_cycle input is a file or a folder. If a folder is provided, then it creates a list of all selections for each drivecycle in the folders as config.dc_files</p> <p>Arguments:</p> <ul> <li><code>config_file</code> str|Path - File path of config file</li> </ul> <p></p>"},{"location":"functions/CodeReference/#scenario-objects","title":"Scenario Objects","text":"Python<pre><code>@dataclass\nclass Scenario()\n</code></pre> <p>Class object that contains all TCO parameters and performance target (range, grade, accel) information         for a vehicle such that performance and TCO can be computed during optimization</p> <p></p>"},{"location":"functions/CodeReference/#originalcargo_kg","title":"originalcargo_kg","text":"<p>if needed, should be assigned immediately after vehicle read in</p> <p></p>"},{"location":"functions/CodeReference/#plf_scenario_vehicle_cargo_capacity_kg","title":"plf_scenario_vehicle_cargo_capacity_kg","text":"<p>includes cargo credit kg</p> <p></p>"},{"location":"functions/CodeReference/#from_config","title":"from_config","text":"Python<pre><code>def from_config(config: Config = None, verbose: bool = False) -&gt; None\n</code></pre> <p>This method overrides certain scenario fields if use_config is True and config object is not None</p> <p>Arguments:</p> <ul> <li><code>config</code> Config, optional - Config object. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/CodeReference/#check_phev_init_socs","title":"check_phev_init_socs","text":"Python<pre><code>def check_phev_init_socs(a_vehicle: vehicle.Vehicle,\n                         scenario: Scenario) -&gt; None\n</code></pre> <p>This function checks that soc_norm_init_for_grade_pct and soc_norm_init_for_accel_pct are present only for PHEVs</p> <p>Arguments:</p> <ul> <li><code>a_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>scenario</code> Scenario - T3CO scenario object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_phev_util_factor","title":"get_phev_util_factor","text":"Python<pre><code>def get_phev_util_factor(scenario: Scenario, v: fastsim.vehicle.Vehicle,\n                         mpgge: dict) -&gt; float\n</code></pre> <p>This function gets the PHEV utility factor derived from the computed range of the vehicle and the operational day range computed from shifts per year and the first vmt year</p> <p>Arguments:</p> <ul> <li><code>scenario</code> Scenario - T3CO scenario object</li> <li><code>v</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>mpgge</code> dict - Miles per Gallon Gasoline Equivalent dictionary</li> </ul> <p>Returns:</p> <ul> <li><code>uf</code> float - PHEV computed utility factor</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_objective_simdrive","title":"get_objective_simdrive","text":"Python<pre><code>def get_objective_simdrive(\n        analysis_vehicle: vehicle.Vehicle,\n        cycle: fastsim.cycle.Cycle) -&gt; fastsim.simdrive.SimDrive\n</code></pre> <p>This function obtains the SimDrive for accel and grade test</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>cycle</code> fastsim.cycle.Cycle - FASTSim Cycle object</li> </ul> <p>Returns:</p> <ul> <li><code>sd</code> fastsim.simdrive.SimDrive - FASTSim SimDrive object containing vehicle inputs and simulation output attributes</li> </ul> <p></p>"},{"location":"functions/CodeReference/#run_grade_or_accel","title":"run_grade_or_accel","text":"Python<pre><code>def run_grade_or_accel(test: str, analysis_vehicle: fastsim.vehicle.Vehicle,\n                       sim_drive: fastsim.simdrive.SimDrive,\n                       ess_init_soc: float) -&gt; None\n</code></pre> <p>This function handles initial SOC considerations for grade and accel tests</p> <p>If ess_init_soc override is passed, use that Else if the vehicle is an HEV, use the standard HEV init SOC values for accel and grade Else, let FASTSim determine init SOC in sim_drive() BEVs use max_soc PHEVs use max_soc Conv init_soc doesn't matter HEVs attempt SOC balancing but that is overrident by HEV test init SOC</p> <p>Arguments:</p> <ul> <li><code>test</code> str - 'accel' or 'grade' test</li> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>sim_drive</code> fastsim.simdrive.SimDrive - FASTSim SimDrive object</li> <li><code>ess_init_soc</code> float - ESS initial state of charge (SOC)</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code> - if test not in ['accel', 'grade']</li> </ul> <p></p>"},{"location":"functions/CodeReference/#create_fastsim_vehicle","title":"create_fastsim_vehicle","text":"Python<pre><code>def create_fastsim_vehicle(veh_dict: dict = None) -&gt; fastsim.vehicle.Vehicle\n</code></pre> <p>This function creates and returns an empty FASTSim vehicle object with no attributes or</p> <p>Arguments:</p> <ul> <li><code>veh_dict</code> dict, optional - Vehicle attributes dict. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>v</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_vehicle","title":"get_vehicle","text":"Python<pre><code>def get_vehicle(veh_no: int, veh_input_path: str) -&gt; fastsim.vehicle.Vehicle\n</code></pre> <p>This function loads vehicle object from vehicle number and input csv filepath</p> <p>Arguments:</p> <ul> <li><code>veh_no</code> int - vehicle selection number</li> <li><code>veh_input_path</code> str - vehicle model assumptions input CSV file path</li> </ul> <p>Returns:</p> <ul> <li><code>veh</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#get_scenario_and_cycle","title":"get_scenario_and_cycle","text":"Python<pre><code>def get_scenario_and_cycle(\n        veh_no: int,\n        scenario_inputs_path: str,\n        a_vehicle: fastsim.vehicle.Vehicle = None,\n        config: Config = None,\n        do_input_validation: bool = False\n) -&gt; Tuple[Scenario, fastsim.cycle.Cycle]\n</code></pre> <p>This function uses helper methods load_scenario and load_design_cycle_from_scenario         to get scenario object and cycle object corresponding to selected vehicle (by veh_no)</p> <p>Arguments:</p> <ul> <li><code>veh_no</code> int - vehicle selection number</li> <li><code>scenario_inputs_path</code> str - input file path for scenario assumptions CSV</li> <li><code>a_vehicle</code> fastsim.vehicle.Vehicle, optional - FASTSim vehicle object for given selection. Defaults to None.</li> <li><code>config</code> Config, optional - Config object for current analysis. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>scenario</code> Scenario - T3CO scenario object selected</li> <li><code>cyc</code> fastsim.cycle.Cycle - FASTSim cycle object selected</li> </ul> <p></p>"},{"location":"functions/CodeReference/#load_scenario","title":"load_scenario","text":"Python<pre><code>def load_scenario(veh_no: int,\n                  scenario_inputs_path: str,\n                  a_vehicle: fastsim.vehicle.Vehicle = None,\n                  config: Config = None) -&gt; Scenario\n</code></pre> <p>This function gets the Scenario object from scenario input CSV filepath, initializes some fields,          and overrides some fields based on Config object</p> <p>Arguments:</p> <ul> <li><code>veh_no</code> int - vehicle selection number</li> <li><code>scenario_inputs_path</code> str - input file path for scenario assumptions CSV</li> <li><code>a_vehicle</code> fastsim.vehicle.Vehicle, optional - FASTSim vehicle object for given selection. Defaults to None.</li> <li><code>config</code> Config, optional - Config object for current analysis. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>scenario</code> Scenario - Scenario object for given selection</li> </ul> <p></p>"},{"location":"functions/CodeReference/#load_design_cycle_from_scenario","title":"load_design_cycle_from_scenario","text":"Python<pre><code>def load_design_cycle_from_scenario(\n        scenario: Scenario,\n        config: Config = None,\n        cyc_file_path: str = gl.OPTIMIZATION_DRIVE_CYCLES,\n        do_input_validation: bool = False) -&gt; fastsim.cycle.Cycle\n</code></pre> <p>This helper method loads the design cycle used for mpgge and range determination. It can also be used standalone to get cycles not in standard gl.OPTIMIZATION_DRIVE_CYCLES location, but still needs cycle name from scenario object, carried in scenario.drive_cycle. If the drive cycles are a list of tuples, handle accordingly with eval.</p> <p>Arguments:</p> <ul> <li><code>scenario</code> Scenario - Scenario object for current selection</li> <li><code>cyc_file_path</code> str, optional - drivecycle input file path. Defaults to gl.OPTIMIZATION_DRIVE_CYCLES.</li> </ul> <p>Returns:</p> <ul> <li><code>range_cyc</code> fastsim.cycle.Cycle - FASTSim cycle object for current Scenario object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#load_design_cycle_from_path","title":"load_design_cycle_from_path","text":"Python<pre><code>def load_design_cycle_from_path(cyc_file_path: str) -&gt; fastsim.cycle.Cycle\n</code></pre> <p>This helper method loads the Cycle object from the drivecycle filepath</p> <p>Arguments:</p> <ul> <li><code>cyc_file_path</code> str - drivecycle input file path</li> </ul> <p>Returns:</p> <ul> <li><code>range_cyc</code> fastsim.cycle.Cycle - FASTSim cycle object for current Scenario object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_test_weight","title":"set_test_weight","text":"Python<pre><code>def set_test_weight(vehicle: fastsim.vehicle.Vehicle,\n                    scenario: Scenario) -&gt; None\n</code></pre> <p>assign standardized vehicle mass for accel and grade test using GVWR and GVWR Credit</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>scenario</code> t3co.run_scenario.Scenario - T3CO scenario object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#reset_vehicle_weight","title":"reset_vehicle_weight","text":"Python<pre><code>def reset_vehicle_weight(vehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This function resets vehicle mass after loaded weight tests are done for accel and grade</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> </ul> <p></p>"},{"location":"functions/CodeReference/#limit_cargo_kg_for_moo_hev_bev","title":"limit_cargo_kg_for_moo_hev_bev","text":"Python<pre><code>def limit_cargo_kg_for_moo_hev_bev(\n        opt_scenario: Scenario,\n        mooadvancedvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to assign limited cargo capacity based on GVWR + GVWRCredit and optimization vehicle mass for advanced vehicles</p> <p>Arguments:</p> <ul> <li><code>opt_scenario</code> t3co.run_scenario.Scenario - T3CO scenario object</li> <li><code>mooadvancedvehicle</code> fastsim.vehicle.Vehicle - pymoo optimization vehicle</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_max_motor_kw","title":"set_max_motor_kw","text":"Python<pre><code>def set_max_motor_kw(analysis_vehicle: fastsim.vehicle.Vehicle,\n                     scenario: Scenario, max_motor_kw: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set max_motor_kw to optimization vehicle and set kw_demand_fc_on if PHEV</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>scenario</code> run_scenario.Scenario - T3CO Scenarion object</li> <li><code>max_motor_kw</code> float - max motor power /kW</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_max_battery_kwh","title":"set_max_battery_kwh","text":"Python<pre><code>def set_max_battery_kwh(analysis_vehicle: fastsim.vehicle.Vehicle,\n                        max_ess_kwh: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set max_ess_kwh to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>max_ess_kwh</code> float - max energy storage system energy capacity /kWh</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_max_battery_power_kw","title":"set_max_battery_power_kw","text":"Python<pre><code>def set_max_battery_power_kw(analysis_vehicle: fastsim.vehicle.Vehicle,\n                             max_ess_kw: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set max_ess_kwx to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>max_ess_kw</code> float - max energy storage system power /kW</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_max_fuel_converter_kw","title":"set_max_fuel_converter_kw","text":"Python<pre><code>def set_max_fuel_converter_kw(analysis_vehicle: fastsim.vehicle.Vehicle,\n                              fc_max_out_kw: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set fc_max_out_kw to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>fc_max_out_kw</code> float - max fuel converter power /kW</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_fuel_store_kwh","title":"set_fuel_store_kwh","text":"Python<pre><code>def set_fuel_store_kwh(analysis_vehicle: fastsim.vehicle.Vehicle,\n                       fs_kwh: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set fs_kwh to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>fs_kwh</code> float - fuel storage energy capacity /kWh</li> </ul> <p></p>"},{"location":"functions/CodeReference/#set_cargo_kg","title":"set_cargo_kg","text":"Python<pre><code>def set_cargo_kg(analysis_vehicle: fastsim.vehicle.Vehicle, cargo_kg)\n</code></pre> <p>This helper method is used within T3COProblem to set cargo_kg to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>cargo_kg</code> float - vehicle cargo capacity /kg</li> </ul> <p></p>"},{"location":"functions/CodeReference/#vehicle_scenario_sweep","title":"vehicle_scenario_sweep","text":"Python<pre><code>def vehicle_scenario_sweep(vehicle: fastsim.vehicle.Vehicle,\n                           scenario: Scenario,\n                           range_cyc,\n                           verbose=False,\n                           **kwargs)\n</code></pre> <p>This function contains helper methods such as get_tco_of_vehicle, check_phev_init_socs, get_accel, and get_gradeability    and returns a dictionary of all TCO related outputs</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for current selection</li> <li><code>scenario</code> Scenario - Scenario object for current selection</li> <li><code>range_cyc</code> fastsim.cycle.Cycle - FASTSim cycle object for current scenario</li> <li><code>verbose</code> bool, optional - if selected, prints out the TCO calculation process. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>out</code> dict - output dictionary containing TCO elements</li> </ul> <p></p>"},{"location":"functions/CodeReference/#run","title":"run","text":"Python<pre><code>def run(veh_no: int,\n        vocation: str = \"blank\",\n        vehicle_input_path: str = gl.FASTSIM_INPUTS,\n        scenario_inputs_path: str = gl.OTHER_INPUTS)\n</code></pre> <p>This function runs vehicle_scenario_sweep based on vehicle and scenario objects read from input file paths</p> <p>Arguments:</p> <ul> <li><code>veh_no</code> int - vehicle selection number</li> <li><code>vocation</code> str, optional - vocation description of selected vehicle. Defaults to \"blank\".</li> <li><code>vehicle_input_path</code> str, optional - input file path for vehicle assumptions CSV. Defaults to gl.FASTSIM_INPUTS.</li> <li><code>scenario_inputs_path</code> str, optional - input file path for scenario assumptions CSV. Defaults to gl.OTHER_INPUTS.</li> </ul> <p>Returns:</p> <ul> <li><code>out</code> dict - output dictionary containing TCO results</li> </ul> <p></p>"},{"location":"functions/CodeReference/#rerun","title":"rerun","text":"Python<pre><code>def rerun(vehicle: fastsim.vehicle.Vehicle, vocation: str, scenario: Scenario,\n          config: Config)\n</code></pre> <p>This function runs vehicle_scenario_sweep when given the vehicle and scenario objects</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>vocation</code> str - vocation description</li> <li><code>scenario</code> Scenario - Scenario object</li> </ul> <p>Returns:</p> <ul> <li><code>out</code> dict - output dictionary containing TCO outputs</li> </ul> <p></p>"},{"location":"functions/CodeReference/#t3codemosopp_cost_demo","title":"t3co.demos.opp_cost_demo","text":""},{"location":"functions/CodeReference/#t3codemoshev_sweep_and_moo","title":"t3co.demos.hev_sweep_and_moo","text":""},{"location":"functions/CodeReference/#vnum","title":"vnum","text":""},{"location":"functions/CodeReference/#t3codemosexample_load_and_run","title":"t3co.demos.example_load_and_run","text":"<p>To run this as a script that drives all the t3co files as a module: The working directory for this script should be at the same depth as the t3co/ module. Thus the scripts (run_scenario.py, etc.) will have a parent package and you won't get relative import errors. ex: run_one.name will be \"t3co.run_one\"</p> <p>First step, generateinputs.generate(vocation) Create the files necessary such that run_scenario.run() can read information for Vehicle and Scenario object instantiation.</p> <p>tldr: generateinputs(vocation) -&gt; gl.FASTSIM_INPUTS, gl.OTHER_INPUTS -&gt; run_scenario.run(gl.FASTSIM_INPUTS, gl.OTHER_INPUTS)</p> <p>Generate Inputs (GI) first retrieves specific user generated information necessary to create two final product files used for TCO and optimization: gl.FASTSIM_INPUTS &amp; gl.OTHER_INPUTS.</p> <p>(GI) gets the user generated information via the specified vocation and the following files: \"t3co/resources/vehicles/{vocation}/specifications/BaselineVehicle.csv\" \"...OptimizerInitializationValues.csv\" \"...PowertrainTechTargets.csv\" \"...VocationRequirements.csv\"</p> <p>Note: the folder {vocation} must exist and be populated by the user beforehand.</p> <p>gl.FASTSIM_INPUTS &amp; gl.OTHER_INPUTS are populated and stored in the default global locations that run_scenario.run() uses as default params - implying run() can use other FASTSIM_INPUTS &amp; OTHER_INPUTS files if desired.</p> <p>Content of gl.FASTSIM_INPUTS and gl.OTHER_INPUTS:</p> <p>gl.FASTSIM_INPUTS content:</p>"},{"location":"functions/CodeReference/#standard-fastsim-input-file-header-and-rows","title":"standard FASTSim input file header and rows","text":"<p>selection,scenario_name,veh_pt_type,drag_coef,frontalAreaM2,glid... 1.0,\"Conv 2020 tech,  750 mi range\",1.0,0.546,10.18,11776.0,0... 2.0,\"Conv 2025 tech,  750 mi range\",1.0,0.5026666670000001,10... 3.0,\"Conv 2030 tech,  750 mi range\",1.0,0.473125,10.18,11776.... 4.0,\"Conv 2035 tech,  750 mi range\",1.0,0.46,10.18,11776.0,0....</p> <p>gl.OTHER_INPUTS content:</p>"},{"location":"functions/CodeReference/#all-information-necessary-to-determine-vehicle-tco-as-well-as-performance-targets","title":"all information necessary to determine vehicle TCO as well as performance targets","text":"<p>selection,drive_cycle,vmt_reduct_per_yr,vmt,constant_trip_distance_mi,vehicle_life_yr,...,region,target_range_mi,min_speed_at_6pct_grade_in_5min_mph,min_speed_at_1p25pct_grade_in_5min_mph,max0to60secAtGV 1.0,long_haul_cyc.csv,0.0,\"[100000, 100000, 100000, 100000, 100000, 100000...United States,750.0,30.0,65.0,80.0,20.0 2.0,long_haul_cyc.csv,,\"[100000, 100000, 100000, 100000, 100000, 100000, 1...United States,750.0,30.0,65.0,80.0,20.0 3.0,long_haul_cyc.csv,,\"[100000, 100000, 100000, 100000, 100000, 100000, 1...United States,750.0,30.0,65.0,80.0,20.0 4.0,long_haul_cyc.csv,,\"[100000, 100000, 100000, 100000, 100000, 100000, 1...United States,750.0,30.0,65.0,80.0,20.0 5.0,long_haul_cyc.csv,,\"[100000, 100000, 100000, 100000, 100000, 100000, 1...United States,750.0,30.0,65.0,80.0,20.0</p> <p>default values for these files generated by generateinputs(): gl.FASTSIM_INPUTS: ./t3co/resources/\"FASTSimInputs.csv\" gl.OTHER_INPUTS:   ./t3co/resources/\"OtherInputs.csv\"</p> <p>These files are populated in generateinputs.generate() FASTSimInputsDf.to_csv(dst/gl.FASTSIM_INPUTS_FILE, index=False) OtherInputsDf.to_csv(dst/gl.OTHER_INPUTS_FILE, index=False)</p> <p>where gl.FASTSIM_INPUTS_FILE = \"FASTSimInputs.csv\" gl.OTHER_INPUTS = \"OtherInputs.csv\" and dst is usually ./t3co/resources</p> <p>run() usage: run_scenario.run(veh_no, vocation, vehicle_input_path=gl.FASTSIM_INPUTS, scenario_inputs_path=gl.OTHER_INPUTS,</p> <p>print('running', name) generateinputs.generate('Class8_long_haul') use_jit = False start = time.time() res1 = run_scenario.run(1, 'Class8_long_haul', use_jit=use_jit) print(f'classic time [s] {time.time()-start} | use jit? {use_jit}')</p> <p></p>"},{"location":"functions/CodeReference/#t3codemost2co_opt_benchmark","title":"t3co.demos.t2co_opt_benchmark","text":""},{"location":"functions/CodeReference/#t3codemosvisualization_demo","title":"t3co.demos.visualization_demo","text":""},{"location":"functions/CodeReference/#t3codemosspencer","title":"t3co.demos.Spencer","text":""},{"location":"functions/Global/","title":"Table of Contents","text":"<ul> <li>t3co/run/Global</li> <li>DieselGalPerGasGal</li> <li>kgH2_per_gge</li> <li>mps_to_mph</li> <li>m_to_mi</li> <li>get_kwh_per_gge</li> <li>set_tco_intermediates</li> <li>set_tco_results</li> <li>kg_to_lbs</li> <li>lbs_to_kgs</li> <li>not_falsy</li> </ul>"},{"location":"functions/Global/#t3corunglobal","title":"t3co/run/Global","text":"<p>Global constants Stores paths to directories used for input files, as well as constants referenced throughout the code base</p> <p></p>"},{"location":"functions/Global/#dieselgalpergasgal","title":"DieselGalPerGasGal","text":"<p>energy equivalent gallons of diesel per 1 gallon gas</p> <p></p>"},{"location":"functions/Global/#kgh2_per_gge","title":"kgH2_per_gge","text":"<p>https://epact.energy.gov/fuel-conversion-factors for Hydrogen</p> <p></p>"},{"location":"functions/Global/#mps_to_mph","title":"mps_to_mph","text":"<p>1 mps = 2.23694 mph</p> <p></p>"},{"location":"functions/Global/#m_to_mi","title":"m_to_mi","text":"<p>1 m = 0.000621371 mi</p> <p></p>"},{"location":"functions/Global/#get_kwh_per_gge","title":"get_kwh_per_gge","text":"Python<pre><code>def get_kwh_per_gge()\n</code></pre> <p>This is a getter for kwh_per_gge, sim and scenario dependant var that can change important to get from one location each time so we can track when and how it's used</p> <p>Returns:</p> <ul> <li><code>kwh_per_gge</code> float - kWh per Gasoline Gallon Equivalent</li> </ul> <p></p>"},{"location":"functions/Global/#set_tco_intermediates","title":"set_tco_intermediates","text":"Python<pre><code>def set_tco_intermediates()\n</code></pre> <p>This function sets path for TCO_INTERMEDIATES to save tsv files</p> <p></p>"},{"location":"functions/Global/#set_tco_results","title":"set_tco_results","text":"Python<pre><code>def set_tco_results()\n</code></pre> <p>This function sets path for TCO_RESULTS</p> <p></p>"},{"location":"functions/Global/#kg_to_lbs","title":"kg_to_lbs","text":"Python<pre><code>def kg_to_lbs(kgs: float) -&gt; float\n</code></pre> <p>This function converts kg to lb</p> <p>Arguments:</p> <ul> <li><code>kgs</code> float - mass in kg</li> </ul> <p>Returns:</p> <ul> <li><code>(float)</code> - mass in pounds</li> </ul> <p></p>"},{"location":"functions/Global/#lbs_to_kgs","title":"lbs_to_kgs","text":"Python<pre><code>def lbs_to_kgs(lbs: float) -&gt; float\n</code></pre> <p>This function converts lb to kg</p> <p>Arguments:</p> <ul> <li><code>lbs</code> float - mass in pounds</li> </ul> <p>Returns:</p> <ul> <li><code>(float)</code> - mass in kg</li> </ul> <p></p>"},{"location":"functions/Global/#not_falsy","title":"not_falsy","text":"Python<pre><code>def not_falsy(var: float) -&gt; bool\n</code></pre> <p>This function returns True to verify that var is NOT falsy: not in [None, np.nan, 0, False]</p> <p>Arguments:</p> <ul> <li><code>var</code> float - variable to check</li> </ul> <p>Returns:</p> <ul> <li><code>(bool)</code> - True if not in [None, 0, False]</li> </ul>"},{"location":"functions/accel/","title":"Table of Contents","text":"<ul> <li>t3co/objectives/accel</li> <li>get_accel</li> </ul>"},{"location":"functions/accel/#t3coobjectivesaccel","title":"t3co/objectives/accel","text":"<p>Module for simulating acceleration performance.</p> <p></p>"},{"location":"functions/accel/#get_accel","title":"get_accel","text":"Python<pre><code>def get_accel(\n        analysis_vehicle: fastsim.vehicle.Vehicle,\n        scenario: run_scenario.Scenario = None,\n        set_weight_to_max_kg: bool = True,\n        verbose=False,\n        ess_init_soc=None) -&gt; Tuple[float, float, fastsim.vehicle.Vehicle]\n</code></pre> <p>This function runs a simdrive for getting 0-to-60 and 0-30 mph time with fully laden weight at GVWR (plus gvwr_credit_kg?)</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario, optional - Scenario object for current selection. Defaults to None.</li> <li><code>set_weight_to_max_kg</code> bool, optional - if True, runs run_scenario.set_test_weight(). Defaults to True.</li> <li><code>verbose</code> bool, optional - if True, prints the process steps. Defaults to False.</li> <li><code>ess_init_soc</code> float, optional - ESS initial SOC override. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>zero_to_sixty</code> float - 0-60 mph acceleration time in sec</li> <li><code>zero_to_thirty</code> float - 0-30 mph acceleration time in sec</li> <li><code>accel_simdrive</code> fastsim.simdrive.SimDrive - FASTSim.simdrive.SimDrive object for running the acceleration drivecycle</li> </ul>"},{"location":"functions/charts/","title":"Table of Contents","text":"<ul> <li>t3co/visualization/charts</li> <li>T3COCharts<ul> <li>__init__</li> <li>from_file</li> <li>from_df</li> <li>to_df</li> <li>parse_scenario_name</li> <li>generate_tco_plots</li> <li>generate_violin_plot</li> <li>generate_histogram</li> </ul> </li> </ul>"},{"location":"functions/charts/#t3covisualizationcharts","title":"t3co/visualization/charts","text":""},{"location":"functions/charts/#t3cocharts-objects","title":"T3COCharts Objects","text":"Python<pre><code>class T3COCharts()\n</code></pre> <p>This class takes T3CO output CSV file as input and generates different plots to gain insights from T3CO Results</p> <p></p>"},{"location":"functions/charts/#__init__","title":"__init__","text":"Python<pre><code>def __init__(\n    filename: str = None,\n    results_df: pd.DataFrame = None,\n    results_guide: str | Path = Path(__file__).parents[1] / \"resources\" /\n    \"visualization\" / \"t3co_outputs_guide.csv\"\n) -&gt; None\n</code></pre> <p>This constructor initializes the T3COCharts object either from a dataframe or a CSV file path.</p> <p>Arguments:</p> <ul> <li><code>filename</code> str, optional - Filepath to T3CO Results CSV File. Defaults to None.</li> <li><code>results_df</code> pd.DataFrame, optional - Input pandas dataframe containing T3CO Results. Defaults to None.</li> <li><code>results_guide</code> str | Path, optional - File path to t3co_outputs_guide.csv file that contains useful parameter descriptions and axis labels. Defaults to Path(file).parents[1]/\"resources\"/\"visualization\"/\"t3co_outputs_guide.csv\".</li> </ul> <p></p>"},{"location":"functions/charts/#from_file","title":"from_file","text":"Python<pre><code>def from_file(filename: str | Path = None) -&gt; None\n</code></pre> <p>This method reads a T3CO Results CSV file into a dataframe</p> <p>Arguments:</p> <ul> <li><code>filename</code> str | Path, optional - Path to T3CO Results CSV File. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/charts/#from_df","title":"from_df","text":"Python<pre><code>def from_df(results_df: pd.DataFrame) -&gt; None\n</code></pre> <p>This method reads t3co_results from a dataframe</p> <p>Arguments:</p> <ul> <li><code>results_df</code> pd.DataFrame - Input T3CO Results dataframe</li> </ul> <p></p>"},{"location":"functions/charts/#to_df","title":"to_df","text":"Python<pre><code>def to_df() -&gt; pd.DataFrame\n</code></pre> <p>This returns the self.t3co_results member</p> <p>Returns:</p> <ul> <li><code>pd.DataFrame</code> - T3CO Results dataframe</li> </ul> <p></p>"},{"location":"functions/charts/#parse_scenario_name","title":"parse_scenario_name","text":"Python<pre><code>def parse_scenario_name() -&gt; None\n</code></pre> <p>This method parses 'scenario_name' into 'vehicle_type', 'tech_progress', and 'vehicle_fuel_type' and uses 'scenario_gvwr_kg' to create 'vehicle_weight_class'</p> <p></p>"},{"location":"functions/charts/#generate_tco_plots","title":"generate_tco_plots","text":"Python<pre><code>def generate_tco_plots(x_group_col: str,\n                       y_group_col: str,\n                       subplot_group_col: str = \"vehicle_fuel_type\",\n                       fig_x_size: int = 8,\n                       fig_y_size: int = 8,\n                       bar_width: float = 0.8,\n                       legend_pos: float = 0.25,\n                       edgecolor: str = \"none\") -&gt; matplotlib.figure.Figure\n</code></pre> <p>This method generates a TCO Breakdown plot based on input arguments. If x_group_col and/or y_group_col are provided, then a matrix/grid of subplots are generated within the same figure based on row- and column-wise groupings</p> <p>Arguments:</p> <ul> <li><code>x_group_col</code> str - T3CO Results parameter name to group on x-axis, i.e., grouping criteria for columns in subplots grid</li> <li><code>y_group_col</code> str - T3CO Results parameter name to group on y-axis, i.e., grouping criteria for rows in subplots grid</li> <li><code>subplot_group_col</code> str, optional - T3CO Results parameter to display within each subplots cell. Defaults to \"vehicle_fuel_type\".</li> <li><code>fig_x_size</code> int, optional - Figure width relative to each bar on x-axis within subplot. Defaults to 8.</li> <li><code>fig_y_size</code> int, optional - Figure height relative to each subplot cell. Defaults to 8.</li> <li><code>bar_width</code> float, optional - Relative width of bars based on available width. Takes values between 0.0 and 1.0. Defaults to 0.8.</li> <li><code>legend_pos</code> float, optional - Relative position of legend on the right side of plots. Takes values between 0.0 and 1.0. Defaults to 0.25.</li> <li><code>edgecolor</code> str, optional - Edge color to distinguish cost elements in the stacked bars. Defaults to \"none\".</li> </ul> <p>Returns:</p> <ul> <li><code>matplotlib.figure.Figure</code> - TCO Breakdown Figure object</li> </ul> <p></p>"},{"location":"functions/charts/#generate_violin_plot","title":"generate_violin_plot","text":"Python<pre><code>def generate_violin_plot(\n        x_group_col: str,\n        y_group_col: str = \"discounted_tco_dol\") -&gt; matplotlib.figure.Figure\n</code></pre> <p>This method generates a violin plot based on x-axis group column and y-axis column name.</p> <p>Arguments:</p> <ul> <li><code>x_group_col</code> str - T3CO Results parameter to group by on x-axis inside violinplot</li> <li><code>y_group_col</code> str, optional - T3CO Results parameter to plot on y-axis. Defaults to \"discounted_tco_dol\".</li> </ul> <p>Returns:</p> <ul> <li><code>matplotlib.figure.Figure</code> - Violin Plot Figure object</li> </ul> <p></p>"},{"location":"functions/charts/#generate_histogram","title":"generate_histogram","text":"Python<pre><code>def generate_histogram(hist_col: str,\n                       n_bins: int,\n                       show_pct: bool = False) -&gt; matplotlib.figure.Figure\n</code></pre> <p>This method generates a histogram plot based on inputs hist_col and n_bins</p> <p>Arguments:</p> <ul> <li><code>hist_col</code> str - T3CO column name to plot histogram</li> <li><code>n_bins</code> int - Number of bins in histogram</li> <li><code>show_pct</code> bool, optional - If True, plots percentage on y-axis instead of number of items. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>matplotlib.figure.Figure</code> - Histogram figure object</li> </ul>"},{"location":"functions/fueleconomy/","title":"Table of Contents","text":"<ul> <li>t3co/objectives/fueleconomy</li> <li>get_range_mi</li> <li>get_sim_drive</li> <li>get_mpgge</li> </ul>"},{"location":"functions/fueleconomy/#t3coobjectivesfueleconomy","title":"t3co/objectives/fueleconomy","text":"<p>Module containing functions for calculating fuel economy objectives.</p> <p></p>"},{"location":"functions/fueleconomy/#get_range_mi","title":"get_range_mi","text":"Python<pre><code>def get_range_mi(mpgge_info: dict, vehicle: fastsim.vehicle.Vehicle,\n                 scenario: run_scenario.Scenario) -&gt; dict\n</code></pre> <p>This funcion computes range [miles] from mpgge using vehicle powertrain type and energy (or fuel) store size.</p> <p>Considerations: - at some point each vehicle powertrain type could employ the concept of a \"first fuel\" or \"primary fuel\" - so return a primary fuel-based range for all powertrains. - PHEVs have two fuels (generally diesel and electricity). So return two ranges: -- One for determining range during optimization i.e. the CD range that PHEVs are commonly specified with (e.g. PHEV-50 = PHEV with 50 mi AER \"All-Electric Range\" ~= CD range) -- One that represents the \"true\" total PHEV range (CD + CS using both ESS and FS)</p> <p>Arguments:</p> <ul> <li><code>mpgge_info</code> dict - Dictionary containing MPGGE breakdown</li> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>range_dict</code> dict - Dictionary containing different range results</li> </ul> <p></p>"},{"location":"functions/fueleconomy/#get_sim_drive","title":"get_sim_drive","text":"Python<pre><code>def get_sim_drive(erc, v, scenario)\n</code></pre> <p>This helper method returns a FASTSim SimDrive object using the vehicle, drive cycle and scenario</p> <p>Arguments:</p> <ul> <li><code>erc</code> fastsim.cycle.Cycle| List[Tuple[fastsim.cycle.Cycle, float - FASTSim range cycle object or list of tuples of cycles</li> <li><code>v</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> </ul> <p>Returns:</p> <ul> <li><code>sim_drive</code> fastsim.simdrive.SimDrive - FASTSim SimDrive object</li> </ul> <p></p>"},{"location":"functions/fueleconomy/#get_mpgge","title":"get_mpgge","text":"Python<pre><code>def get_mpgge(\n    eff_range_cyc: fastsim.cycle.Cycle\n    | List[Tuple[fastsim.cycle.Cycle, float]],\n    v: fastsim.vehicle.Vehicle,\n    scenario,\n    diagnostic=False\n) -&gt; Tuple[dict, List[fastsim.simdrive.SimDrive], List[dict]]\n</code></pre> <p>This helper method gets the composite mpgge fuel efficiency of vehicle for each efficiency_range Drive Cycle and weight. It runs the vehicle using efficiency range cycle(s) and returns mpgge based on the powertrain type</p> <p>Method computes a composite mpgge from multiple drive cycles and weights for each cycle. If the user passes in a single Drive Cycle rather than a list of tuples, the base case of a composite mpgge from a single Drive Cycle and a single weight, 1, is computed.</p> <p>Also updates the vehicle's corresponding scenario object</p> <p>Arguments:</p> <ul> <li><code>eff_range_cyc</code> fastsim.cycle.Cycle | List[Tuple[fastsim.cycle.Cycle, float]] - efficiency range cycle</li> <li><code>v</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> <li><code>diagnostic</code> bool, optional - if True, returns all mpgge dicts. Defaults to False.</li> </ul> <p>Raises:</p> <ul> <li><code>ValueError</code> - unknown vehicle powertrain type</li> </ul> <p>Returns:</p> <ul> <li><code>mpgge_comp</code> dict - Dictionary containing MPGGE breakdowns</li> <li><code>sim_drives</code> List[fastsim.simdrive.SimDrive] - List of simdrives for charge depleting and charge sustaining cycles</li> <li><code>mpgges</code> List[dict], optional - if diagnostic==True, returns additional</li> </ul>"},{"location":"functions/generateinputs/","title":"Table of Contents","text":"<ul> <li>t3co/run/generateinputs</li> <li>generate</li> </ul>"},{"location":"functions/generateinputs/#t3corungenerateinputs","title":"t3co/run/generateinputs","text":""},{"location":"functions/generateinputs/#generate","title":"generate","text":"Python<pre><code>def generate(vocation: str, dst: str = gl.OPTIMIZATION_AND_TCO_RCRS)\n</code></pre> <p>This function aggregates specifications from users for powertrains, desired ranges, component costs etc. into two csv files - FASTSimInputs and OtherInputs</p> <p>Arguments:</p> <ul> <li><code>vocation</code> str - Vocation type description</li> <li><code>dst</code> str, optional - results directory file path. Defaults to gl.OPTIMIZATION_AND_TCO_RCRS.</li> </ul>"},{"location":"functions/gradeability/","title":"Table of Contents","text":"<ul> <li>t3co/objectives/gradeability</li> <li>get_gradeability</li> </ul>"},{"location":"functions/gradeability/#t3coobjectivesgradeability","title":"t3co/objectives/gradeability","text":""},{"location":"functions/gradeability/#get_gradeability","title":"get_gradeability","text":"Python<pre><code>def get_gradeability(\n    analysis_vehicle: fastsim.vehicle.Vehicle,\n    scenario: run_scenario.Scenario = None,\n    verbose: bool = False,\n    ess_init_soc: float = None,\n    set_weight_to_max_kg: bool = True\n) -&gt; Tuple[float, float, fastsim.simdrive.SimDrive, fastsim.simdrive.SimDrive]\n</code></pre> <p>This function runs SimDrives to determine the gradeability at given speed and the grade vehicle is evaluated at how much it meets or exceeds target speed at the target grade.</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario, optional - Scenario object for current selection. Defaults to None.</li> <li><code>verbose</code> bool, optional - if True, prints process steps. Defaults to False.</li> <li><code>ess_init_soc</code> float, optional - ESS Initial SOC override. Defaults to None.</li> <li><code>set_weight_to_max_kg</code> bool, optional - if True, run_scenario.set_test_weight() overrides vehice weight to GVWR. Defaults to True.</li> </ul> <p>Returns:</p> <ul> <li><code>grade_6percent_mph_ach</code> float - Achieved speed on 6% grade test</li> <li><code>grade_1pt25percent_mph_ach</code> float - Achieved speed on 1.25% grade test</li> <li><code>grade_6_simdrive</code> fastsim.simdrive.SimDrive - FASTSim SimDrive for gradeability test of 6% grade</li> <li><code>grade_1p25_simdrive</code> fastsim.simdrive.SimDrive - FASTSim SimDrive for gradeability test of 1.25% grade</li> </ul>"},{"location":"functions/moo/","title":"Table of Contents","text":"<ul> <li>t3co/moopack/moo</li> <li>T3COProblem<ul> <li>setup_opt_records</li> <li>__init__</li> <li>compile_reporting_vars</li> <li>instantiate_moo_vehicles_and_scenario</li> <li>cda_percent_delta_knob</li> <li>weight_delta_percent_knob</li> <li>fc_peak_eff_knob</li> <li>get_objs</li> <li>adjust_fc_peak_eff</li> <li>sweep_knob</li> <li>get_tco_from_moo_advanced_result</li> </ul> </li> <li>T3CODisplay<ul> <li>__init__</li> </ul> </li> <li>run_optimization</li> </ul>"},{"location":"functions/moo/#t3comoopackmoo","title":"t3co/moopack/moo","text":""},{"location":"functions/moo/#t3coproblem-objects","title":"T3COProblem Objects","text":"Python<pre><code>class T3COProblem(ElementwiseProblem)\n</code></pre> <p>Class for creating PyMoo problem.</p> <p></p>"},{"location":"functions/moo/#setup_opt_records","title":"setup_opt_records","text":"Python<pre><code>def setup_opt_records()\n</code></pre> <p>This method sets up the empty optimization record arrays</p> <p></p>"},{"location":"functions/moo/#__init__","title":"__init__","text":"Python<pre><code>def __init__(knobs_bounds: dict,\n             vnum: float,\n             optimize_pt: str,\n             obj_list: list = None,\n             constr_list: list = None,\n             verbose: bool = False,\n             config: run_scenario.Config = None,\n             do_input_validation: bool = False,\n             **kwargs) -&gt; None\n</code></pre> <p>This constructor initializes optimization input variables</p> <p>Arguments:</p> <ul> <li><code>knobs_bounds</code> dict - Dictionary containing knobs bounds for optimization</li> <li><code>vnum</code> float - Vehicle selection number</li> <li><code>optimize_pt</code> str, optional - Vehicle powertrain type - Conv, BEV, HEV, PHEV. Defaults to gl.BEV.</li> <li><code>obj_list</code> list, optional - List of objectives. Defaults to None.</li> <li><code>constr_list</code> list, optional - List of constraints. Defaults to None.</li> <li><code>verbose</code> bool, optional - if True, prints process steps. Defaults to False.</li> <li><code>config</code> run_scenario.Config, optional - T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/moo/#compile_reporting_vars","title":"compile_reporting_vars","text":"Python<pre><code>def compile_reporting_vars() -&gt; None\n</code></pre> <p>This method creates an output dictionary containing optimization results</p> <p></p>"},{"location":"functions/moo/#instantiate_moo_vehicles_and_scenario","title":"instantiate_moo_vehicles_and_scenario","text":"Python<pre><code>def instantiate_moo_vehicles_and_scenario(\n        vnum: int,\n        config: run_scenario.Config = None,\n        do_input_validation: bool = False) -&gt; None\n</code></pre> <p>This method instantiates the multi-objective optimization problem vehicles and scenarios, starting with the baseline Conventional vehicle.</p> <p>Arguments:</p> <ul> <li><code>vnum</code> int - vehicle selection number</li> <li><code>config</code> run_scenario.Config, optional - T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</li> </ul> <p>Raises:</p> <ul> <li><code>TypeError</code> - Invalid optimize_pt selection</li> </ul> <p></p>"},{"location":"functions/moo/#cda_percent_delta_knob","title":"cda_percent_delta_knob","text":"Python<pre><code>def cda_percent_delta_knob(CdA_perc_reduction: str,\n                           optvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This method sets the drag_coef based on aero improvement curve and glider_kg based on cda_cost_coeff_a and cda_cost_coeff_b</p> <p>Arguments:</p> <ul> <li><code>CdA_perc_reduction</code> str - Name of aero improvement curve file</li> <li><code>optvehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for optimization vehicle</li> </ul> <p></p>"},{"location":"functions/moo/#weight_delta_percent_knob","title":"weight_delta_percent_knob","text":"Python<pre><code>def weight_delta_percent_knob(wt_perc_reduction: float,\n                              optvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This method sets the knob from the lightweighting curve</p> <p>Arguments:</p> <ul> <li><code>wt_perc_reduction</code> float - Weight reduction percentage value from lightweighting curve</li> <li><code>optvehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of the optimization vehicle</li> </ul> <p></p>"},{"location":"functions/moo/#fc_peak_eff_knob","title":"fc_peak_eff_knob","text":"Python<pre><code>def fc_peak_eff_knob(fc_peak_eff: float,\n                     optvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This method sets the knob from the engine efficiency curve</p> <p>Arguments:</p> <ul> <li><code>fc_peak_eff</code> float - Fuel converter peak effiency override from engine efficiency improvement curve</li> <li><code>optvehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for optimization vehicle</li> </ul> <p></p>"},{"location":"functions/moo/#get_objs","title":"get_objs","text":"Python<pre><code>def get_objs(x: dict,\n             write_tsv: bool = False) -&gt; Tuple[np.array, np.array, dict]\n</code></pre> <p>This method gets called when PyMoo calls _evaluate. It initializes objectives and constraints and runs vehicle_scenario_sweep</p> <p>x optimization knobs = [max motor kw, battery kwh, drag coeff % improvement] Function for running FE cycles and accel tests then returning fuel consumption and zero-to-sixty times.</p> <p>x is a set of genes (or parameters), so kwh size is a gene chromosome is a full gene, all values in x</p> <p>Arguments:</p> <ul> <li><code>x</code> dict - Dictionary containing optimization knobs - {max motor kw, battery kwh, drag coeff % improvement}</li> <li><code>write_tsv</code> bool, optional - if True, save intermediate dataframes. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>obj_arr_F</code> np.array - Array of objectives - tot_cost and phev_cd_fuel_used_kwh</li> <li><code>constraint_results_G</code> np.array - Array of constraints</li> <li><code>rs_sweep</code> dict - Output dictionary from vehicle_scenario_sweep</li> </ul> <p></p>"},{"location":"functions/moo/#adjust_fc_peak_eff","title":"adjust_fc_peak_eff","text":"Python<pre><code>def adjust_fc_peak_eff(fc_peak_eff: float, scenario: run_scenario.Scenario,\n                       optvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This method augments an advanced vehicle fc_eff_array based on new fc_peak_eff using baseline fc_eff_array</p> <p>Arguments:</p> <ul> <li><code>fc_peak_eff</code> float - Fuel converter peak efficiency override</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>optvehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of optimization vehicle</li> </ul> <p></p>"},{"location":"functions/moo/#sweep_knob","title":"sweep_knob","text":"Python<pre><code>def sweep_knob(knob: list,\n               definition: int = 100,\n               plot: bool = False,\n               optres: float = None,\n               **kwargs) -&gt; list\n</code></pre> <p>This method sweeps the optimization knob of vehicle from lbound to ubound, return TCO             plot optres to see if there's agreement from opt solution and your sweep</p> <p>Arguments:</p> <ul> <li><code>knob</code> list - list of knobs names for optimization</li> <li><code>definition</code> int, optional - Number of points. Defaults to 100.</li> <li><code>plot</code> bool, optional - if True, saves plot of bounds and TCOs. Defaults to False.</li> <li><code>optres</code> float, optional - Optimization resolution. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>tcos</code> list - List of TCOs of length=definition</li> </ul> <p></p>"},{"location":"functions/moo/#get_tco_from_moo_advanced_result","title":"get_tco_from_moo_advanced_result","text":"Python<pre><code>def get_tco_from_moo_advanced_result(x: dict) -&gt; dict\n</code></pre> <p>This method is a utility function to get detailed TCO information from optimized MOO result</p> <p>Arguments:</p> <ul> <li><code>x</code> dict - Dictionary containing optimization knobs - [max motor kw, battery kwh, drag coeff % improvement]</li> </ul> <p>Returns:</p> <ul> <li><code>out</code> dict - Dictionary containing TCO results for optimization runs</li> </ul> <p></p>"},{"location":"functions/moo/#t3codisplay-objects","title":"T3CODisplay Objects","text":"Python<pre><code>class T3CODisplay(Output)\n</code></pre> <p>This class contains the display object for Pymoo optimization printouts - pymoo.util.display.Display</p> <p>Arguments:</p> <ul> <li><code>Output</code> pymoo.util.display.output.Output - Pymoo minimize display object</li> </ul> <p></p>"},{"location":"functions/moo/#__init___1","title":"__init__","text":"Python<pre><code>def __init__(**kwargs) -&gt; None\n</code></pre> <p>This constructor initializes the pymoo.util.display.Display object</p> <p></p>"},{"location":"functions/moo/#run_optimization","title":"run_optimization","text":"Python<pre><code>def run_optimization(\n        pop_size: int,\n        n_max_gen: int,\n        knobs_bounds: dict,\n        vnum: int,\n        x_tol: float,\n        f_tol: float,\n        nth_gen: int,\n        n_last: int,\n        algo: str,\n        obj_list: list = None,\n        config: run_scenario.Config = None,\n        do_input_validation=True,\n        **kwargs) -&gt; Tuple[pymoo.core.result.Result, T3COProblem, bool]\n</code></pre> <p>This method creates and runs T3COProblem minimization</p> <p>Arguments:</p> <ul> <li><code>pop_size</code> int - Population size for optimization</li> <li><code>n_max_gen</code> int - maximum number of generations for optimization</li> <li><code>knobs_bounds</code> dict - Dictionary containing knobs and bounds</li> <li><code>vnum</code> int - vehicle selection number</li> <li><code>x_tol</code> float - tolerance in parameter space</li> <li><code>f_tol</code> float - tolerance in objective space</li> <li><code>nth_gen</code> int - number of generations to evaluate if convergence occurs</li> <li><code>n_last</code> int - number of generations to look back for termination</li> <li><code>algo</code> str - algorithm name</li> <li><code>obj_list</code> list, optional - list of objectives - TCO or PHEV_MINIMIZE_FUEL_USE_OBJECTIVE. Defaults to None.</li> <li><code>config</code> run_scenario.Config, optional - T3CO Config object containing analysis attributes and scenario attribute overrides. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>res</code> pymoo.core.result.Result - Pymoo optimization result object</li> <li><code>problem</code> moo.T3COProblem - T3COProblem ElementwiseProblem object</li> <li><code>OPTIMIZATION_SUCCEEDED</code> bool - if True, pymoo.minimize succeeded</li> </ul>"},{"location":"functions/opportunity_cost/","title":"Table of Contents","text":"<ul> <li>t3co/tco/opportunity_cost</li> <li>OpportunityCost<ul> <li>__init__</li> <li>set_kdes</li> <li>set_payload_loss_factor</li> <li>set_fueling_dwell_time_cost</li> <li>set_M_R_downtime_cost</li> </ul> </li> <li>main</li> </ul>"},{"location":"functions/opportunity_cost/#t3cotcoopportunity_cost","title":"t3co/tco/opportunity_cost","text":""},{"location":"functions/opportunity_cost/#opportunitycost-objects","title":"OpportunityCost Objects","text":"Python<pre><code>class OpportunityCost()\n</code></pre> <p>This class is used to calculate the different opportunity costs for a scenario and vehicle - Payload Capacity Cost Multiplier - Fueling Downtime Cost - Maintenance and Repair Downtime Cost</p> <p></p>"},{"location":"functions/opportunity_cost/#__init__","title":"__init__","text":"Python<pre><code>def __init__(scenario: run_scenario.Scenario,\n             range_dict: dict = None,\n             **kwargs) -&gt; None\n</code></pre> <p>Initializes OpportunityCost object using Scenario object, range_dict (from fueleconomy module), and other arguments</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object</li> <li><code>range_dict</code> dict, optional - dictionary containing primary_fuel_range_mi from fueleconomy.get_range_mi function. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/opportunity_cost/#set_kdes","title":"set_kdes","text":"Python<pre><code>def set_kdes(scenario: run_scenario.Scenario,\n             bw_method: float = 0.15,\n             verbose: bool = False) -&gt; None\n</code></pre> <p>This method sets tje kde kernel. This is time-consuming, only call this once, if possible.</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object</li> <li><code>bw_method</code> float, optional - kernel bandwidth method used by guassian_kde. Defaults to .15.</li> <li><code>verbose</code> bool, optional - if True, prints process sets. Defaults to False.</li> </ul> <p></p>"},{"location":"functions/opportunity_cost/#set_payload_loss_factor","title":"set_payload_loss_factor","text":"Python<pre><code>def set_payload_loss_factor(a_vehicle: fastsim.vehicle.Vehicle,\n                            scenario: run_scenario.Scenario,\n                            plots: bool = False,\n                            plots_dir: str = None) -&gt; None\n</code></pre> <p>This method runs teh kernel density estimation function set_kdes and calculates the payload capacity loss factor (payload_cap_cost_multiplier)             of the new vehicle compared to a conventional vehicle's reference empty weight.</p> <p>Arguments:</p> <ul> <li><code>a_vehicle</code> fastsim.vehicle - FASTSim vehicle object of the analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>plots</code> bool, optional - if True, creates histogram of KDE weight bins. Defaults to False.</li> <li><code>plots_dir</code> str, optional - output diretory for saving plot figure. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/opportunity_cost/#set_fueling_dwell_time_cost","title":"set_fueling_dwell_time_cost","text":"Python<pre><code>def set_fueling_dwell_time_cost(a_vehicle: fastsim.vehicle.Vehicle,\n                                scenario: run_scenario.Scenario) -&gt; None\n</code></pre> <p>This function calculates the fueling dwell time cost for a vehicle based on fuel fill rate/charging power and shifts_per_year</p> <p>Arguments:</p> <ul> <li><code>a_vehicle</code> fastsim.vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> </ul> <p></p>"},{"location":"functions/opportunity_cost/#set_m_r_downtime_cost","title":"set_M_R_downtime_cost","text":"Python<pre><code>def set_M_R_downtime_cost(a_vehicle: fastsim.vehicle.Vehicle,\n                          scenario: run_scenario.Scenario) -&gt; None\n</code></pre> <p>This function calculates the Maintenance and Repair (M&amp;R) downtime cost based on planned, unplanned, and tire replacement downtime inputs</p> <p>Arguments:</p> <ul> <li><code>a_vehicle</code> fastsim.vehicle - FASTSim object of the analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for the current selection</li> </ul> <p></p>"},{"location":"functions/opportunity_cost/#main","title":"main","text":"Python<pre><code>def main()\n</code></pre> <p>Runs the opportunity cost module as a standalone code based on input vehicles and scenarios</p>"},{"location":"functions/run_scenario/","title":"Table of Contents","text":"<ul> <li>t3co/run/run_scenario</li> <li>Config<ul> <li>from_file</li> <li>from_dict</li> <li>validate_analysis_id</li> <li>check_drivecycles_and_create_selections</li> </ul> </li> <li>Scenario<ul> <li>originalcargo_kg</li> <li>plf_scenario_vehicle_cargo_capacity_kg</li> <li>from_config</li> </ul> </li> <li>check_phev_init_socs</li> <li>get_phev_util_factor</li> <li>get_objective_simdrive</li> <li>run_grade_or_accel</li> <li>create_fastsim_vehicle</li> <li>get_vehicle</li> <li>get_scenario_and_cycle</li> <li>load_scenario</li> <li>load_design_cycle_from_scenario</li> <li>load_design_cycle_from_path</li> <li>set_test_weight</li> <li>reset_vehicle_weight</li> <li>limit_cargo_kg_for_moo_hev_bev</li> <li>set_max_motor_kw</li> <li>set_max_battery_kwh</li> <li>set_max_battery_power_kw</li> <li>set_max_fuel_converter_kw</li> <li>set_fuel_store_kwh</li> <li>set_cargo_kg</li> <li>vehicle_scenario_sweep</li> <li>run</li> <li>rerun</li> </ul>"},{"location":"functions/run_scenario/#t3corunrun_scenario","title":"t3co/run/run_scenario","text":"<p>Module for loading vehicles, scenarios, running them and managing them</p> <p></p>"},{"location":"functions/run_scenario/#config-objects","title":"Config Objects","text":"Python<pre><code>@dataclass\nclass Config()\n</code></pre> <p>This class reads T3COConfig.csv file containing analysis attributes like vehicle and scenario paths, TCO_method, and scenario attribute overrides.</p> <p></p>"},{"location":"functions/run_scenario/#from_file","title":"from_file","text":"Python<pre><code>def from_file(filename: str, analysis_id: int) -&gt; Self\n</code></pre> <p>This method generates a Config dictionary from CSV file and calls Config.from_dict</p> <p>Arguments:</p> <ul> <li><code>filename</code> str - path of input T3CO Config file</li> <li><code>analysis_id</code> int - analysis ID selections</li> </ul> <p>Returns:</p> <ul> <li><code>Self.from_dict</code> - method that gets Config instance from config_dict</li> </ul> <p></p>"},{"location":"functions/run_scenario/#from_dict","title":"from_dict","text":"Python<pre><code>def from_dict(config_dict: dict) -&gt; Self\n</code></pre> <p>This method generates a Config instance from config_dict</p> <p>Arguments:</p> <ul> <li><code>config_dict</code> dict - dictionary containing fields from T3CO Config input CSV file</li> </ul> <p>Returns:</p> <ul> <li><code>Self</code> - Config instance containining all values from T3CO Config CSV file</li> </ul> <p></p>"},{"location":"functions/run_scenario/#validate_analysis_id","title":"validate_analysis_id","text":"Python<pre><code>def validate_analysis_id(filename: str, analysis_id: int = 0) -&gt; Self\n</code></pre> <p>This method validates that correct analysis id is input</p> <p>Arguments:</p> <ul> <li><code>filename</code> str - T3CO Config input CSV file path</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code> - Error if analysis_id not found</li> </ul> <p></p>"},{"location":"functions/run_scenario/#check_drivecycles_and_create_selections","title":"check_drivecycles_and_create_selections","text":"Python<pre><code>def check_drivecycles_and_create_selections(config_file: str | Path)\n</code></pre> <p>This method checks if the config.drive_cycle input is a file or a folder. If a folder is provided, then it creates a list of all selections for each drivecycle in the folders as config.dc_files</p> <p>Arguments:</p> <ul> <li><code>config_file</code> str|Path - File path of config file</li> </ul> <p></p>"},{"location":"functions/run_scenario/#scenario-objects","title":"Scenario Objects","text":"Python<pre><code>@dataclass\nclass Scenario()\n</code></pre> <p>Class object that contains all TCO parameters and performance target (range, grade, accel) information         for a vehicle such that performance and TCO can be computed during optimization</p> <p></p>"},{"location":"functions/run_scenario/#originalcargo_kg","title":"originalcargo_kg","text":"<p>if needed, should be assigned immediately after vehicle read in</p> <p></p>"},{"location":"functions/run_scenario/#plf_scenario_vehicle_cargo_capacity_kg","title":"plf_scenario_vehicle_cargo_capacity_kg","text":"<p>includes cargo credit kg</p> <p></p>"},{"location":"functions/run_scenario/#from_config","title":"from_config","text":"Python<pre><code>def from_config(config: Config = None, verbose: bool = False) -&gt; None\n</code></pre> <p>This method overrides certain scenario fields if use_config is True and config object is not None</p> <p>Arguments:</p> <ul> <li><code>config</code> Config, optional - Config object. Defaults to None.</li> </ul> <p></p>"},{"location":"functions/run_scenario/#check_phev_init_socs","title":"check_phev_init_socs","text":"Python<pre><code>def check_phev_init_socs(a_vehicle: vehicle.Vehicle,\n                         scenario: Scenario) -&gt; None\n</code></pre> <p>This function checks that soc_norm_init_for_grade_pct and soc_norm_init_for_accel_pct are present only for PHEVs</p> <p>Arguments:</p> <ul> <li><code>a_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>scenario</code> Scenario - T3CO scenario object</li> </ul> <p></p>"},{"location":"functions/run_scenario/#get_phev_util_factor","title":"get_phev_util_factor","text":"Python<pre><code>def get_phev_util_factor(scenario: Scenario, v: fastsim.vehicle.Vehicle,\n                         mpgge: dict) -&gt; float\n</code></pre> <p>This function gets the PHEV utility factor derived from the computed range of the vehicle and the operational day range computed from shifts per year and the first vmt year</p> <p>Arguments:</p> <ul> <li><code>scenario</code> Scenario - T3CO scenario object</li> <li><code>v</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>mpgge</code> dict - Miles per Gallon Gasoline Equivalent dictionary</li> </ul> <p>Returns:</p> <ul> <li><code>uf</code> float - PHEV computed utility factor</li> </ul> <p></p>"},{"location":"functions/run_scenario/#get_objective_simdrive","title":"get_objective_simdrive","text":"Python<pre><code>def get_objective_simdrive(\n        analysis_vehicle: vehicle.Vehicle,\n        cycle: fastsim.cycle.Cycle) -&gt; fastsim.simdrive.SimDrive\n</code></pre> <p>This function obtains the SimDrive for accel and grade test</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>cycle</code> fastsim.cycle.Cycle - FASTSim Cycle object</li> </ul> <p>Returns:</p> <ul> <li><code>sd</code> fastsim.simdrive.SimDrive - FASTSim SimDrive object containing vehicle inputs and simulation output attributes</li> </ul> <p></p>"},{"location":"functions/run_scenario/#run_grade_or_accel","title":"run_grade_or_accel","text":"Python<pre><code>def run_grade_or_accel(test: str, analysis_vehicle: fastsim.vehicle.Vehicle,\n                       sim_drive: fastsim.simdrive.SimDrive,\n                       ess_init_soc: float) -&gt; None\n</code></pre> <p>This function handles initial SOC considerations for grade and accel tests</p> <p>If ess_init_soc override is passed, use that Else if the vehicle is an HEV, use the standard HEV init SOC values for accel and grade Else, let FASTSim determine init SOC in sim_drive() BEVs use max_soc PHEVs use max_soc Conv init_soc doesn't matter HEVs attempt SOC balancing but that is overrident by HEV test init SOC</p> <p>Arguments:</p> <ul> <li><code>test</code> str - 'accel' or 'grade' test</li> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>sim_drive</code> fastsim.simdrive.SimDrive - FASTSim SimDrive object</li> <li><code>ess_init_soc</code> float - ESS initial state of charge (SOC)</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code> - if test not in ['accel', 'grade']</li> </ul> <p></p>"},{"location":"functions/run_scenario/#create_fastsim_vehicle","title":"create_fastsim_vehicle","text":"Python<pre><code>def create_fastsim_vehicle(veh_dict: dict = None) -&gt; fastsim.vehicle.Vehicle\n</code></pre> <p>This function creates and returns an empty FASTSim vehicle object with no attributes or</p> <p>Arguments:</p> <ul> <li><code>veh_dict</code> dict, optional - Vehicle attributes dict. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>v</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> </ul> <p></p>"},{"location":"functions/run_scenario/#get_vehicle","title":"get_vehicle","text":"Python<pre><code>def get_vehicle(veh_no: int, veh_input_path: str) -&gt; fastsim.vehicle.Vehicle\n</code></pre> <p>This function loads vehicle object from vehicle number and input csv filepath</p> <p>Arguments:</p> <ul> <li><code>veh_no</code> int - vehicle selection number</li> <li><code>veh_input_path</code> str - vehicle model assumptions input CSV file path</li> </ul> <p>Returns:</p> <ul> <li><code>veh</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> </ul> <p></p>"},{"location":"functions/run_scenario/#get_scenario_and_cycle","title":"get_scenario_and_cycle","text":"Python<pre><code>def get_scenario_and_cycle(\n        veh_no: int,\n        scenario_inputs_path: str,\n        a_vehicle: fastsim.vehicle.Vehicle = None,\n        config: Config = None,\n        do_input_validation: bool = False\n) -&gt; Tuple[Scenario, fastsim.cycle.Cycle]\n</code></pre> <p>This function uses helper methods load_scenario and load_design_cycle_from_scenario         to get scenario object and cycle object corresponding to selected vehicle (by veh_no)</p> <p>Arguments:</p> <ul> <li><code>veh_no</code> int - vehicle selection number</li> <li><code>scenario_inputs_path</code> str - input file path for scenario assumptions CSV</li> <li><code>a_vehicle</code> fastsim.vehicle.Vehicle, optional - FASTSim vehicle object for given selection. Defaults to None.</li> <li><code>config</code> Config, optional - Config object for current analysis. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>scenario</code> Scenario - T3CO scenario object selected</li> <li><code>cyc</code> fastsim.cycle.Cycle - FASTSim cycle object selected</li> </ul> <p></p>"},{"location":"functions/run_scenario/#load_scenario","title":"load_scenario","text":"Python<pre><code>def load_scenario(veh_no: int,\n                  scenario_inputs_path: str,\n                  a_vehicle: fastsim.vehicle.Vehicle = None,\n                  config: Config = None) -&gt; Scenario\n</code></pre> <p>This function gets the Scenario object from scenario input CSV filepath, initializes some fields,          and overrides some fields based on Config object</p> <p>Arguments:</p> <ul> <li><code>veh_no</code> int - vehicle selection number</li> <li><code>scenario_inputs_path</code> str - input file path for scenario assumptions CSV</li> <li><code>a_vehicle</code> fastsim.vehicle.Vehicle, optional - FASTSim vehicle object for given selection. Defaults to None.</li> <li><code>config</code> Config, optional - Config object for current analysis. Defaults to None.</li> </ul> <p>Returns:</p> <ul> <li><code>scenario</code> Scenario - Scenario object for given selection</li> </ul> <p></p>"},{"location":"functions/run_scenario/#load_design_cycle_from_scenario","title":"load_design_cycle_from_scenario","text":"Python<pre><code>def load_design_cycle_from_scenario(\n        scenario: Scenario,\n        config: Config = None,\n        cyc_file_path: str = gl.OPTIMIZATION_DRIVE_CYCLES,\n        do_input_validation: bool = False) -&gt; fastsim.cycle.Cycle\n</code></pre> <p>This helper method loads the design cycle used for mpgge and range determination. It can also be used standalone to get cycles not in standard gl.OPTIMIZATION_DRIVE_CYCLES location, but still needs cycle name from scenario object, carried in scenario.drive_cycle. If the drive cycles are a list of tuples, handle accordingly with eval.</p> <p>Arguments:</p> <ul> <li><code>scenario</code> Scenario - Scenario object for current selection</li> <li><code>cyc_file_path</code> str, optional - drivecycle input file path. Defaults to gl.OPTIMIZATION_DRIVE_CYCLES.</li> </ul> <p>Returns:</p> <ul> <li><code>range_cyc</code> fastsim.cycle.Cycle - FASTSim cycle object for current Scenario object</li> </ul> <p></p>"},{"location":"functions/run_scenario/#load_design_cycle_from_path","title":"load_design_cycle_from_path","text":"Python<pre><code>def load_design_cycle_from_path(cyc_file_path: str) -&gt; fastsim.cycle.Cycle\n</code></pre> <p>This helper method loads the Cycle object from the drivecycle filepath</p> <p>Arguments:</p> <ul> <li><code>cyc_file_path</code> str - drivecycle input file path</li> </ul> <p>Returns:</p> <ul> <li><code>range_cyc</code> fastsim.cycle.Cycle - FASTSim cycle object for current Scenario object</li> </ul> <p></p>"},{"location":"functions/run_scenario/#set_test_weight","title":"set_test_weight","text":"Python<pre><code>def set_test_weight(vehicle: fastsim.vehicle.Vehicle,\n                    scenario: Scenario) -&gt; None\n</code></pre> <p>assign standardized vehicle mass for accel and grade test using GVWR and GVWR Credit</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>scenario</code> t3co.run_scenario.Scenario - T3CO scenario object</li> </ul> <p></p>"},{"location":"functions/run_scenario/#reset_vehicle_weight","title":"reset_vehicle_weight","text":"Python<pre><code>def reset_vehicle_weight(vehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This function resets vehicle mass after loaded weight tests are done for accel and grade</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> </ul> <p></p>"},{"location":"functions/run_scenario/#limit_cargo_kg_for_moo_hev_bev","title":"limit_cargo_kg_for_moo_hev_bev","text":"Python<pre><code>def limit_cargo_kg_for_moo_hev_bev(\n        opt_scenario: Scenario,\n        mooadvancedvehicle: fastsim.vehicle.Vehicle) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to assign limited cargo capacity based on GVWR + GVWRCredit and optimization vehicle mass for advanced vehicles</p> <p>Arguments:</p> <ul> <li><code>opt_scenario</code> t3co.run_scenario.Scenario - T3CO scenario object</li> <li><code>mooadvancedvehicle</code> fastsim.vehicle.Vehicle - pymoo optimization vehicle</li> </ul> <p></p>"},{"location":"functions/run_scenario/#set_max_motor_kw","title":"set_max_motor_kw","text":"Python<pre><code>def set_max_motor_kw(analysis_vehicle: fastsim.vehicle.Vehicle,\n                     scenario: Scenario, max_motor_kw: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set max_motor_kw to optimization vehicle and set kw_demand_fc_on if PHEV</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>scenario</code> run_scenario.Scenario - T3CO Scenarion object</li> <li><code>max_motor_kw</code> float - max motor power /kW</li> </ul> <p></p>"},{"location":"functions/run_scenario/#set_max_battery_kwh","title":"set_max_battery_kwh","text":"Python<pre><code>def set_max_battery_kwh(analysis_vehicle: fastsim.vehicle.Vehicle,\n                        max_ess_kwh: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set max_ess_kwh to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>max_ess_kwh</code> float - max energy storage system energy capacity /kWh</li> </ul> <p></p>"},{"location":"functions/run_scenario/#set_max_battery_power_kw","title":"set_max_battery_power_kw","text":"Python<pre><code>def set_max_battery_power_kw(analysis_vehicle: fastsim.vehicle.Vehicle,\n                             max_ess_kw: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set max_ess_kwx to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>max_ess_kw</code> float - max energy storage system power /kW</li> </ul> <p></p>"},{"location":"functions/run_scenario/#set_max_fuel_converter_kw","title":"set_max_fuel_converter_kw","text":"Python<pre><code>def set_max_fuel_converter_kw(analysis_vehicle: fastsim.vehicle.Vehicle,\n                              fc_max_out_kw: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set fc_max_out_kw to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>fc_max_out_kw</code> float - max fuel converter power /kW</li> </ul> <p></p>"},{"location":"functions/run_scenario/#set_fuel_store_kwh","title":"set_fuel_store_kwh","text":"Python<pre><code>def set_fuel_store_kwh(analysis_vehicle: fastsim.vehicle.Vehicle,\n                       fs_kwh: float) -&gt; None\n</code></pre> <p>This helper method is used within T3COProblem to set fs_kwh to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>fs_kwh</code> float - fuel storage energy capacity /kWh</li> </ul> <p></p>"},{"location":"functions/run_scenario/#set_cargo_kg","title":"set_cargo_kg","text":"Python<pre><code>def set_cargo_kg(analysis_vehicle: fastsim.vehicle.Vehicle, cargo_kg)\n</code></pre> <p>This helper method is used within T3COProblem to set cargo_kg to optimization vehicle</p> <p>Arguments:</p> <ul> <li><code>analysis_vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>cargo_kg</code> float - vehicle cargo capacity /kg</li> </ul> <p></p>"},{"location":"functions/run_scenario/#vehicle_scenario_sweep","title":"vehicle_scenario_sweep","text":"Python<pre><code>def vehicle_scenario_sweep(vehicle: fastsim.vehicle.Vehicle,\n                           scenario: Scenario,\n                           range_cyc,\n                           verbose=False,\n                           **kwargs)\n</code></pre> <p>This function contains helper methods such as get_tco_of_vehicle, check_phev_init_socs, get_accel, and get_gradeability    and returns a dictionary of all TCO related outputs</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object for current selection</li> <li><code>scenario</code> Scenario - Scenario object for current selection</li> <li><code>range_cyc</code> fastsim.cycle.Cycle - FASTSim cycle object for current scenario</li> <li><code>verbose</code> bool, optional - if selected, prints out the TCO calculation process. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>out</code> dict - output dictionary containing TCO elements</li> </ul> <p></p>"},{"location":"functions/run_scenario/#run","title":"run","text":"Python<pre><code>def run(veh_no: int,\n        vocation: str = \"blank\",\n        vehicle_input_path: str = gl.FASTSIM_INPUTS,\n        scenario_inputs_path: str = gl.OTHER_INPUTS)\n</code></pre> <p>This function runs vehicle_scenario_sweep based on vehicle and scenario objects read from input file paths</p> <p>Arguments:</p> <ul> <li><code>veh_no</code> int - vehicle selection number</li> <li><code>vocation</code> str, optional - vocation description of selected vehicle. Defaults to \"blank\".</li> <li><code>vehicle_input_path</code> str, optional - input file path for vehicle assumptions CSV. Defaults to gl.FASTSIM_INPUTS.</li> <li><code>scenario_inputs_path</code> str, optional - input file path for scenario assumptions CSV. Defaults to gl.OTHER_INPUTS.</li> </ul> <p>Returns:</p> <ul> <li><code>out</code> dict - output dictionary containing TCO results</li> </ul> <p></p>"},{"location":"functions/run_scenario/#rerun","title":"rerun","text":"Python<pre><code>def rerun(vehicle: fastsim.vehicle.Vehicle, vocation: str, scenario: Scenario,\n          config: Config)\n</code></pre> <p>This function runs vehicle_scenario_sweep when given the vehicle and scenario objects</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object</li> <li><code>vocation</code> str - vocation description</li> <li><code>scenario</code> Scenario - Scenario object</li> </ul> <p>Returns:</p> <ul> <li><code>out</code> dict - output dictionary containing TCO outputs</li> </ul>"},{"location":"functions/sweep/","title":"Table of Contents","text":"<ul> <li>t3co/sweep</li> <li>deug_traces</li> <li>save_tco_files</li> <li>get_knobs_bounds_curves</li> <li>get_objectives_constraints</li> <li>run_moo</li> <li>check_input_files</li> <li>skip_scenario</li> <li>optimize</li> <li>run_vehicle_scenarios</li> <li>run_optimize_analysis</li> </ul>"},{"location":"functions/sweep/#t3cosweep","title":"t3co/sweep","text":""},{"location":"functions/sweep/#deug_traces","title":"deug_traces","text":"Python<pre><code>def deug_traces(vehicle: fastsim.vehicle.Vehicle,\n                cycles: List[fastsim.cycle.Cycle],\n                scenario: run_scenario.Scenario) -&gt; None\n</code></pre> <p>This function gets a diagnostic trace of get_mpgge</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim Vehicle object</li> <li><code>cycles</code> List[fastsim.cycle.Cycle] - List of FASTSim drivecycle objects</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object</li> </ul> <p></p>"},{"location":"functions/sweep/#save_tco_files","title":"save_tco_files","text":"Python<pre><code>def save_tco_files(tco_files: dict, resdir: str, scenario_name: str, sel: str,\n                   ts: str) -&gt; None\n</code></pre> <p>This function saves the intermediary files as tsv</p> <p>Arguments:</p> <ul> <li><code>tco_files</code> dict - Contains all TCO calculation dataframes</li> <li><code>resdir</code> str - result directory strong</li> <li><code>scenario_name</code> str - scenario name</li> <li><code>sel</code> str - selection(s)</li> <li><code>ts</code> str - timestring</li> </ul> <p></p>"},{"location":"functions/sweep/#get_knobs_bounds_curves","title":"get_knobs_bounds_curves","text":"Python<pre><code>def get_knobs_bounds_curves(selection: int, vpttype: str, sdf: pd.DataFrame,\n                            lw_imp_curves: pd.DataFrame,\n                            aero_drag_imp_curves: pd.DataFrame,\n                            eng_eff_curves: pd.DataFrame) -&gt; Tuple[dict, dict]\n</code></pre> <p>This function fetches the knobs and constraints for running the optimization for a given selection</p> <p>Arguments:</p> <ul> <li><code>selection</code> int - selection number</li> <li><code>vpttype</code> str - vehicle powertrain type = veh_pt_type</li> <li><code>sdf</code> pd.DataFrame - scenario dataframe</li> <li><code>lw_imp_curves</code> pd.DataFrame - light weighting curve dataframe</li> <li><code>aero_drag_imp_curves</code> pd.DataFrame - aero drag curve dataframe</li> <li><code>eng_eff_curves</code> pd.DataFrame - engine efficiency curve dataframe</li> </ul> <p>Returns:</p> <ul> <li><code>knobs_bounds</code> dict - dict of knobs and bounds</li> <li><code>curves</code> dict - dict of lw, aero, and engine efficiency curve parameters</li> </ul> <p></p>"},{"location":"functions/sweep/#get_objectives_constraints","title":"get_objectives_constraints","text":"Python<pre><code>def get_objectives_constraints(selection: int,\n                               sdf: pd.DataFrame,\n                               verbose: bool = True) -&gt; Tuple[list, list]\n</code></pre> <p>This function appends to list of necessary variables based on the constraints and objectives selected</p> <p>Arguments:</p> <ul> <li><code>selection</code> int - selection number</li> <li><code>sdf</code> DataFrame - scenario dataframe</li> <li><code>verbose</code> bool, optional - if selected, function will print objectives and constraints. Defaults to True.</li> </ul> <p>Returns:</p> <ul> <li><code>objectives</code> list - list of selected objective variables</li> <li><code>constraints</code> list - list of selected constraint variables</li> </ul> <p></p>"},{"location":"functions/sweep/#run_moo","title":"run_moo","text":"Python<pre><code>def run_moo(\n        sel: int, sdf: pd.DataFrame, optpt: str, algo: str, skip_opt: bool,\n        pop_size: float, n_max_gen: int, n_last: int, nth_gen: int,\n        x_tol: float, verbose: bool, f_tol: float, resdir: str,\n        lw_imp_curves_df: pd.DataFrame, aero_drag_imp_curves_df: pd.DataFrame,\n        eng_eff_imp_curves_df: pd.DataFrame, config: run_scenario.Scenario,\n        **kwargs) -&gt; Tuple[pymoo.core.result.Result, moo.T3COProblem, bool]\n</code></pre> <p>This function calls get_objectives_constraints and get_knobs_bounds_curves, and then calls run_optimization to perform the multiobjective optimization</p> <p>Arguments:</p> <ul> <li><code>sel</code> int - selection number</li> <li><code>sdf</code> DataFrame - Scenario dataframe</li> <li><code>optpt</code> str - FASTSim vehicle powertrain type</li> <li><code>algo</code> str - algorithm name</li> <li><code>skip_opt</code> bool - skip optimization boolean</li> <li><code>pop_size</code> int - population size for optimization</li> <li><code>n_max_gen</code> int - maximum number of generations for optimization</li> <li><code>n_last</code> int - number of generations to look back for termination</li> <li><code>nth_gen</code> int - number of generations to evaluate if convergence occurs</li> <li><code>x_tol</code> float - tolerance in parameter space</li> <li><code>verbose</code> book - if selected, function prints the optimization process</li> <li><code>f_tol</code> float - tolerance in objective space</li> <li><code>resdir</code> str - results directory</li> <li><code>lw_imp_curves_df</code> DataFrame - light weighting curves dataframe</li> <li><code>aero_drag_imp_curves_df</code> DataFrame - aero drag curves dataframe</li> <li><code>eng_eff_imp_curves_df</code> DataFrame - engine efficiency curve dataframe</li> <li><code>config</code> Config - Config class object</li> </ul> <p>Returns:</p> <ul> <li><code>moo_results</code> pymoo.core.result.Result - optimization results object</li> <li><code>moo_problem</code> T3COProblem - minimization problem that calculates TCO</li> <li><code>moo_code</code> bool - Error message</li> </ul> <p></p>"},{"location":"functions/sweep/#check_input_files","title":"check_input_files","text":"Python<pre><code>def check_input_files(df: pd.DataFrame, filetype: str, filepath: str) -&gt; None\n</code></pre> <p>This function contains assert statements that make sure input vehicle and scenario dataframes do not contain numm rows</p> <p>Arguments:</p> <ul> <li><code>df</code> DataFrame - vehicle or scenario dataframe</li> <li><code>filetype</code> str - 'vehicle' or 'scenario'</li> <li><code>filepath</code> str - filepath of the vehicle or scenario input files</li> </ul> <p></p>"},{"location":"functions/sweep/#skip_scenario","title":"skip_scenario","text":"Python<pre><code>def skip_scenario(sel,\n                  selections,\n                  scenario_name,\n                  report_kwargs,\n                  verbose=False) -&gt; bool\n</code></pre> <p>This function checks if given selection is present in exclude or look_for selections</p> <p>Arguments:</p> <ul> <li><code>sel</code> float - description</li> <li><code>scenario_name</code> str - scenario name</li> <li><code>verbose</code> bool, optional - if selected, prints out scenarios that are skipped. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code> - if not present, returns True; Else False</li> </ul> <p></p>"},{"location":"functions/sweep/#optimize","title":"optimize","text":"Python<pre><code>def optimize(sel: float,\n             sdf: pd.DataFrame,\n             vdf: pd.DataFrame,\n             algo: str,\n             report_kwargs: dict,\n             REPORT_COLS: dict,\n             skip_opt: bool,\n             config: run_scenario.Config,\n             write_tsv: bool = False) -&gt; dict\n</code></pre> <p>This function runs the optimization for a given selection if skip_opt = False</p> <p>Arguments:</p> <ul> <li><code>sel</code> float - Selection number</li> <li><code>sdf</code> pd.DataFrame - Dataframe of input scenario file</li> <li><code>vdf</code> pd.DataFrame - Dataframe of input vehicle file</li> <li><code>algo</code> str - Multiobjective optimization Algorithm name</li> <li><code>report_kwargs</code> dict - arguments related to running T3CO</li> <li><code>REPORT_COLS</code> dict - Results columns dictionary for sorting the T3CO results</li> <li><code>skip_opt</code> bool - skip optimization. If true, then optimizer is not run.</li> <li><code>config</code> run_scenario.Config - Config object</li> <li><code>write_tsv</code> bool, optional - if selected, intermediary dataframes are saved as tsv files.. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>report_i</code> dict - Dictionary of T3CO results for given selection</li> </ul> <p></p>"},{"location":"functions/sweep/#run_vehicle_scenarios","title":"run_vehicle_scenarios","text":"Python<pre><code>def run_vehicle_scenarios(\n    config: run_scenario.Config, REPORT_COLS: dict, **kwargs\n) -&gt; Tuple[List[int | str], pd.DataFrame, pd.DataFrame, bool, dict, dict]\n</code></pre> <p>This function reads the input files, validates inputs, compiles the selections, and returns a clean set of inputs that are needed for the current analysis.</p> <p>Arguments:</p> <ul> <li><code>config</code> Config - Config object containing analysis attributes and scenario attribute overrides</li> <li><code>REPORT_COLS</code> dict - Dictionary of reporting columns from T3CO</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code> - input validation error</li> <li><code>Exception</code> - optimization error</li> </ul> <p>Returns:</p> <p>selections, vdf, sdf, skip_all_opt, report_kwargs, REPORT_COLS (Tuple[List[int|str], pd.DataFrame, pd.DataFrame, bool, dict, dict]): Selections list, vehicle dataframe, scenario dataframe, skip all optimization, report arguments, and report columns</p> <p></p>"},{"location":"functions/sweep/#run_optimize_analysis","title":"run_optimize_analysis","text":"Python<pre><code>def run_optimize_analysis(sel: str | int, vdf: pd.DataFrame, sdf: pd.DataFrame,\n                          skip_all_opt: bool, config: run_scenario.Config,\n                          report_kwargs: dict, REPORT_COLS: dict) -&gt; dict\n</code></pre> <p>This function runs the optimization function based on skip_all_opt input to return the report_i dictionary with T3CO results for each selection.</p> <p>Arguments:</p> <ul> <li><code>sel</code> str | int - selection number</li> <li><code>vdf</code> pd.DataFrame - Dataframe of input vehicle file</li> <li><code>sdf</code> pd.DataFrame - Dataframe of input scenario file</li> <li><code>skip_all_opt</code> bool - Skip all optimization. If true, then the optimizer is not run for any scenario</li> <li><code>config</code> run_scenario.Config - Config object</li> <li><code>report_kwargs</code> dict - Dictionary of args required for running T3CO</li> <li><code>REPORT_COLS</code> dict - Dictionary of reporting columns from T3CO</li> </ul> <p>Returns:</p> <ul> <li><code>report_i</code> dict - Dictionary of T3CO results for given selection</li> </ul>"},{"location":"functions/tco_analysis/","title":"Table of Contents","text":"<ul> <li>t3co/tco/tco_analysis</li> <li>get_operating_costs</li> <li>discounted_costs</li> <li>calc_discountedTCO</li> <li>get_tco_of_vehicle</li> </ul>"},{"location":"functions/tco_analysis/#t3cotcotco_analysis","title":"t3co/tco/tco_analysis","text":""},{"location":"functions/tco_analysis/#get_operating_costs","title":"get_operating_costs","text":"Python<pre><code>def get_operating_costs(ownershipCosts: pd.DataFrame,\n                        TCO_switch: str = \"DIRECT\") -&gt; pd.DataFrame\n</code></pre> <p>This function creates a dataframe of operating cost from ownershipCosts dataframe based on TCO_switch ('DIRECT' or 'EFFICIENCY')</p> <p>Arguments:</p> <ul> <li><code>ownershipCosts</code> pd.DataFrame - Dataframe containing year-wise ownership costs estimations like Fuel, maintenance, insurance, etc</li> <li><code>TCO_switch</code> str, optional - Switch between different TCO calculations - 'DIRECT' or 'EFFICIENCY'. Defaults to 'DIRECT'.</li> </ul> <p>Returns:</p> <ul> <li><code>operatingCosts_df</code> pd.DataFrame - Dataframe containing operating cost categories based on TCO_switch</li> </ul> <p></p>"},{"location":"functions/tco_analysis/#discounted_costs","title":"discounted_costs","text":"Python<pre><code>def discounted_costs(scenario: run_scenario.Scenario,\n                     ownershipCosts: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>This function calculates the yearly discounted costs for each category of ownershipCosts based on scenario.discRate</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> <li><code>ownershipCosts</code> pd.DataFrame - Dataframe containing year-wise ownership costs estimations like Fuel, maintenance, insurance, etc</li> </ul> <p>Returns:</p> <ul> <li><code>ownershipCosts</code> pd.DataFrame - ownershipCosts dataframe with additional 'Discounted Cost [$]' column</li> </ul> <p></p>"},{"location":"functions/tco_analysis/#calc_discountedtco","title":"calc_discountedTCO","text":"Python<pre><code>def calc_discountedTCO(scenario: run_scenario.Scenario,\n                       discounted_costs_df: pd.DataFrame,\n                       veh_cost_set: dict,\n                       veh_opp_cost_set: dict,\n                       sim_drive: fastsim.simdrive.SimDrive,\n                       TCO_switch: str = \"DIRECT\") -&gt; Tuple[float, dict, dict]\n</code></pre> <p>This function calculates the discounted Total Cost of Ownerhip (discounted to account for time-value of money). There are two methods to calculate discounted TCO - 'DIRECT' and 'EFFICIENCY'</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> <li><code>discounted_costs_df</code> pd.DataFrame - discounted operating costs dataframe</li> <li><code>veh_cost_set</code> dict - Dictionary containing MSRP breakdown</li> <li><code>veh_opp_cost_set</code> dict - Dictionary containing opportunity costs breakdown</li> <li><code>sim_drive</code> fastsim.simdrive.SimDrive - FASTSim.simdrive.SimDrive object containing inputs and outputs from vehicle simulation over a cycle</li> <li><code>TCO_switch</code> str, optional - Switch between different TCO calculations - 'DIRECT' or 'EFFICIENCY'. Defaults to 'DIRECT'.</li> </ul> <p>Returns:</p> <ul> <li><code>discounted_tco_dol</code> float - Discounted Total Cost of Ownership value</li> <li><code>oppy_cost_dol_set</code> dict - Dictionary containing discounted opportunity costs breakdown</li> <li><code>veh_oper_cost_set</code> dict - Dictionary containing discounted operating costs breakdown</li> </ul> <p></p>"},{"location":"functions/tco_analysis/#get_tco_of_vehicle","title":"get_tco_of_vehicle","text":"Python<pre><code>def get_tco_of_vehicle(\n    vehicle: fastsim.vehicle.Vehicle,\n    range_cyc: fastsim.cycle.Cycle,\n    scenario: run_scenario.Scenario,\n    write_tsv: bool = False\n) -&gt; Tuple[\n        float,\n        float,\n        dict,\n        pd.DataFrame,\n        pd.DataFrame,\n        dict,\n        dict,\n        fastsim.simdrive.SimDrive,\n        dict,\n        dict,\n        dict,\n]\n</code></pre> <p>This function calculates the Total Cost of Ownership of a vehicle and scenario for a given cycle. The three main components are: - Opportunity Costs - MSRP - Operating Costs</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of selected vehicle</li> <li><code>range_cyc</code> fastsim.cycle.Cycle - FASTSim range cycle object</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object for current selection</li> <li><code>write_tsv</code> bool, optional - if True, save intermediate files as TSV. Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>tot_cost_dol</code> float - TCO in dollars</li> <li><code>discounted_tco_dol</code> float - discounted TCO in dollars</li> <li><code>oppy_cost_set</code> dict - Dictionary of opportunity cost breakdown</li> <li><code>ownership_costs_df</code> pd.DataFrame - Ownerhip Costs dataframe containing different categories per year</li> <li><code>discounted_costs_df</code> pd.DataFrame - discounted Ownerhip Costs dataframe containing different categories per year</li> <li><code>mpgge</code> dict - Dictionary containing MPGGEs</li> <li><code>veh_cost_set</code> dict - Dictionary containing MSRP breakdown</li> <li><code>design_cycle_sdr</code> fastsim.simdrive.SimDrive - FASTSim SimDrive object for design drivecycle</li> <li><code>veh_oper_cost_set</code> dict - Dictionary containing operating costs breakdown</li> <li><code>veh_opp_cost_set</code> dict - Dictionary containing opportunity costs breakdown</li> <li><code>tco_files</code> dict - Dictionary containing TCO intermediate dataframes</li> </ul>"},{"location":"functions/tco_stock_emissions/","title":"Table of Contents","text":"<ul> <li>t3co/tco/tco_stock_emissions</li> <li>dropCols</li> <li>stockModel</li> </ul>"},{"location":"functions/tco_stock_emissions/#t3cotcotco_stock_emissions","title":"t3co/tco/tco_stock_emissions","text":""},{"location":"functions/tco_stock_emissions/#dropcols","title":"dropCols","text":"Python<pre><code>def dropCols(df: pd.DataFrame) -&gt; pd.DataFrame\n</code></pre> <p>This helper method drops columns if any row contains ['*']</p> <p>Arguments:</p> <ul> <li><code>df</code> pd.DataFrame - Input dataframe</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Output dataframe with dropped dummy columns</li> </ul> <p></p>"},{"location":"functions/tco_stock_emissions/#stockmodel","title":"stockModel","text":"Python<pre><code>def stockModel(\n    sales: pd.DataFrame,\n    marketShares: pd.DataFrame,\n    survival: pd.DataFrame,\n    annualTravel: pd.DataFrame,\n    fuelSplit: pd.DataFrame,\n    fuelEfficiency: pd.DataFrame,\n    emissions: pd.DataFrame,\n    vehicleCosts: pd.DataFrame = None,\n    travelCosts: pd.DataFrame = None,\n    fuelCosts: pd.DataFrame = None,\n    insuranceCosts: pd.DataFrame = None,\n    residualCosts: pd.DataFrame = None,\n    downtimeCosts: pd.DataFrame = None,\n    write_files: bool = False\n) -&gt; Tuple[pd.DataFrame, pd.DataFrame, pd.DataFrame]\n</code></pre> <p>This function generates the ownershipCosts dataframe from the dataframes for each cost category</p> <p>Arguments:</p> <ul> <li><code>sales</code> pd.DataFrame - Dataframe of yearly number of vehicles sales</li> <li><code>marketShares</code> pd.DataFrame - Dataframe of yearly Market Share of selection's vocation per vehicle [veh/veh]</li> <li><code>survival</code> pd.DataFrame - Dataframe of yearly Surviving vehicle per each vehicle [veh/veh]</li> <li><code>annualTravel</code> pd.DataFrame - Dataframe of vehicle's vmt: Annual Travel [mi/yr]</li> <li><code>fuelSplit</code> pd.DataFrame - Dataframe of fraction of travel using each fuel [mi/mi]</li> <li><code>fuelEfficiency</code> pd.DataFrame - Dataframe of vehicle's yearly average fuel efficiency [mi/gge]</li> <li><code>emissions</code> pd.DataFrame - Dataframe of vehicle's yearly average emissions</li> <li><code>vehicleCosts</code> pd.DataFrame, optional - Dataframe of vehicle components costs [dol]. Defaults to None.</li> <li><code>travelCosts</code> pd.DataFrame, optional - Dataframe of maintenance costs [dol/mi]. Defaults to None.</li> <li><code>fuelCosts</code> pd.DataFrame, optional - Dataframe of fuel operating costs [dol/gge]. Defaults to None.</li> <li><code>insuranceCosts</code> pd.DataFrame, optional - Dataframe of yearly insurance costs [dol]. Defaults to None.</li> <li><code>residualCosts</code> pd.DataFrame, optional - Dataframe of yearly residual costs [dol]. Defaults to None.</li> <li><code>downtimeCosts</code> pd.DataFrame, optional - Dataframe of yearly downtime costs [dol]. Defaults to None.</li> <li><code>write_files</code> bool, optional - if True, save vehicleCosts, travelCosts, fuelCosts, insuranceCosts,residualCosts, downtimeCosts . Defaults to False.</li> </ul> <p>Returns:</p> <ul> <li><code>stock</code> pd.DataFrame - Dataframe of stock model of vehicles in the market</li> <li><code>emissions</code> pd.DataFrame - Dataframe of total emissions</li> <li><code>ownershipCosts</code> pd.DataFrame - Dataframe of all ownership costs for given selection</li> </ul>"},{"location":"functions/tcocalc/","title":"Table of Contents","text":"<ul> <li>t3co/tco/tcocalc</li> <li>find_residual_rates</li> <li>calculate_dollar_cost</li> <li>calculate_opp_costs</li> <li>fill_fuel_eff_file</li> <li>fill_veh_expense_file</li> <li>fill_trav_exp_tsv</li> <li>fill_downtimelabor_cost_tsv</li> <li>fill_market_share_tsv</li> <li>fill_fuel_expense_tsv</li> <li>fill_annual_tsv</li> <li>fill_reg_sales_tsv</li> <li>fill_insurance_tsv</li> <li>fill_residual_cost_tsc</li> <li>fill_survival_tsv</li> <li>fill_fuel_split_tsv</li> </ul>"},{"location":"functions/tcocalc/#t3cotcotcocalc","title":"t3co/tco/tcocalc","text":""},{"location":"functions/tcocalc/#find_residual_rates","title":"find_residual_rates","text":"Python<pre><code>def find_residual_rates(vehicle: fastsim.vehicle.Vehicle,\n                        scenario: run_scenario.Scenario) -&gt; float\n</code></pre> <p>This helper method gets the residual rates from ResidualValues.csv</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>residual_rates</code> float - Residual rate as percentage of MSRP</li> </ul> <p></p>"},{"location":"functions/tcocalc/#calculate_dollar_cost","title":"calculate_dollar_cost","text":"Python<pre><code>def calculate_dollar_cost(veh: fastsim.vehicle.Vehicle,\n                          scenario: run_scenario.Scenario) -&gt; dict\n</code></pre> <p>This helper method calculates the MSRP breakdown dictionary from -   Glider -   Fuel converter -   Fuel Storage -   Motor &amp; power electronics -   Plug -   Battery -   Battery replacement -   Purchase tax</p> <p>Arguments:</p> <ul> <li><code>veh</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>cost_set</code> dict - Dictionary containing MSRP breakdown</li> </ul> <p></p>"},{"location":"functions/tcocalc/#calculate_opp_costs","title":"calculate_opp_costs","text":"Python<pre><code>def calculate_opp_costs(vehicle: fastsim.vehicle.Vehicle,\n                        scenario: run_scenario.Scenario,\n                        range_dict: dict) -&gt; dict\n</code></pre> <p>This helper method calculates opportunity costs and generates veh_opp_cost_set from -   Payload Lost Capacity Cost/Multiplier -   Fueling Downtime -   Maintenance and Repair Downtime</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>range_dict</code> dict - Dictionary containing range values from fueleconomy.get_range_mi()</li> </ul> <p>Returns:</p> <ul> <li><code>veh_opp_cost_set</code> dict - Dictionary containing opportunity cost results</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_fuel_eff_file","title":"fill_fuel_eff_file","text":"Python<pre><code>def fill_fuel_eff_file(vehicle: fastsim.vehicle.Vehicle,\n                       scenario: run_scenario.Scenario,\n                       mpgge_dict: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of Fuel Efficiency [mi/gge] For PHEV, cd_grid_electric_mpgge, cd_fuel_mpgge, and cs_fuel_mpgge For BEV, grid_mpgge For HEV and CONV, mpgge</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>mpgge_dict</code> dict - MPGGE dictionary from fueleconomy.get_mpgge()</li> </ul> <p>Returns:</p> <ul> <li><code>fefdata</code> pd.DataFrame - Dictionary containing Fuel Efficiency [mi/gge]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_veh_expense_file","title":"fill_veh_expense_file","text":"Python<pre><code>def fill_veh_expense_file(scenario: run_scenario.Scenario,\n                          cost_set: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of MSRP breakdown costs as Cost [$/veh]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>cost_set</code> dict - Dictionary containing MSRP breakdown cost components</li> </ul> <p>Returns:</p> <ul> <li><code>vexpdf</code> pd.DataFrame - Dataframe containing MSRP components costs as Cost [$/veh]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_trav_exp_tsv","title":"fill_trav_exp_tsv","text":"Python<pre><code>def fill_trav_exp_tsv(vehicle: fastsim.vehicle.Vehicle,\n                      scenario: run_scenario.Scenario) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing maintenance costs in Cost [$/mi]</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing maintenance costs in Cost [$/mi]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_downtimelabor_cost_tsv","title":"fill_downtimelabor_cost_tsv","text":"Python<pre><code>def fill_downtimelabor_cost_tsv(scenario: run_scenario.Scenario,\n                                oppy_cost_set: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing fueling downtime and M&amp;R downtime costs in Cost [$/Yr]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>oppy_cost_set</code> dict - Dictionary containing fueling_downtime_oppy_cost_dol_per_yr,fueling_dwell_labor_cost_dol_per_yr and mr_downtime_oppy_cost_dol_per_yr</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing fueling and MR downtime costs in Cost [$/Yr]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_market_share_tsv","title":"fill_market_share_tsv","text":"Python<pre><code>def fill_market_share_tsv(scenario: run_scenario.Scenario,\n                          num_vs: int = 1) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing market share of current vehicle selection per vehicle sold</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>num_vs</code> int, optional - Number of vehicles. Defaults to 1.</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing market share of current vehicle in Market Share [veh/veh]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_fuel_expense_tsv","title":"fill_fuel_expense_tsv","text":"Python<pre><code>def fill_fuel_expense_tsv(vehicle: fastsim.vehicle.Vehicle,\n                          scenario: run_scenario.Scenario) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of fuel operating costs in Cost [$/gge]</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Raises:</p> <ul> <li><code>Exception</code> - Invalid fuel_type type</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing fuel operating costs in Cost [$/gge]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_annual_tsv","title":"fill_annual_tsv","text":"Python<pre><code>def fill_annual_tsv(scenario: run_scenario.Scenario) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of annual vehicle miles traveled (vmt) - Annual Travel [mi/yr]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing Annual Travel [mi/yr]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_reg_sales_tsv","title":"fill_reg_sales_tsv","text":"Python<pre><code>def fill_reg_sales_tsv(scenario: run_scenario.Scenario,\n                       num_vs: int = 1) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing vehicle sales per year - Sales [veh]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>num_vs</code> int, optional - Number of vehicles. Defaults to 1.</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing vehicle sales in Sales [veh]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_insurance_tsv","title":"fill_insurance_tsv","text":"Python<pre><code>def fill_insurance_tsv(scenario: run_scenario.Scenario,\n                       veh_cost_set: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing vehicle insurance costs as Cost [$/Yr]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>veh_cost_set</code> dict - Dictionary containing MSRP costs</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing insurance costs in Cost [$/Yr]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_residual_cost_tsc","title":"fill_residual_cost_tsc","text":"Python<pre><code>def fill_residual_cost_tsc(vehicle: fastsim.vehicle.Vehicle,\n                           scenario: run_scenario.Scenario,\n                           veh_cost_set: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of residual costs as Cost [$/Yr]</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>veh_cost_set</code> dict - Dictionary containing MSRP costs</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing vehicle residual costs as Cost [$/Yr]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_survival_tsv","title":"fill_survival_tsv","text":"Python<pre><code>def fill_survival_tsv(scenario: run_scenario.Scenario,\n                      num_vs=1) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe containing surviving vehicles as Surviving Vehicles [veh/veh]</p> <p>Arguments:</p> <ul> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>num_vs</code> int, optional - Number of vehicles. Defaults to 1.</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing number of surviving vehicles on road in Surviving Vehicles [veh/veh]</li> </ul> <p></p>"},{"location":"functions/tcocalc/#fill_fuel_split_tsv","title":"fill_fuel_split_tsv","text":"Python<pre><code>def fill_fuel_split_tsv(vehicle: fastsim.vehicle.Vehicle,\n                        scenario: run_scenario.Scenario,\n                        mpgge: dict) -&gt; pd.DataFrame\n</code></pre> <p>This helper method generates a dataframe of fraction of travel in each fuel type as Fraction of Travel [mi/mi]</p> <p>Arguments:</p> <ul> <li><code>vehicle</code> fastsim.vehicle.Vehicle - FASTSim vehicle object of analysis vehicle</li> <li><code>scenario</code> run_scenario.Scenario - Scenario object of current selection</li> <li><code>mpgge</code> dict - MPGGE dictionary from fueleconomy.get_mpgge()</li> </ul> <p>Returns:</p> <ul> <li><code>df</code> pd.DataFrame - Dataframe containing fraction of travel in each fuel type as Fraction of Travel [mi/mi]</li> </ul>"},{"location":"models/Oxidized%20FASTSim%20for%20Oxidized%20T3CO/","title":"Oxidized FASTSim for Oxidized T3CO","text":""},{"location":"models/Oxidized%20FASTSim%20for%20Oxidized%20T3CO/#how-to-install-oxidized-fastsim-for-oxidized-t3co-in-server-environment-or-local-desktop","title":"How to install Oxidized FASTSim for Oxidized T3CO in server environment (or local desktop)","text":"<p>As of now, running from source code in UNIX-like server environments is the only way to use Oxidzed T3CO until a tarball or wheel dist for UNIX-like is completed </p> <ul> <li><code>cd /srv/data/users/$USER/</code> # i.e. the path for where you should have your programs on the fleetdna server</li> <li><code>conda create --name t3co-env</code></li> <li><code>conda activate t3co-env</code></li> </ul>"},{"location":"models/Oxidized%20FASTSim%20for%20Oxidized%20T3CO/#install-rust-if-needed","title":"Install rust (if needed)","text":"<ul> <li>conda update rust or</li> <li>export RUSTUP_HOME=/srv/data/users/ayip/.rustup</li> <li>export CARGO_HOME=/srv/data/users/ayip/.cargo</li> <li>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</li> </ul>"},{"location":"models/Oxidized%20FASTSim%20for%20Oxidized%20T3CO/#install-fastsim-207-from-the-github-repo","title":"Install FASTSim 2.0.7 from the Github repo","text":"<ul> <li>If FASTSim is already installed n your current environment, uninstall it: <code>pip uninstall fastsim</code></li> <li>clone fastsim repo with git, <code>git clone https://github.com/NREL/fastsim.git</code></li> <li><code>cd fastsim</code></li> <li><code>git checkout rust-port</code> # switch to rust-port branch - may or may not be redundant with next step</li> <li><code>git checkout 2.0.7</code> # switch to tagged version/commit 2.0.7</li> <li>(citing instructions to compile and test Rust under DEVELOPERS)</li> <li>do <code>pip install maturin</code></li> <li><code>cd rust</code></li> <li>do <code>cargo test --release</code></li> <li><code>cd fastsim-py</code></li> <li>do <code>maturin develop --release</code></li> <li><code>cd ..</code> back up to root folder in <code>/fastsim</code></li> <li>install the FASTSim 2.0.7 code base into your activated conda environment for T3CO with <code>pip install -e .</code> # you might have to do this a few times repeatedly, if you get the error message \"resource temporarily unavailable\" - maybe VPN/SSH related but it's unavoidable because we're on the server</li> </ul>"},{"location":"models/Oxidized%20FASTSim%20for%20Oxidized%20T3CO/#test-run-oxidized-t3co","title":"Test run Oxidized T3CO","text":"<ul> <li><code>cd run_scripts</code></li> <li><code>python sweep.py -dst_dir /srv/data/nfs/T3CO/users/$USER/t3co-test-delete-bevs -look_for \"BEV\" -skopt -skiv</code></li> </ul>"},{"location":"models/PHEVs/","title":"Plug-in Hybrid Electric Vehicle Considerations","text":"<p>Given that PHEVs follow along the same TCO and optimizaton path as other powertrains, but with some wrinkles attributable only to PHEVs, we've listed those considerations here separately to ensure PHEVs are documented clearly and distinctly where needed. </p>"},{"location":"models/PHEVs/#contents","title":"Contents","text":"<ul> <li>Plug-in Hybrid Electric Vehicle Considerations<ul> <li>Contents</li> <li>PHEV Fuel Economy CD/CS </li> <li>PHEV Fuel Costs and Utility Factor </li> <li>PHEV Acceleration \\&amp; Grade Tests </li> <li>PHEV Optimization </li> <li>PHEV Special Inputs </li> <li>PHEVs Not Doing What You Want?</li> </ul> </li> </ul>"},{"location":"models/PHEVs/#phev-fuel-economy-cdcs","title":"PHEV Fuel Economy CD/CS","text":"<p>Plug in hybrid electric vehicles are presumed to operate in two distinct modes. The first \u2013 charge depleting (CD) - is a predominantly electrically powered regime, which is desirable to predominate the overall operational model of a vehicle due to its lower emissions per mile of operation. It is also presumed that due to a lower cost of charging electricity it would be an economically preferred mode of operation for a fleet operator or a light duty vehicle owner. As daily driving varies between vehicles, this mode of operation may be designed to cover majority of a fleet or personal driving. For longer operating routes or extensive driving, those vehicles are capable to operate safely after their initial \u201ccharge depleting\u201d mode of operation is depleted. Once a state of battery charge reaches its \u201cminimum\u201d operating window for charge depleting mode, the vehicle\u2019s controls would shift the vehicle power generation to predominantly come from the engine \u2013 which would switch the vehicle into a charge sustaining mode of operation (CS).  </p> <p>One of T3CO\u2019s objectives is that the model is flexible and generalized to allow wide variety of powertrain and drive cycle simulations. In some instances, drive cycles may experience highly dynamic  operation early in their simulated cycle followed by steadier operation in a different part of the cycle. Due to the cycle\u2019s non-homogeneous operation, it desirable to assess the typical vehicle performance throughout a cycle while the vehicle is in either a CS or CD mode. In assessing an entire cycle in both CS and CD modes, the model thus assures that typical operation of a vehicle would be represented in designing the vehicle powertrain even when the design cycle is completely disparate in kinetic intensity between its start and end. Any cycle characteristics which may benefit or deter CS mode of operation early in the drive cycle would be simulated. Also, CD operation would be assessed with operation of the vehicle late in the simulated drive cycle. Below is a description of how to enable T3CO to produce a full evaluation of a drive cycle in both its CD and CS modes and provide optimizer (MOO) and model output parameters to allow powertrain and energy storage sizing for range.</p>"},{"location":"models/PHEVs/#phev-fuel-costs-and-utility-factor","title":"PHEV Fuel Costs and Utility Factor","text":"<p>Fuel costs for PHEVs depend on a concept called the Utility Factor. The utility in question is when the PHEV operates in a Charge Depleting (CD) fashion, and the factor is the fraction of operational time in which the vehicle can do this. The ideal would be that the PHEV operates in CD at all times, as this maximizes miles running on electricity, and thus maximizes energy efficiency and minimizes fuel costs. This would correspond to a utility factor of 1.</p> <p>The user can prescribe the utility factor as a constant value, using the T3CO input <code>phev_utility_factor_override</code>, otherwise, the UF will be computed for the user.</p> <p>The Utility Factor is computed here: https://github.com/NREL/T3CO/blob/661d2cb308f66041df693ad27fab050f512d6298/t3co/run_scenario.py#L238 using the concept of shift range [miles], as: </p> Text Only<pre><code>    shift_range_mi = vehicle miles travelled in year one / shifts_per_year\n    phev_utility_factor_computed = round(min(shift_range_mi, cd_range_mi) / shift_range_mi, 3)  \n    uf = scenario.phev_utility_factor_computed\n</code></pre> <p><code>cd_range_mi</code> is computed here: https://github.com/NREL/T3CO/blob/661d2cb308f66041df693ad27fab050f512d6298/t3co/objectives/fueleconomy.py#L41</p> <p>as described in the docs in fuel_efficiency_and_range.md</p> <p>The Utility Factor essentially weights the three fuel economy metrics that go into TCO, computed for PHEVs:  |code variable|| |--|--| |cs_fuel_mpgge| Charge Sustaining miles per gallon of gasoline equivalent from ICE fuel stores only| |cd_fuel_mpgge| Charge Depleting miles per gallon of gasoline equivalent from ICE fuel stores only| |cd_grid_electric_mpgge| Charge Depleting grid adjusted (charger efficiency) miles per gallon of gasoline equivalent from PHEV battery pack only |</p> <p>The code fills out fuel usage in GGE based on the utility factor adjusted mpgges for the CD and CS modes and computes a resulting fuel cost for each vehicle operational year:</p> Text Only<pre><code>    data = [\n        [vehicle_segment, fuels[0], vocation, uf ],     # cd_electricity\n        [vehicle_segment, fuels[1], vocation, uf ],     # cd_diesel\n        [vehicle_segment, fuels[2], vocation, 1 - uf ]  # cs_diesel\n    ]\n</code></pre> <p></p> <p></p>"},{"location":"models/PHEVs/#phev-acceleration-grade-tests","title":"PHEV Acceleration &amp; Grade Tests","text":"<p>PHEVs have a special input for determining intial SOC during the acceleration test: <code>soc_norm_init_for_accel_pct</code>. Similarly, PHEVs have a special input for determining intial SOC during the grade test: <code>soc_norm_init_for_grade_pct</code>. This is used to determine the normalized percentage of available SOC within the vehicle's minimum and maximum SOC range. The formula is:</p> Text Only<pre><code>ess_init_soc_for_test = vehicle.min_soc + (scenario.soc_norm_init_for_test * (vehicle.max_soc - vehicle.min_soc) )\n</code></pre> <p>There are other inputs from the T3CO scenario file that can override initial SOC behavior. <code>ess_init_soc_grade</code> and <code>ess_init_soc_accel</code>. As of now, it is treated as an error for a user to provide these along with values for <code>soc_norm_init_for_grade_pct</code> and <code>soc_norm_init_for_accel_pct</code> as it is ambiguous as to which initial SOC is supposed to be used. These general initial SOC overrides should be supplied only for HEVs and BEVs. The default behavior, what the code does for inital SOC for tests in the absense of any input for <code>ess_init_soc_grade/accel</code>, or <code>ess_init_soc_for_grade/accel</code>, is a mix of FASTSim's default behaviors and some overrides that T3CO configures. This is described in acceleration_and_grade_tests.md</p> <p>applied at: https://github.com/NREL/T3CO/blob/47d92dadef3451f403275159888811e01057416d/t3co/run_scenario.py#L539</p> <p>Note It is worth noting that initial SOC inputs for grade and acceleration of PHEVs do not seem to matter much unless the battery is small enough in size (kWh) as to make it possible that the vehicle can naturally deplete its usable SOC range before the test is over.</p> Text Only<pre><code>ess kwh size 4.0\nmax motor kw 163.0\nmax fc kw 100.0\ninit soc:  0.05 max speed at 6% grade achvd 36.333\ninit soc:  0.15 max speed at 6% grade achvd 36.349\ninit soc:  0.25 max speed at 6% grade achvd 36.49\ninit soc:  0.35 max speed at 6% grade achvd 36.724\ninit soc:  0.45 max speed at 6% grade achvd 37.102\ninit soc:  0.55 max speed at 6% grade achvd 37.704\ninit soc:  0.65 max speed at 6% grade achvd 38.652\ninit soc:  0.75 max speed at 6% grade achvd 40.123\ninit soc:  0.85 max speed at 6% grade achvd 42.363\ninit soc:  0.95 max speed at 6% grade achvd 45.69\n\ness kwh size 150.0\nmax motor kw 163.0\nmax fc kw 100.0\ninit soc:  0.05 max speed at 6% grade achvd 34.849\ninit soc:  0.15 max speed at 6% grade achvd 67.793\ninit soc:  0.25 max speed at 6% grade achvd 67.793\ninit soc:  0.35 max speed at 6% grade achvd 67.793\ninit soc:  0.45 max speed at 6% grade achvd 67.793\ninit soc:  0.55 max speed at 6% grade achvd 67.793\ninit soc:  0.65 max speed at 6% grade achvd 67.793\ninit soc:  0.75 max speed at 6% grade achvd 67.793\ninit soc:  0.85 max speed at 6% grade achvd 67.793\ninit soc:  0.95 max speed at 6% grade achvd 67.793\n</code></pre>"},{"location":"models/PHEVs/#phev-optimization","title":"PHEV Optimization","text":"<p>PHEV optimization uses an optional, special input called <code>motor_power_override_kw_fc_demand_on_pct</code>. This is the percentage of motor power value set to the vehicle field <code>kw_fc_demand_on</code> to allow <code>kw_fc_demand_on</code> to increase or decrease proportionally with changes in <code>mc_max_kw</code> from the optimizer. This is described in more detail in the opimization docs.</p>"},{"location":"models/PHEVs/#phev-special-inputs","title":"PHEV Special Inputs","text":"PHEV scenario file inputs description required/optional default range phev_utility_factor_override prescribed utility factor, code will no longer compute it optional if not supplied, will be -1 and UF will be computed by T3CO [0,1] shifts_per_year Get the PHEV utility factor derived from the computed range of the vehicle and the operational day range computed from shifts per year and the first vmt year required Suggested value: 250 (weekdays/yr, assuming 1 shift/day) [1,inf] soc_norm_init_for_grade_pct Strictly PHEV only, will throw error for other types For grade test, determines the normalized percentage of available SOC within the vehicle's minimum and maximum SOC range optional if not supplied, will be -1, FASTSim sets PHEV init SOC as max_soc [0,1] soc_norm_init_for_accel_pct Strictly PHEV only, will throw error for other types For accel test, determines the normalized percentage of available SOC within the vehicle's minimum and maximum SOC range optional if not supplied, will be -1, FASTSim sets PHEV init SOC as max_soc [0,1] motor_power_override_kw_fc_demand_on_pct The percentage of motor power value set to the vehicle field <code>kw_fc_demand_on</code> to allow <code>kw_fc_demand_on</code> to increase or decrease proportionally with changes in <code>mc_max_kw</code> from the optimizer. optional suggested value: .85. If not supplied, will be -1 and <code>vehicle.kw_fc_demand_on defaults</code> to vehicle file input (0,1]"},{"location":"models/PHEVs/#phevs-not-doing-what-you-want","title":"PHEVs Not Doing What You Want?","text":"<p>PHEVs can be difficult to work with and configure in order to get the desired results. Sometimes you want to manipulate the vehicle into operating paradigms for research purposes, such as using motor more favorably than engine, or vice versa. There are a few hybrid powertrain controls in FASTSim Vehicle models that users should be aware of: - kw_demand_fc_on the kw demand on the transmission from the drive cycle, a threshold at which the fuel converter (engine) must be turned on the contribute to meeting powertrain demand  - mc_sec_to_peak_pwr seconds to motor reaching peak power, should be tied to a physically realistic value - min_fc_time_on minimum time in seconds the engine must be on if the engine is turned on to meet demand - new powertrain input/variable </p> <p>Other considerations: Currently, if the engine is turned on at all, FASTSim tries to use the engine close to or at its max power (kw) level in order to approach the theoretical max efficiency of the engine. This is done without regard to how much engine power on top of motor power is actually needed in order to meet drive cycle demand.</p>"},{"location":"models/ScenarioFile/","title":"T3CO Scenario File","text":"<p>Below is an example of a scenario file contents, in columnar format for readability. Usually the input CSV is in row form. Scenario selections become a <code>selection</code> object in T3CO. Scenario files are one of two fundamental units of T3CO. The other is the FASTSim <code>Vehicle</code>. To put it in plain English, if FASTSim <code>Vehicles</code> are the peanut butter, <code>Scenarios</code> are the jelly. These two objects literally flow through the code in a pair, in tandem. Most methods in T3CO have arguments for a <code>Vehicle</code> object and its accompanying <code>Scenario</code> object. If using row-based sources for vehicles and scenarios, the <code>selection</code> value in the scenario file should correspond with the <code>selection</code> value in the FASTSim input file. The <code>Vehicle</code> of selection should correspond with <code>Scenario</code> of selection 21 and they should flow through the code together. This is how we pair a vehicle with operating and economic conditions from the scenario to create total cost of ownership and performance results; as well as optimization targets and constraints.</p> column name description example value type/bounds <code>selection</code> &lt;  &gt; <code>110</code> NA <code>scenario_name</code> &lt;  &gt; <code>Class 8 Sleeper cab mid roof (PHEV, 2050, no program)</code> NA <code>drive_cycle</code> &lt;  &gt; <code>[(\"EPA_Ph2_rural_interstate_65mph.csv\", .86), (\"EPA_Ph2_urban_highway_55mph.csv\", .09), (\"EPA_Ph2_transient.csv\", .05)]</code> Strings are drive cycle names or full paths to drive cycle. If using only one drive cycle,can be a single string. If using a composite set of cycles, must be a list of tuples. First tuple element is drive cycle string, second element is a float between 0 and 1:<code>string or [(string,float),...]</code> <code>vmt_reduct_per_yr</code> &lt; &gt; <code>nan</code> <code>[0, inf]</code> <code>vmt</code> &lt; &gt; <code>[108010,117983,114998,104732]</code> Should have a vmt entry in the list for every year the vehicle is operational based on <code>vehicle_life_yr</code>: <code>[int,...]</code> <code>constant_trip_distance_mi</code> &lt; &gt; <code>0</code> <code>int</code> <code>vehicle_life_yr</code> &lt; &gt; <code>4</code> <code>int</code> <code>discount_rate_pct_per_yr</code> &lt; &gt; <code>0.03</code> <code>float [0,1]</code> <code>ess_cost_dol_per_kw</code> &lt; &gt; <code>0</code> <code>float</code> <code>ess_cost_dol_per_kwh</code> &lt; &gt; <code>85</code> <code>float</code> <code>ess_base_cost_dol</code> &lt; &gt; <code>0</code> <code>float</code> <code>ess_cost_reduction_dol_per_yr</code> &lt; &gt; <code>0</code> <code>float</code> <code>ess_salvage_value_dol</code> &lt; &gt; <code>0</code> <code>float</code> <code>pe_mc_cost_dol_per_kw</code> &lt; &gt; <code>11</code> <code>float</code> <code>pe_mc_base_cost_dol</code> &lt; &gt; <code>350</code> <code>float</code> <code>fc_ice_cost_dol_per_kw</code> &lt; &gt; <code>50</code> <code>float</code> <code>fc_ice_base_cost_dol</code> &lt; &gt; <code>6250</code> <code>float</code> <code>fc_fuelcell_cost_dol_per_kw</code> &lt; &gt; <code>85</code> <code>float</code> <code>fs_cost_dol_per_kwh</code> &lt; &gt; <code>0.07</code> <code>float</code> <code>fs_h2_cost_dol_per_kwh</code> &lt; &gt; <code>9.5</code> <code>float</code> <code>plug_base_cost_dol</code> &lt; &gt; <code>500</code> <code>float</code> <code>markup_pct</code> &lt; &gt; <code>1.2</code> <code>float</code> <code>tax_rate_pct</code> &lt; &gt; <code>0.035</code> <code>float</code> <code>fc_cng_ice_cost_dol_per_kw</code> &lt; &gt; <code>55</code> <code>float</code> <code>fs_cng_cost_dol_per_kwh</code> &lt; &gt; <code>7.467735503</code> <code>float</code> <code>vehicle_glider_cost_dol</code> &lt; &gt; <code>112759</code> <code>float</code> <code>segment_name</code> &lt; &gt; <code>HDTC8</code> <code>string</code> <code>gvwr_kg</code> &lt; &gt; <code>36287.43275</code> <code>float</code> <code>gvwr_credit_kg</code> &lt; &gt; <code>0</code> amount [kg] vehicle can exceed GVWR[kg], applies during component sizing during optimization <code>int</code> <code>fuel</code> &lt; &gt; <code>[\"cd_electricity\", \"cd_diesel\", \"cs_diesel\"]</code> multiple fuel types are permissible, or a single type can be input. For PHEVs, there must be specified two Charge Depleting and on Charge Sustaining as shown<code>string or [string,...]</code> <code>maint_oper_cost_dol_per_mi</code> &lt; &gt; <code>[0.15,0.16,...0.19]</code> <code>float list</code> <code>vocation</code> &lt; &gt; <code>Long haul</code> <code>string</code> <code>model_year</code> &lt; &gt; <code>2050</code> <code>int</code> <code>region</code> &lt; &gt; <code>FY21NoProgram</code> <code>string</code> <code>target_range_mi</code> &lt; &gt; <code>500</code> <code>float</code> Note: for PHEVs, T3CO will meet this requirement in CD mode <code>min_speed_at_6pct_grade_in_5min_mph</code> &lt; &gt; <code>30</code> <code>float</code> <code>min_speed_at_1p25pct_grade_in_5min_mph</code> &lt; &gt; <code>65</code> <code>float</code> <code>max_time_0_to_60mph_at_gvwr_s</code> &lt; &gt; <code>80</code> <code>float</code> <code>max_time_0_to_30mph_at_gvwr_s</code> &lt; &gt; <code>20</code> <code>float</code> <code>lw_imp_curve_sel</code> &lt; &gt; <code>MDHD_noprogram_2050</code> <code>string</code> Optimization \"knob\" handling. For certain knobs, there are curves that apply. This value references a column in the light-weighting curves file. Example: light weighting curves. Referenced in <code>sweep.py</code> here <code>eng_eff_imp_curve_sel</code> &lt; &gt; <code>MDHD_large_noprogram_2050</code> <code>string</code> Optimization \"knob\" handling. For certain knobs, there are curves that apply. This value references a column in the engine efficiency improvement curves file. Example: engine efficiency curves. Referenced in <code>sweep.py</code> here <code>aero_drag_imp_curve_sel</code> &lt; &gt; <code>SleeperTractorMidRoof_noprogram_2050</code> <code>string</code> Optimization \"knob\" handling. For certain knobs, there are curves that apply. This value references a column in the drag coefficient improvement curves file. Example: drag coefficient curves. Referenced in <code>sweep.py</code> here <code>skip_opt</code> &lt; &gt; <code>True</code> Important column! Though it's a bit buried, this column will designate whether this scenario and vehicle combination should be optimized or not. If <code>True</code>, then optimization is skipped.<code>True or False</code> <code>knob_min_ess_kwh</code> &lt; &gt; <code>300</code> <code>nan or float</code> Optimization settings If this \"knob\" has a min and max value input from user, it implies that this opimization parameter should be used. <code>knob_max_ess_kwh</code> &lt; &gt; <code>1500</code> <code>nan or float</code> Optimization settings If this \"knob\" has a min and max value input from user, it implies that this opimization parameter should be used. <code>knob_min_motor_kw</code> &lt; &gt; <code>200</code> <code>nan or float</code> Optimization settings If this \"knob\" has a min and max value input from user, it implies that this opimization parameter should be used. <code>knob_max_motor_kw</code> &lt; &gt; <code>400</code> <code>nan or float</code> Optimization settings If this \"knob\" has a min and max value input from user, it implies that this opimization parameter should be used. <code>knob_min_fc_kw</code> &lt; &gt; <code>100</code> <code>nan or float</code> Optimization settings If this \"knob\" has a min and max value input from user, it implies that this opimization parameter should be used. <code>knob_max_fc_kw</code> &lt; &gt; <code>300</code> <code>nan or float</code> Optimization settings If this \"knob\" has a min and max value input from user, it implies that this opimization parameter should be used. <code>knob_min_fs_kwh</code> &lt; &gt; <code>100</code> <code>nan or float</code> Optimization settings If this \"knob\" has a min and max value input from user, it implies that this opimization parameter should be used. <code>knob_max_fs_kwh</code> &lt; &gt; <code>600</code> <code>nan or float</code> Optimization settings If this \"knob\" has a min and max value input from user, it implies that this opimization parameter should be used. <code>constraint_range</code> &lt; &gt; <code>nan</code> <code>True or False</code> Optimization setting. If True, then the constraint is applied and tests for range must be met or exceeded. Test threshold designated by value in <code>target_range_mi</code> <code>constraint_accel</code> &lt; &gt; <code>nan</code> <code>True or False</code> Optimization setting. If True, then the constraint is applied and tests for acceleratiion. must be met or exceeded Test threshold designated by value in <code>max_time_0_to_60mph_at_gvwr_s and max_time_0_to_30mph_at_gvwr_s</code> <code>constraint_grade</code> &lt; &gt; <code>nan</code> <code>True or False</code> Optimization setting. If True, then the constraint is applied and tests for grade must be met or exceeded Test threshold designated by value in <code>min_speed_at_6pct_grade_in_5min_mph and min_speed_at_1p25pct_grade_in_5min_mph</code> <code>objective_tco</code> &lt; &gt; <code>nan</code> <code>True or False</code> Optimization setting. If True, then the objective to minimize Total Cost of Ownership is applied. <code>constraint_c_rate</code> &lt; &gt; <code>True</code> <code>True or False</code> Optimization setting. If True, then the constraint for c rate is applied <code>shifts_per_year</code> &lt; &gt; <code>260</code> PHEVs only! See PHEV Docs <code>phev_utility_factor_override</code> &lt; &gt; <code>.6</code> PHEVs only! See PHEV Docs <code>soc_norm_init_for_grade_pct</code> &lt; &gt; <code>.8</code> PHEVs only! See PHEV Docs <code>soc_norm_init_for_accel_pct</code> &lt; &gt; <code>.85</code> PHEVs only! See PHEV Docs <code>motor_power_override_kw_fc_demand_on_pct</code> &lt; &gt; <code>.95</code> PHEV specific inputs. See PHEV Docs <code>ess_init_soc_grade</code> &lt; &gt; <code>.8</code> <code>[0,1]</code> For BEV or HEV, during grade test, if initial SOC override is desired, rather than using the FASTSim + T3CO intial SOC regime <code>ess_init_soc_accel</code> &lt; &gt; <code>.85</code> <code>[0,1]</code>  For BEV or HEV, during grade test, if initial SOC override is desired, rather than using the FASTSim + T3CO intial SOC regime"},{"location":"models/TCO_calculations/","title":"Contents","text":"<ul> <li>Contents</li> <li>Overview </li> <li>Vehicle MSRP          - MSRP Inputs         - MSRP Formula         - MSRP Code</li> <li>Fuel Costs </li> <li>Other Costs </li> <li>Payload Opportunity Costs </li> <li>Stock Model TCO Calculations </li> <li>BEV considerations </li> <li>PHEV considerations </li> <li>Fuel Costs Table </li> </ul>"},{"location":"models/TCO_calculations/#overview","title":"Overview","text":"<p>The Total Cost of Ownership is a core metric calculated by T3CO. It is made up of a few parts. The first is MSRP, or the purchase cost of the vehicle. Then there is fuel cost for each operational year. Then there are \"other costs\" as well as Payload Opportunity Costs.</p>"},{"location":"models/TCO_calculations/#vehicle-msrp","title":"Vehicle MSRP","text":"<p>The vehicle MSRP is composed of a glider cost, powertrain costs from engine and/or motor, energy storage for liquid fuel or battery pack, the plug for PHEVs and EVs, the battery replacement cost (rarely used), &amp; the Purchase tax. </p> <p>example</p> Text Only<pre><code>'veh_msrp_set': {   \n  'Battery': 7309.147060965,\n  'Battery replacement': 0,\n  'Fuel Storage': 382.918608555,\n  'Fuel converter': 18554.678768654998,\n  'Glider': 121918.9997,\n  'Motor &amp; power electronics': 627.78252096,\n  'Plug': 0.0,\n  'Purchase tax': 0.0,\n  'msrp': 148793.526659135\n}\n</code></pre> <p>The Glider and Plug costs are straight inputs from the T3CO scenario file. Battery and Fuel Storage are computed on a <code>$/kWh</code> basis. Fuel converter and Motor &amp; power electronics are computed on a <code>$/kW</code> also from the T3CO scenario file.</p>"},{"location":"models/TCO_calculations/#msrp-inputs","title":"MSRP Inputs","text":"column name example value bounds <code>ess_cost_dol_per_kw</code> <code>0</code> <code>float</code> <code>ess_cost_dol_per_kwh</code> <code>85</code> <code>float</code> <code>ess_base_cost_dol</code> <code>0</code> <code>float</code> <code>ess_cost_reduction_dol_per_yr</code> <code>0</code> <code>float</code> <code>ess_salvage_value_dol</code> <code>0</code> <code>float</code> <code>pe_mc_cost_dol_per_kw</code> <code>11</code> <code>float</code> <code>pe_mc_base_cost_dol</code> <code>350</code> <code>float</code> <code>fc_ice_cost_dol_per_kw</code> <code>50</code> <code>float</code> <code>fc_ice_base_cost_dol</code> <code>6250</code> <code>float</code> <code>fc_fuelcell_cost_dol_per_kw</code> <code>85</code> <code>float</code> <code>fs_cost_dol_per_kwh</code> <code>0.07</code> <code>float</code> <code>fs_h2_cost_dol_per_kwh</code> <code>9.5</code> <code>float</code> <code>plug_base_cost_dol</code> <code>500</code> <code>float</code> <code>markup_pct</code> <code>1.2</code> <code>float</code> <code>tax_rate_pct</code> <code>0.035</code> <code>float</code> <code>fc_cng_ice_cost_dol_per_kw</code> <code>55</code> <code>float</code> <code>fs_cng_cost_dol_per_kwh</code> <code>7.467735503</code> <code>float</code> <code>vehicle_glider_cost_dol</code> <code>112759</code> <code>float</code> ##### MSRP Formula  Text Only<pre><code>vehicle_glider_cost_dol = scenario.vehicle_glider_cost_dol\n\n# fcPrice\nif veh.veh_pt_type == gl.BEV or veh.fc_max_kw == 0:\n    fcPrice = 0\n\nelif veh.fc_eff_type == 'H2FC':\n    fcPrice = scenario.fc_fuelcell_cost_dol_per_kw * fc_max_kw\n\nelif veh.fc_eff_type == 9:\n    fcPrice = ((scenario.fc_cng_ice_cost_dol_per_kw * fc_max_kw) + fc_ice_base_cost_dol)\n\nelse:\n    fcPrice = ((fc_ice_cost_dol_per_kw * fc_max_kw) + fc_ice_base_cost_dol)\nfcPrice *= markup_pct\n\n# fuelStorPrice\nif veh.veh_pt_type == gl.BEV:\n    fuelStorPrice = 0\nelif veh.veh_pt_type == gl.HEV and scenario.fuel_type == 'hydrogen':\n    fuelStorPrice = scenario.fs_h2_cost_dol_per_kwh * veh.fs_kwh\nelif veh.veh_pt_type in [gl.CONV, gl.HEV, gl.PHEV] and scenario.fuel_type == 'cng':\n    fuelStorPrice = scenario.fs_cng_cost_dol_per_kwh * veh.fs_kwh\nelif veh.veh_pt_type in [gl.CONV, gl.HEV, gl.PHEV]:\n    fuelStorPrice = scenario.fs_cost_dol_per_kwh * veh.fs_kwh\nfuelStorPrice *= markup_pct\n\n# calculate mcPrice\nmc_max_kw = veh.mc_max_kw\nif mc_max_kw == 0:\n    mcPrice = 0\nelse:\n    mcPrice = (pe_mc_base_cost_dol + (pe_mc_cost_dol_per_kw * mc_max_kw))\nmc_max_kw *= markup_pct\n\n# calc ESS price\nif veh.ess_max_kwh == 0:\n    essPrice = 0\nelse:\n    essPrice = (ess_base_cost_dol + (ess_cost_dol_per_kwh * veh.ess_max_kwh))\nessPrice *= markup_pct\n\n# calc plugPrice\nif veh_pt_type == gl.PHEV or veh_pt_type == gl.BEV or (veh_pt_type == gl.HEV and chargingOn):\n    plugPrice = plugPrice\nelse:\n    plugPrice = 0\nplugPrice *= markup_pct\n\nif veh_pt_type == gl.CONV:\n    msrp = vehicle_glider_cost_dol + fuelStorPrice + fcPrice\n# could be HEV or FCEV\nelif veh_pt_type == gl.HEV:\n    msrp = vehicle_glider_cost_dol + fuelStorPrice + fcPrice + mcPrice + essPrice\nelif veh_pt_type == gl.PHEV:\n    msrp = vehicle_glider_cost_dol + fuelStorPrice + fcPrice + mcPrice + essPrice + plugPrice\nelif veh_pt_type == gl.BEV:\n    msrp = vehicle_glider_cost_dol + mcPrice + essPrice + plugPrice\n\npTaxCost = tax_rate_pct * msrp\n\ncost_set = {\n    \"Glider\": vehicle_glider_cost_dol,\n    \"Fuel converter\": fcPrice,\n    \"Fuel Storage\": fuelStorPrice,\n    \"Motor &amp; power electronics\": mcPrice,\n    \"Plug\": plugPrice,\n    \"Battery\": essPrice,\n    \"Battery replacement\": 0,\n    \"Purchase tax\": pTaxCost,\n    \"msrp\": msrp\n}\n</code></pre>"},{"location":"models/TCO_calculations/#msrp-code","title":"MSRP Code","text":"<p>Code to generate MSRP</p>"},{"location":"models/TCO_calculations/#fuel-costs","title":"Fuel Costs","text":"<p>Fuel costs make up a plurality, if not the majority, of TCO. As one would expect, fuel costs per year are dependant on three things: The fuel efficiency of the vehicle, the miles travelled per year, and the cost per unit of fuel. All fuel efficiencies are converted to miles per gallon of gasoline equivalent (MPGGE). All fuel costs are converted to dollars per gallon of gasoline equivalent.  Text Only<pre><code>sum up all years\n  fuel_cost_year_i = miles_travelled_year_i / mpgge * $/gge\n</code></pre> Fuel efficiency is populated (code) as per these docs. </p> Model Year Region Vehicle Vocation Fuel Fuel Efficiency [mi/gge] Age [yr] 2022 United States MD BOX TRUCK BOX TRUCK Diesel 4.6 <p>This table is eventually joined in the Stock Model Code with other tables. For example, if the vehicle has a 5 year life span:</p> Year Fuel Category Cost [$/gge] 2022 Diesel Fuel 3.98 2023 Diesel Fuel 4.10 2024 Diesel Fuel 4.20 2025 Diesel Fuel 4.29 2026 Diesel Fuel 4.35 <p>Then there is the annual travel table (code), made up from <code>vmt</code> in the Scenario file </p> Age [yr] Annual Travel [mi/yr] 0 100,000 1 100,000 2 90,000 3 85,000 4 80,000 <p>Finally, these are all joined with the fuel split table (code), such that each fuel used is assessed pro rata based on the proportion of usage for driven miles. This comes into play for PHEVs and their Utility Factor</p> <p>Usual Conventional or HEV format: |Vehicle|Fuel|Vocation|Fraction of Travel [mi/mi]| |----|----|----|----| |MD BOX TRUCK|Diesel|BOX TRUCK| 1 | Or BEV Format:  |Vehicle|Fuel|Vocation|Fraction of Travel [mi/mi]| |----|----|----|----| |MD EV BOX TRUCK|Electricity|BOX TRUCK| 1 |</p> <p>PHEV format, where utility factor is .6 (60% of the time vehicle is in charge depleting mode): |Vehicle|Fuel|Vocation|Fraction of Travel [mi/mi]| |----|----|----|----| |MD PHEV BOX TRUCK|cd_diesel|BOX TRUCK| .6 | |MD PHEV BOX TRUCK|cd_electricity|BOX TRUCK| .6 | |MD PHEV BOX TRUCK|cs_diesel|BOX TRUCK| .4 |</p> <p>These joins happen in the Stock Model Code.</p>"},{"location":"models/TCO_calculations/#other-costs","title":"Other Costs","text":"<p>There are other costs for vehicles during their TCO operational period (code). These costs are, but not limited to, maintenance costs  <code>$/mile</code>, for both conventional and advanced powertrains, denoted from the Scenario input file as <code>maint_oper_cost_dol_per_mi</code> provided as a list across the vehicle life</p> <p>There is also <code>payload opportunity cost</code> (under development), as well as optional <code>time opportunity costs</code> and <code>labor opportunity costs</code>. Also under development.</p> <p>other costs table</p> Region Vocation Vehicle Category Cost [$/mi] United States BOX TRUCK MD BOX TRUCK maintenance .32 United States BOX TRUCK MD BOX TRUCK payload opp cost 0 United States BOX TRUCK MD BOX TRUCK time opp cost\" 0 United States BOX TRUCK MD BOX TRUCK labor opp cost 0"},{"location":"models/TCO_calculations/#payload-opportunity-costs","title":"Payload Opportunity Costs","text":"<p>Payload Opportunity Cost is the concept of applying an opportunity cost to payload capacity that might be lost due to increasing a vehicle vocation empty weight when electrifying the powertrain. In the example below, the empty weight of the vehicle increased by 11,958 pounds. This region, less the EV weight credit of 2,000 pounds, is shaded in red under the kernel density estimate, representing potential lost cargo due to electrification and added battery weight.</p> <p></p>"},{"location":"models/TCO_calculations/#stock-model-tco-calculations","title":"Stock Model TCO Calculations","text":"<p>Total vehicle costs are compiled via a series elegant of table <code>INNER JOINS</code> in the stock model code. </p>"},{"location":"models/TCO_calculations/#bev-considerations","title":"BEV considerations","text":"<p>Vehicles that run on alternative fuels such as BEVs, FCEVs (treated as HEV by FASTSim), run on fuels, such as hydrogen or electricity, that need to be converted to a gallon of gasoline equivalent unit for fuel efficiency, <code>MPGGE</code>, and cost, <code>$/GGE</code>. The code where these conversions happen is here:</p>"},{"location":"models/TCO_calculations/#phev-considerations","title":"PHEV considerations","text":"<p>PHEVs have the same considerations as BEVs, but with the added twist of Utility Factors, which can come in as a user input in the Scenario File, or get computed. See PHEV Considerations.</p>"},{"location":"models/TCO_calculations/#fuel-costs-table","title":"Fuel Costs Table","text":"<p>The default fuel costs table is located at <code>t3co/resources/auxiliary/FuelPrices.csv</code></p>"},{"location":"models/acceleration_and_grade_tests/","title":"Acceleration and Grade","text":"<ul> <li>Accel and Grade Test Overview</li> <li>Accel and Grade Test Target Inputs</li> <li>Default Initial SOCs</li> </ul>"},{"location":"models/acceleration_and_grade_tests/#accel-and-grade-test-overview","title":"Accel and Grade Test Overview","text":"<p>The vehicle is tested to determine if its powertrain is powerful enough to achieve or exceed its grade and acceleration targets. </p>"},{"location":"models/acceleration_and_grade_tests/#acceleration-test","title":"Acceleration Test","text":"<p>Acceleration Test code</p> <p>There are two tests: - seconds to achieve zero to sixty mph - seconds to achieve zero to thirty mph</p> <p>The test is done with the vehicle usually at <code>scenario.gvwr_kg + scenario.GvwrCreditK</code>, or just at normal weight.</p> <p>The vehicle is given a synthetic drive cycle of 300 seconds of length with zero grade. The vehicle is forced to run at top speed immediately. A test is done to see if the vehicle reaches the target speeds of 30 and 60 mph. If the vehicle reaches those speeds, interpolation is performed to compute the precise second at which the vehicle reaches those target speeds. The test passes, for example, if the second that the vehicle reaches 30 mph is <code>&lt;= max_time_0_to_30mph_at_gvwr_s</code>. The test returns the acceleration time for the two tests in seconds.</p>"},{"location":"models/acceleration_and_grade_tests/#grade-test","title":"Grade Test","text":"<p>Grade Test code</p> <p>Likewise, there are two tests for Grade. The grade tests measure the max speed [MPH] reached by the vehicle at 6% grade and 1.25% grade within 5 minutes. The grade test returns the max speed achieved [MPH] for the two tests.</p> <p>The test is done with the vehicle usually at <code>scenario.gvwr_kg + scenario.GvwrCreditK</code>, or just at normal weight.</p>"},{"location":"models/acceleration_and_grade_tests/#accel-and-grade-test-target-inputs","title":"Accel and Grade Test Target Inputs","text":"<p>Inputs from the T3CO input file:</p> test scenario input value Acceleration 0 to 60 max_time_0_to_60mph_at_gvwr_s <code>seconds, int &gt; 0</code> Acceleration 0 to 30 max_time_0_to_30mph_at_gvwr_s <code>seconds, int &gt; 0</code> Min speed at 6% grade [MPH] min_speed_at_6pct_grade_in_5min_mph <code>MPH, int &gt; 0</code> Min speed at 1.25% grade [MPH] min_speed_at_1p25pct_grade_in_5min_mph <code>MPH, int &gt; 0</code>"},{"location":"models/acceleration_and_grade_tests/#default-initial-socs","title":"Default Initial SOCs","text":"<p>The default behavior, what the code does for inital SOC for tests in the absense of any input for <code>ess_init_soc_grade/accel</code>, or <code>ess_init_soc_for_grade/accel</code>, is a mix of FASTSim's default behaviors and some overrides that T3CO configures. </p> Text Only<pre><code>init_soc comes from simdrive()\n    BEVs use max_soc\n    PHEVs use max_soc\n    Conv init_soc doesn't matter\n\nif the vehicle is a HEV\n    For accel, initial SOC is (max_soc + min_soc) / 2.0\n    For grade, initial SOC is min_soc\n\nor if ess_init_soc is passed to get_gradeability and get_accel\n\nfor PHEVs, there is an additional setting for ess_init_soc\n    soc_norm_init_for_accel_pct # column in Scenario file\n    soc_norm_init_for_grade_pct # column in Scenario file\n    These values are in the range 0 to 1 (0 is min_soc)\n\n    For example, for the accel test\n    init_soc = min_soc + (soc_norm_init_for_accel_pct * (max_soc - min_soc))\n</code></pre>"},{"location":"models/fuel_efficiency_and_range/","title":"Contents","text":"<ul> <li>Fuel Efficiency Calculations</li> <li>Range From Fuel Efficiency</li> <li>A Note on PHEVs</li> </ul>"},{"location":"models/fuel_efficiency_and_range/#fuel-efficiency-calculations","title":"Fuel Efficiency Calculations","text":"<p>Fuel efficiency calculations in T3CO yield a variety of metrics based on the energy output from the vehicle's fuel stores and battery, taken from FASTSim.SimDrive object results. For the purposes of finding vehicle range [miles] and fuel efficiency, If the user inputs a composit drive cycle, then the fuel efficiency is a blend computed from each drive cycle's mpgge (miles per gallon of gasoline equivalent, for example) and that drive cycle's weight, using a weighted harmonic average.</p> <p></p> <p>Composite drive cycle input example: <code>[(\"EPA_Ph2_rural_interstate_65mph.csv\", .86), (\"EPA_Ph2_urban_highway_55mph.csv\", .09), (\"EPA_Ph2_transient.csv\", .05)]</code></p> <p>Input file example:</p> selection scenario_name drive_cycle 1 Class 8 Sleeper cab high roof (Diesel, 2020, no program) [(\"EPA_Ph2_rural_interstate_65mph.csv\", .86), (\"EPA_Ph2_urban_highway_55mph.csv\", .09), (\"EPA_Ph2_transient.csv\", .05)] 2 Class 8 Sleeper cab mid roof (Diesel, 2020, no program) [(\"EPA_Ph2_rural_interstate_65mph.csv\", .86), (\"EPA_Ph2_urban_highway_55mph.csv\", .09), (\"EPA_Ph2_transient.csv\", .05)] 3 Class 8 Sleeper cab low roof (Diesel, 2020, no program) [(\"EPA_Ph2_rural_interstate_65mph.csv\", .86), (\"EPA_Ph2_urban_highway_55mph.csv\", .09), (\"EPA_Ph2_transient.csv\", .05)] <p>fuel efficiency metrics are computed in <code>t3co.objectives.fuel_economy.py</code></p> <p>For Conventionals, BEVs, HEVs/FCEVs, we calculate their fuel economies as |Code Variable| Definition | |--|--| |mpgge | miles per gallon of gasoline equivalent | |grid_mpgge | grid adjusted (charger efficiency) miles per gallon of gasoline equivalent | |mpgde | miles per gallon of diesel equivalent | |kwh_per_mi | kWh per mile |</p> <p>For plug-in hybrids (PHEVs) we calculate </p> Code Variable Definition cs_fuel_mpgge Charge Sustaining miles per gallon of gasoline equivalent from ICE fuel stores only cs_fuel_mpgde Charge Sustaining miles per gallon of diesel equivalent from ICE fuel stores only cs_fuel_kwh__mi Charge Sustaining kWh per mile from ICE fuel stores only cd_fuel_mpgge Charge Depleting miles per gallon of gasoline equivalent from ICE fuel stores only cd_fuel_mpgde Charge Depleting miles per gallon of diesel equivalent from ICE fuel stores only cd_electric_mpgge Charge Depleting miles per gallon of gasoline equivalent from PHEV battery pack only cd_grid_electric_mpgge Charge Depleting grid adjusted (charger efficiency) miles per gallon of gasoline equivalent from PHEV battery pack only cd_electric_kwh__mi Charge Depleting kWh per mile from PHEV battery pack only cd_fuel_kwh__mi Charge Depleting kWh per mile from ICE fuel stores only ave_combined_kwh__mile Average combined kWh per mile <code>AveCombinedkWhperMile = UF*(CDelectricityKWhperMile + CDfuelKWhpermile) + (1-UF)*CSfuelKWhperMile</code> <p>Note, UF stands for Utility Factor</p> <p>For each drive cycle in the T3CO scenario file, a weighted value for these fuel economy metrics is calculated. </p>"},{"location":"models/fuel_efficiency_and_range/#range-from-fuel-efficiency","title":"Range From Fuel Efficiency","text":"<p>The process for determining range depends on determining the fuel economy of the vehicle based on design cycles or a set of design cycles with weights. Design cycle or composite design cycles are specifed in the <code>Scenario</code> input file under the <code>drive_cycle</code> column. Fuel economy is determined in the <code>t3co\\objectives\\fueleconomy.py</code> module. The logic for fuel economy is essentially Text Only<pre><code>for cycle_i, weight_i in (cycles, cycle_weights)\n    if PHEV\n        get charge depleting mpgge with infinite battery and init_soc = max_soc\n        get charge sustaining mpgge with \"normal\" battery and init_soc = min_soc + 0.01 \n    else\n        init_soc comes from simdrive()\n        BEVs use max_soc\n        HEVs use balanced SOC\n        Conv init_soc doesn't matter\n        if vehicle is Conv or HEV\n            mpgge = sim_drive.mpgge\n        else it's a BEV\n            mpgge = sim_drive.mpgge + (1/sim_drive.electric_kwh_per_mi) * gl.get_kwh_per_gge()\n\n    # get weighted mpgge vales\n    'mpgge': sum([w_i for w_i in weights]) / sum([w_i / mpgge_i['mpgge'] for w_i, mpgge_i in zip(weights, mpgges)])\n</code></pre></p> <p>Range from fuel economy is a calculation based on the vehicle's MPGGE (miles per gallon of gasoline equivalent) and the GGE energy storage capacity the vehicle has. This is computed in <code>t3co.objectives.fuel_economy.get_range_mi</code>. </p> Text Only<pre><code>if vehicle is a BEV:\n    range_mi = vehicle.ess_max_kwh * (vehicle.max_soc - vehicle.min_soc) * electric_mpgge / kwh_per_gge\nelif vehicle is a Conventional ICE:\n    range_mi = (vehicle.fs_kwh / kwh_per_gge) * mpgge\nelif vehicle is an HEV:\n    elec_range_mi = vehicle.ess_max_kwh * (vehicle.max_soc - vehicle.min_soc) * mpgge / kwh_per_gge\n    conv_range_mi = (vehicle.fs_kwh / kwh_per_gge) * mpgge\n    range_mi = elec_range_mi + conv_range_mi\nelif vehicle is a PHEV:\n    # charge depleting range [miles]\n    # CDrangeMiles = MIN( ESSmaxKWh*(CDmaxSOC- CDminSOC)/ CDelectricityKWhperMile , maxFuelStorKWh/33.7/ CDfuelGGEperMile )\n    cd_range_mi = min(\n        vehicle.ess_max_kwh * (vehicle.max_soc - vehicle.min_soc) / mpgge_info['cd_electric_kwh__mi'],\n        vehicle.fs_kwh / kwh_per_gge * mpgge_info['cd_fuel_mpgge']\n    )\n    # charge sustaining range [miles]\n    # note, CS range in this way of thinking, is essentially what range is *left over* after you've exhausted the battery to min SOC \n    # and switch into CS mode from CD mode, thus we subtract cd_gge_used from the GGE fuel stores of the vehicle\n    cd_gge_used = cd_range_mi / mpgge_info['cd_fuel_mpgge']\n    gge_capacity = vehicle.fs_kwh / kwh_per_gge\n    cs_range_mi = (gge_capacity - cd_gge_used) * mpgge_info['cs_fuel_mpgge']\n    range_mi = cd_range_mi + cs_range_mi\nreturn range_mi\n</code></pre>"},{"location":"models/fuel_efficiency_and_range/#a-note-on-phevs","title":"A Note on PHEVs","text":""},{"location":"models/fuel_efficiency_and_range/#phev-fuel-economy","title":"PHEV fuel economy","text":"<p>The CD and CS in the PHEV fuel economy table stand for charge sustaining and charge depleting, these are two defined \"modes\" of operation described below. These are described in detail in the PHEV documentation.</p> <p>PHEVs generate multiple metrics for fuel efficiency based on the two operating modes, CD and CS. As seen above, they are used for for computing the range of the vehicle. </p>"},{"location":"models/optimization/","title":"Contents","text":"<ul> <li>Optimization Overview</li> <li>Optimization from Sweep Module</li> <li>Optimization Inputs</li> <li>Conventional Considerations</li> <li>BEV Considerations</li> <li>HEV/FCEV Considerations</li> <li>PHEV Considerations</li> </ul>"},{"location":"models/optimization/#optimization-overview","title":"Optimization Overview","text":"<p>By default, T3CO uses pymoo to minimize TCO while meeting constraints on required performance metrics (range, acceleration, grade). </p> Text Only<pre><code>Objective (minimized):\nTCO, PHEV_MINIMIZE_FUEL_USE_OBJECTIVE\n\nConstraints (met):\nRANGE, ACCEL, GRADE\n</code></pre> <p>In general, all knobs that apply to each powertrain will be active.</p> <p>A blank in either min or max of the knob will disable that knob. (use value from vehicle input) A blank in eng_eff_imp_curve_sel, aero_drag_imp_curve_sel, and ltwt_imp_curve will turn those off. (set to cda imp and ltwt redux to zeros, and leave fuel converter peak efficiency unchanged)</p> Text Only<pre><code># Decision variables / \"knobs\":\nfs_kwh     (liquid fuel tank or hydrogen tank)\nfc_max_kw (engine or fuel cell size kw) \ness_max_kwh  (battery size kwh)\nmc_max_kw (motor size kw)\nCdA_perc_imp (aerodynamic drag coefficient)\nfc_peak_eff (engine peak efficiency - adjusts the entire engine efficiency curve. Power on x axis, y axis is efficiency)\nwt_delta_perc (light weighting percent off of baseline vehicle mass)\n\nBEV: {wt_delta_perc, CdA_perc_imp, ess_max_kwh, mc_max_kw}\nHEV: {wt_delta_perc, CdA_perc_imp, fc_peak_eff, ess_max_kwh, mc_max_kw, fc_max_kw, fs_kwh}\nCONV: {wt_delta_perc, CdA_perc_imp, fc_peak_eff, fc_max_kw, fs_kwh}\nFCEV: {wt_delta_perc, CdA_perc_imp, fc_peak_eff, ess_max_kwh, mc_max_kw, fc_max_kw, fs_kwh}\n</code></pre>"},{"location":"models/optimization/#all-applicable-constraint-targets-for-each-powertrain","title":"All applicable constraint targets for each powertrain","text":"Text Only<pre><code>BEV: RANGE, ACCEL, GRADE, TCO\nHEV: ACCEL, GRADE, TCO\nCONV: ACCEL, GRADE, TCO\nFCEV: RANGE, ACCEL, GRADE, TCO ??? &lt; verify\n</code></pre>"},{"location":"models/optimization/#optimization-from-sweep-module","title":"Optimization from Sweep Module","text":"<p>One way to activate optimization, and the general code flow, is to use sweep.py. The optimization algorithms available are enumerated in the moo module.</p> <p>An example use, employing both NSGA2 and PatternSearch in an ensemble optimization approach:</p> Text Only<pre><code>    python sweep.py  -algorithms \"['NSGA2', 'PatternSearch']\" -dir_mark \"multi-algo-test\" -dst_dir C:\\Users\\users\\Documents\\testruns\\multialgo-test3 -selections \"range(0,140)\"\n</code></pre>"},{"location":"models/optimization/#optimization-inputs","title":"Optimization Inputs","text":""},{"location":"models/optimization/#example-means-of-specifying-targets-in-scenario-file","title":"example means of specifying targets in scenario file","text":"target_range_mi min_speed_at_6pct_grade_in_5min_mph min_speed_at_1p25pct_grade_in_5min_mph max_time_0_to_60mph_at_gvwr_s max_time_0_to_30mph_at_gvwr_s 750 30 65 80 20 750 30 65 80 20 750 30 65 80 20"},{"location":"models/optimization/#example-means-of-specifying-improvement-cost-curves-in-scenario-file","title":"example means of specifying improvement cost curves in scenario file","text":"lw_imp_curve_sel eng_eff_imp_curve_sel aero_drag_imp_curve_sel MDHD_xyz MDHD_large_noprogram_2025 MDHD_abcdef <p>See: EngineEffImprovementCostCurve.csv</p> <p>where small medium large engine sizes refers to  6.7 L,   &lt;250 kW 11 L 15 L 250-375 kW according to the LD MDHD Benefits Analysis Assumptions FY2021 spreadsheet</p> -\u00a0 L hp kW class 4,5 all applications 7 200 149 class 6,7 all applications 7 270 201 class 8 urban 11 350 261 class 8 regional &amp; multipurpose 11 or 15 350 or 455 261 or 339 class 7 day cabs 11 350 261 class 8 day and sleeper cabs 15 455 339 <p>In the scenario file: specify the following variables with the appropriate improvement cost curve, with the available options being in: AeroDragImprovementCostCurve</p> <p>The improvement cost curve files include optimizer knob bounds specified for CdA and engine efficiency (dependent on vehicle type and scenario and year, based on the Technology Manager inputs and Alicia Birky), and lightweighting (allowed to lightweight over full curve).</p> <p>For the other decision variables / knobs, the scenario file will need to specify reasonable (i.e. physically feasible and sensible) optimizer knob bounds for: <code>knob_min_ess_kwh, knob_min_motor_kw, knob_min_fc_kw, knob_max_ess_kwh, knob_max_motor_kw, knob_max_fc_kw</code> (code will use the appropriate combinations of fc/motor/ess for each powertrain)</p>"},{"location":"models/optimization/#example-of-engine-cost-curves-input-referred-to-via-scenario-file-selection-in-eng_eff_imp_curve_sel-column","title":"example of engine cost curves input, referred to via scenario file selection in <code>eng_eff_imp_curve_sel</code> column","text":"name MDHD_large_noprogram_2020 MDHD_large_noprogram_2025 eng_cost [0,0.35,6,13.25,14.15,30.7,39.8] [0,0.35,7.35,25.65,32.45] eng_pctpt [0.45,0.49,0.52,0.52,0.53,0.53,0.59] [0.45,0.49,0.53,0.53,0.59] fc_peak_eff_knob_max 0.481405 0.492 fc_peak_eff_knob_min 0.45 0.45"},{"location":"models/optimization/#drive-cycles-for-optimization","title":"Drive Cycles for Optimization","text":"<p>design cycle will be a composite of the 3 standard EPA drive cycles</p>"},{"location":"models/optimization/#initialdefault-weights","title":"initial/default weights","text":"rural urban transient 86 9 5 <p>These are the EPA weights for Sleeper cabs. From EPA_RIA_Inputs, we will input appropriate cycle weights for each size class.</p> <p>rural     = EPA_Ph2_rural_interstate_65mph.csv urban     = EPA_Ph2_urban_highway_55mph.csv transient = EPA_Ph2_transient.csv</p>"},{"location":"models/optimization/#vehicle-input-file-example-for-drive_cycle","title":"vehicle input file example for drive_cycle","text":"selection scenario_name drive_cycle \u2026 1 Class 8 Sleeper cab (Diesel, 2021, program success) [(EPA_Ph2_rural_interstate_65mph.csv, .86),   (EPA_Ph2_urban_highway_55mph.csv, .09), (EPA_Ph2_transient.csv, .05)] \u2026 2 Class 8 Sleeper cab (Diesel, 2027, program success) [(EPA_Ph2_rural_interstate_65mph.csv, .86),   (EPA_Ph2_urban_highway_55mph.csv, .09), (EPA_Ph2_transient.csv, .05)] \u2026"},{"location":"models/optimization/#conventional-considerations","title":"Conventional Considerations","text":""},{"location":"models/optimization/#bev-considerations","title":"BEV Considerations","text":""},{"location":"models/optimization/#hevfcev-considerations","title":"HEV/FCEV Considerations","text":""},{"location":"models/optimization/#phev-considerations","title":"PHEV Considerations","text":""},{"location":"models/optimization/#motor_power_override_kw_fc_demand_on_pct","title":"<code>motor_power_override_kw_fc_demand_on_pct</code>","text":"<p>During PHEV optimization, an adjustment for PHEVs that is not made for any other powertrain types to the value of <code>kw_demand_fc_on</code> for the vehicle. <code>kw_demand_fc_on</code> is a vehicle file input and a type of hyrbid vehicle controls parameter. This parameter is the kW threshold of power demand from the drive cycle at which the fuel converter is activated to meet trace. In order to have the kW threshold float along with the sizing of the motor during optimization, T3CO sets the value of <code>kw_demand_fc_on</code> based on a set percentage of the motor size, <code>motor_power_override_kw_fc_demand_on_pct</code>. This percentage is specified in the T3CO scenario file. </p> <p>If this percentage is not specified in the T3CO scenario file, then <code>kw_demand_fc_on</code> is not adjusted and remains the static value from the vehicle input file. <code>motor_power_override_kw_fc_demand_on_pct</code> overrides <code>kw_demand_fc_on</code>. If neither are provided then T3CO will error out.</p> <p>This adjustment happens in <code>t3co.run_scenario.set_max_motor_kw(vehicle, new_kw_value)</code> when the optimization loop calls <code>set_max_motor_kw</code></p> Text Only<pre><code>if vehicle.veh_pt_type == PHEV:\n    vehicle.mc_max_kw = optimization_function(TCO, grade and acceleration performance)\n    kw_demand_fc_on = motor_power_override_kw_fc_demand_on_pct * vehicle.mc_max_kw\n</code></pre>"},{"location":"models/run_script_readme/","title":"Run script readme","text":"<p>All the scripts in here assume that you've run <code>pip install -e .</code> from the root level of the github repo, thus allowing T3CO to be imported as a module.  </p>"},{"location":"models/tco_ReadMe/","title":"ReadMe for Stock Model Framework","text":""},{"location":"models/tco_ReadMe/#overview","title":"Overview","text":"<ul> <li>Please visit http://nrel.github.io/sera/ for detailed documentation on the SERA model (Stock Module will be of most interest to you)</li> <li>The SERA model was developed since the late 2000s, primarily funded for FCTO projects (most have GitHub repos that can be found here: https://github.nrel.gov/SERA)</li> <li>The model is primarily used for H2 infrastructure (LDV station placement over time, hydrogen supply chain optimization (production plant siting, trucks/pipeline placement and flows) across the US)</li> <li>The Stock Model is a general stock model framework analogous to the ANL VISION model but with the capability of much more spatial and temporal fidelity (and without the fudge factors)</li> <li>The SERA Stock Model algorithm is fairly general and the user has a lot of responsibility to create, validate, and use the correct, data-heavy input files (this allows the same algorithm to be very flexibly used - an attribute I spoke with Jason about)</li> </ul>"},{"location":"models/tco_ReadMe/#sera-executable","title":"SERA Executable","text":"<ul> <li>The actual SERA model is written in Haskell and is compiled into an executable file that one can run on Linux, Windows, and Mac machines</li> <li>Location of latest exe version is on Eagle at: /projects/sera/old-versions/sera-3.3.1.9</li> <li>Some aspects of the SERA model are currently being moved to the language Julia which has the potential to be much faster and more people understand the language</li> </ul>"},{"location":"models/tco_ReadMe/#sera-in-python","title":"SERA in Python","text":"<ul> <li>I (Chad) have replicated some of the SERA stock model functionality in Python to improve computation speed (using the Pandas package)</li> <li>The Python version of the stock module has been validated to match the Haskell version</li> <li>There are a number of ways to make the code faster and even more robust which will be useful if it is going to be used for additional products</li> </ul>"},{"location":"models/tco_ReadMe/#examples-this-folder","title":"Examples / This Folder","text":"<ul> <li>I have included some example input files and the Python version of SERA's stock model in this folder</li> <li>We can discuss in more detail when I am back in the office, but feel free to browse the files to understand the structure and format</li> </ul>"},{"location":"models/tco_ReadMe/#more-documentation","title":"More Documentation","text":"<ul> <li>For more information, please see the FCTO Market Segmentation report on the y-drive here</li> <li>Additionally, much of the TCO analysis for that project was done in R. Most files are here</li> </ul>"}]}